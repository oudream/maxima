@c Language: Portuguese
@c /distrib.texi/1.3/Mon Jan  1 07:18:27 2007//
@menu
* Introdução a distrib::
* Definições para distribuições contínuas::
* Definições para distribuições discretas::
@end menu

@node Introdução a distrib, Definições para distribuições contínuas, distrib, distrib
@section Introdução a distrib


Pacote @code{distrib} contém um conjunto de funções para fazer cálculos 
envolvendo probabilidades de modelos de uma única variável estatística e de 
ambos os tipos discreta e contínua. 

O que segue é um curto resumo de definiçoes básicas
relacionadas à teoria das probabilidades.

Seja @math{f(x)} a @var{função densidade de probabilidade} absoluta 
de uma variável aleatória contínua @math{X}. A @var{função 
distribuição de probabilidade} é definida como
@ifhtml
@example
                       x
                      /
                      [
               F(x) = I     f(u) du
                      ]
                      /
                       minf
@end example
@end ifhtml
@ifinfo
@example
                       x
                      /
                      [
               F(x) = I     f(u) du
                      ]
                      /
                       minf
@end example
@end ifinfo
@tex
$$F\left(x\right)=\int_{ -\infty }^{x}{f\left(u\right)\;du}$$
@end tex
que é igual à probabilidade @var{Pr(X <= x)}.

O valor @var{médio} é um parâmetro de localização e está definido como
@ifhtml
@example
                     inf
                    /
                    [
           E[X]  =  I   x f(x) dx
                    ]
                    /
                     minf
@end example
@end ifhtml
@ifinfo
@example
                     inf
                    /
                    [
           E[X]  =  I   x f(x) dx
                    ]
                    /
                     minf
@end example
@end ifinfo
@tex
$$E\left[X\right]=\int_{ -\infty }^{\infty }{x\,f\left(x\right)\;dx}$$
@end tex

A @var{variância} é uma medida de variação,
@ifhtml
@example
                 inf
                /
                [                    2
         V[X] = I     f(x) (x - E[X])  dx
                ]
                /
                 minf
@end example
@end ifhtml
@ifinfo
@example
                 inf
                /
                [                    2
         V[X] = I     f(x) (x - E[X])  dx
                ]
                /
                 minf
@end example
@end ifinfo
@tex
$$V\left[X\right]=\int_{ -\infty }^{\infty }{f\left(x\right)\,\left(x
 -E\left[X\right]\right)^2\;dx}$$
@end tex
que é um número real positivo. A raíz quadrada da variância é o
@var{desvio padrão}, @math{D[X]=sqrt(V[X])}, e esse @var{desvio padrão}
é outra medida de variação.

O @var{coeficiente de assimetria} é uma medida de não simetria,
@ifhtml
@example
                 inf
                /
            1   [                    3
  SK[X] = ----- I     f(x) (x - E[X])  dx
              3 ]
          D[X]  /
                 minf
@end example
@end ifhtml
@ifinfo
@example
                 inf
                /
            1   [                    3
  SK[X] = ----- I     f(x) (x - E[X])  dx
              3 ]
          D[X]  /
                 minf
@end example
@end ifinfo
@tex
$$SK\left[X\right]={{\int_{ -\infty }^{\infty }{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^3\;dx}}\over{D\left[X\right]^3}}$$
@end tex

E o @var{coeficiente de curtose} mede o grau de achatamento de uma distribuição,
@ifhtml
@example
                 inf
                /
            1   [                    4
  KU[X] = ----- I     f(x) (x - E[X])  dx - 3
              4 ]
          D[X]  /
                 minf
@end example
@end ifhtml
@ifinfo
@example
                 inf
                /
            1   [                    4
  KU[X] = ----- I     f(x) (x - E[X])  dx - 3
              4 ]
          D[X]  /
                 minf
@end example
@end ifinfo
@tex
$$KU\left[X\right]={{\int_{ -\infty }^{\infty }{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^4\;dx}}\over{D\left[X\right]^4}}-3$$
@end tex
Se @math{X} for gaussiana, @math{KU[X]=0}. De facto, ambos assimetria e curtose são
parâmetros de ajuste usados para medir a não gaussianidade de uma distribuição.

Se a variável aleatória @math{X} for discreta, a função densidade
de probabilidade, ou simplesmente @var{probabilidade}, @math{f(x)} toma valores
positivos dentro de certos conjuntos contáveis de números @math{x_i},
e zero em caso contrário. Nesse caso, a função
distribuição de probabilidade é
@ifhtml
@example
                       ====
                       \
                F(x) =  >    f(x )
                       /        i
                       ====
                      x <= x
                       i
@end example
@end ifhtml
@ifinfo
@example
                       ====
                       \
                F(x) =  >    f(x )
                       /        i
                       ====
                      x <= x
                       i
@end example
@end ifinfo
@tex
$$F\left(x\right)=\sum_{x_{i}\leq x}{f\left(x_{i}\right)}$$
@end tex

A média, variância, desvio padrão, coeficiente de assimetria e coeficiente de curtose tomam a forma
@ifhtml
@example
                       ====
                       \
                E[X] =  >  x  f(x ) ,
                       /    i    i
                       ====
                        x 
                         i
@end example
@end ifhtml
@ifinfo
@example
                       ====
                       \
                E[X] =  >  x  f(x ) ,
                       /    i    i
                       ====
                        x 
                         i
@end example
@end ifinfo
@tex
$$E\left[X\right]=\sum_{x_{i}}{x_{i}f\left(x_{i}\right)},$$
@end tex

@ifhtml
@example
                ====
                \                     2
        V[X] =   >    f(x ) (x - E[X])  ,
                /        i    i
                ====
                 x
                  i
@end example
@end ifhtml
@ifinfo
@example
                ====
                \                     2
        V[X] =   >    f(x ) (x - E[X])  ,
                /        i    i
                ====
                 x
                  i
@end example
@end ifinfo
@tex
$$V\left[X\right]=\sum_{x_{i}}{f\left(x_{i}\right)\left(x_{i}-E\left[X\right]\right)^2},$$
@end tex

@ifhtml
@example
               D[X] = sqrt(V[X]),
@end example
@end ifhtml
@ifinfo
@example
               D[X] = sqrt(V[X]),
@end example
@end ifinfo
@tex
$$D\left[X\right]=\sqrt{V\left[X\right]},$$
@end tex

@ifhtml
@example
                     ====
              1      \                     3
  SK[X] =  -------    >    f(x ) (x - E[X])  
           D[X]^3    /        i    i
                     ====
                      x
                       i
@end example
@end ifhtml
@ifinfo
@example
                     ====
              1      \                     3
  SK[X] =  -------    >    f(x ) (x - E[X])  
           D[X]^3    /        i    i
                     ====
                      x
                       i
@end example
@end ifinfo
@tex
$$SK\left[X\right]={{\sum_{x_{i}}{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^3\;dx}}\over{D\left[X\right]^3}}$$
@end tex
and
@ifhtml
@example
                     ====
              1      \                     4
  KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
           D[X]^4    /        i    i
                     ====
                      x
                       i
@end example
@end ifhtml
@ifinfo
@example
                     ====
              1      \                     4
  KU[X] =  -------    >    f(x ) (x - E[X])   - 3 ,
           D[X]^4    /        i    i
                     ====
                      x
                       i
@end example
@end ifinfo
@tex
$$KU\left[X\right]={{\sum_{x_{i}}{f\left(x\right)\,
 \left(x-E\left[X\right]\right)^4\;dx}}\over{D\left[X\right]^4}}-3,$$
@end tex
respectively.

O Pacote @code{distrib} inclui funções para simulação de
variáveis estatísticas pseudo-aleatórias. Algumas dessas funções
fazem uso de variáveis opcionais que indicam o algoritmo a ser usado.
O método inverso genérico (baseado no facto que se
@var{u} for um número aleatório uniforme no intervalo @math{(0,1)},
então @var{F^(-1)(u)} é uma variável estatística pseudo-aleatória
com distribuição @math{F}) está implementada para a maioria dos casos;
isso é um método subóptimo em termos de cronometragem, mas útil para
fazer comparações com outros algoritmos. Nesse exemplo, a
@code{perandom_formance} dos algoritmos @code{ahrens_cheng} e
@code{inverse} em simular  variáveis chi-quadradas (letra grega "chi") 
são comparadas por meio de seus histogramas:

@example
(%i1) load(distrib)$
(%i2) load(descriptive)$
(%i3) showtime: true$
Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
(%i4) random_chi2_algorithm: 'ahrens_cheng$ histogram(random_chi2(10,500))$
Evaluation took 0.00 seconds (0.00 elapsed) using 40 bytes.
Evaluation took 0.69 seconds (0.71 elapsed) using 5.694 MB.
(%i6) random_chi2_algorithm: 'inverse$ histogram(random_chi2(10,500))$
Evaluation took 0.00 seconds (0.00 elapsed) using 32 bytes.
Evaluation took 10.15 seconds (10.17 elapsed) using 322.098 MB.
@end example

Com o objectivo de fazer comparações visuais entre algoritmos para uma
variável estatística discreta, a função @code{barsplot} do pacote
@code{descriptive} pode ser usada.

Note que algum trabalho resta para ser realizado, uma vez que essas funções
de simulação não foram ainda verificadas pelos mais rigorosamente
melhores dos testes de ajuste.

Por favor, consulte um manual introdutório sobre probabilidade e estatística
para maiores informações sobre todo esse material matemático.

Existe uma convenção de nome no pacote @code{distrib}. Todo nome de
função tem duas partes, a primeira faz referência à função
ou ao parâmetro que queremos calcular,
@example
Funções:
   função densidade de probabilidade            (pdf_*)
   função distribuição de probabilidade       (cdf_*)
   Quartil                    (quantile_*)
   Média                        (mean_*)
   Variância                    (var_*)
   Desvio padrão          (std_*)
   Coeficiente de assimetria        (skewness_*)
   Coeficiente de curtose        (kurtosis_*)
   Variável estatística pseudo-aleatória              (random_*)
@end example

A segunda parte é uma referência explícita ao modelo probabilístico,
@example
Distribuíções contínuas:
   Normal              (*normal)
   Student             (*student_t)
   Chi^2               (*chi2)
   F                   (*f)
   Exponencial         (*exp)
   Lognormal           (*lognormal)
   Gama               (*gamma)
   Beta                (*beta)
   contínua uniforme  (*continuous_uniform)
   Logística            (*logistic)
   Pareto              (*pareto)
   Weibull             (*weibull)
   Rayleigh            (*rayleigh)
   Laplace             (*laplace)
   Cauchy              (*cauchy)
   Gumbel              (*gumbel)

Distribuições discretas:
   Binomial             (*binomial)
   Poisson              (*poisson)
   Bernoulli            (*bernoulli)
   Geométrica            (*geometric)
   discreta uniforme     (*discrete_uniform)
   hipergeométrica       (*hypergeometric)
   Binomial Negativa    (*negative_binomial)
@end example

Por exemplo, @code{pdf_student_t(x,n)} é a função densidade de
probabilidade da distribuição de Student com @var{n} graus de liberdade,
@code{std_pareto(a,b)} é o desvio padrão da distribuição de
Pareto com parâmetros @var{a} e @var{b} e @code{kurtosis_poisson(m)}
é o coeficiente de curtose da distribuição de Poisson com média @var{m}.


Para poder usar o pacote @code{distrib} precisa primeiro carregá-lo
escrevendo
@example
(%i1) load(distrib)$
@end example

Para comentários, melhorias ou sugestões, por favor contacte o autor em
@var{'mario AT edu DOT xunta DOT es'}.

@node Definições para distribuições contínuas, Definições para distribuições discretas, Introdução a distrib, distrib
@section Definições para distribuições contínuas

@deffn {Função} pdf_normal (@var{x},@var{m},@var{s})
Retorna o valor em @var{x} da função densidade de probabilidade
de uma  variável aleatória @math{Normal(m,s)}, com @math{s>0}. Para fazer
uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_normal (@var{x},@var{m},@var{s})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma  variável aleatória @math{Normal(m,s)}, com @math{s>0}. Essa
função é definida em termos de funções de erro internas do
Maxima,
@code{erf}.

@c ===beg===
@c load (distrib)$
@c assume(s>0)$ cdf_normal(x,m,s);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(s>0)$ cdf_normal(x,m,s);
                             x - m
                       erf(---------)
                           sqrt(2) s    1
(%o3)                  -------------- + -
                             2          2
@end example

Veja também @code{erf}.
@end deffn


@deffn {Função} quantile_normal (@var{q},@var{m},@var{s})
Retorna o @var{q}-quantil de uma variável aleatória @math{Normal(m,s)}, com
@math{s>0}; em outras palavras, isso é o inverso de @code{cdf_normal}. O argumento
@var{q} deve ser um elemento de @math{[0,1]}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_normal (@var{m},@var{s})
Retorna a média de uma  variável aleatória @math{Normal(m,s)}, com
@math{s>0}, a saber @var{m}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_normal (@var{m},@var{s})
Retorna a variância de uma  variável aleatória @math{Normal(m,s)}, com
@math{s>0}, a saber @var{s^2}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} std_normal (@var{m},@var{s})
Retorna o desvio padrão de uma  variável aleatória @math{Normal(m,s)},
com @math{s>0}, a saber @var{s}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_normal (@var{m},@var{s})
Retorna o coeficiente de assimetria de uma  variável aleatória @math{Normal(m,s)},
com @math{s>0}, que é sempre igual  a 0. Para fazer uso dessa função,escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_normal (@var{m},@var{s})
Retorna o coeficiente de curtose de uma  variável aleatória @math{Normal(m,s)},
com @math{s>0}, que é sempre igual  a 0. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_normal_algorithm
Valor por omissão: @code{box_mueller}

Esse é o algoritmo seleccionado para simular variáveis aleatórias normais.
O algoritmos implementados são @code{box_mueller} e @code{inverse}:
@itemize @bullet
@item
@code{box_mueller}, Baseado no algoritmo descrito em Knuth, D.E. (1981)
@var{Seminumerical Algorithms. The Art of Computer Programming.} Addison-Wesley.

@item
@code{inverse}, baseado no método inverso genérico.
@end itemize

Veja também @code{random_normal}.
@end defvr


@deffn {Função} random_normal (@var{m},@var{s})
@deffnx {Função} random_normal (@var{m},@var{s},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Normal(m,s)},
com @math{s>0}. Chamando @code{random_normal} com um terceiro argumento
@var{n}, uma amostra aleatória de tamanho @var{n} será simulada.

Existem dois algoritmos implementados para essa função, e o algoritmo
a ser usado pode ser seleccionado fornecendo um certo valor para a variável global
@code{random_normal_algorithm}, cujo valor padrão é
@code{box_mueller}.

Veja também @code{random_normal_algorithm}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_student_t (@var{x},@var{n})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória de Student @math{t(n)}, com @math{n>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_student_t (@var{x},@var{n})
Retorna o valor em @var{x} da função distribuição de probabilidade de
uma variável aleatória de Student @math{t(n)}, com @math{n>0}. Essa função
não tem uma forma definitiva e é calculada numericamente
se a
variável global
@code{numer} for igual a @code{true},  de outra froma @code{cdf_student_t} retorna uma
expressão nominal.

@c ===beg===
@c load (distrib)$
@c cdf_student_t(1/2, 7/3);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_student_t(1/2, 7/3);
                                     1  7
(%o2)                  cdf_student_t(-, -)
                                     2  3
(%i3) %,numer;
(%o3)                   .6698450596140417
@end example
@end deffn


@deffn {Função} quantile_student_t (@var{q},@var{n})
Retorna o @var{q}-quantil de uma variável aleatória de Student @math{t(n)},
com @math{n>0}; em outras palavras, @code{quantile_student_t} é o inverso de
@code{cdf_student_t}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_student_t (@var{n})
Retorna a média de uma variável aleatória de Student @math{t(n)}, com
@math{n>0}, que é sempre igual a 0. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_student_t (@var{n})
Retorna a variância de uma variável aleatória de Student @math{t(n)}, com @math{n>2}.

@c ===beg===
@c load (distrib)$
@c assume(n>2)$  var_student_t(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(n>2)$  var_student_t(n);
                                n
(%o3)                         -----
                              n - 2
@end example
@end deffn


@deffn {Função} std_student_t (@var{n})
Retorna o desvio padrão de uma variável aleatória de Student @math{t(n)},
com @math{n>2}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} skewness_student_t (@var{n})
Retorna o coeficiente de assimetria de uma variável aleatória de Student @math{t(n)},
com @math{n>3}, que é sempre igual a 0. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_student_t (@var{n})
Retorna o coeficiente de curtose de uma variável aleatória de Student @math{t(n)},
com @math{n>4}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_student_t_algorithm
Valor por omissão: @code{ratio}

Esse é o  algoritmo seleccionado para simular variáveis estatísticas pseudo-aleatórias
de Student. Algorítmos implementados são @code{inverse} e @code{ratio}:
@itemize @bullet
@item
@code{inverse}, baseado no método inverso genérico.


@item
@code{ratio}, baseado no facto que se @var{Z} for uma variável aleatória normal @math{N(0,1)} e
@math{S^2} for uma variável aleatória chi quadrada com @var{n} graus de liberdade,
@math{Chi^2(n)}, então
@ifhtml
@example
                           Z
                 X = -------------
                     /   2  \ 1/2
                     |  S   |
                     | ---  |
                     \  n   /
@end example
@end ifhtml
@ifinfo
@example
                           Z
                 X = -------------
                     /   2  \ 1/2
                     |  S   |
                     | ---  |
                     \  n   /
@end example
@end ifinfo
@tex
$$X={{Z}\over{\sqrt{{S^2}\over{n}}}}$$
@end tex
é uma variável aleatória de Student com @var{n} graus de liberdade, @math{t(n)}.
@end itemize

Veja também @code{random_student_t}.
@end defvr


@deffn {Função} random_student_t (@var{n})
@deffnx {Função} random_student_t (@var{n},@var{m})
Retorna uma variável estatística pseudo-aleatória de Student @math{t(n)},
com @math{n>0}. Chamando @code{random_student_t} com um segundo argumento
@var{m}, uma amostra aleatória de tamanho @var{m} será simulada.

Existem dois algoritmos implementados para essa função, se pode
seleccionar o algoritmo a ser usado fornecendo um certo valor à variável
global @code{random_student_t_algorithm}, cujo valor padrão é @code{ratio}.

Veja também @code{random_student_t_algorithm}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_chi2 (@var{x},@var{n})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória Chi-quadrada @math{Chi^2(n)}, com @math{n>0}.

A  variável aleatória @math{Chi^2(n)} é equivalente a @math{Gamma(n/2,2)},
portanto quando Maxima não tiver informação para pegar o resultado, uma
forma nomial baseada na função de densidade densidade de probabilidade da
função  gama é
retornada.

@c ===beg===
@c load (distrib)$
@c pdf_chi2(x,n);
@c assume(x>0, n>0)$  pdf_chi2(x,n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_chi2(x,n);
                                    n
(%o2)                  pdf_gamma(x, -, 2)
                                    2
(%i3) assume(x>0, n>0)$  pdf_chi2(x,n);
                         n/2 - 1   - x/2
                        x        %e
(%o4)                   ----------------
                          n/2       n
                         2    gamma(-)
                                    2
@end example
@end deffn


@deffn {Função} cdf_chi2 (@var{x},@var{n})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória Chi-quadrada @math{Chi^2(n)}, com @math{n>0}.

Essa função não possui uma forma fechada e é calculada numericamante
se a variável global @code{numer} for igual a @code{true},  de outra forma essa
função retorna uma expressão nominal baseada na 
distribuição gama, uma vez
que a variável aleatória @math{Chi^2(n)}
é equivalente a    é equivalente a @math{Gamma(n/2,2)}.

@c ===beg===
@c load (distrib)$
@c cdf_chi2(3,4);
@c cdf_chi2(3,4),numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_chi2(3,4);
(%o2)                  cdf_gamma(3, 2, 2)
(%i3) cdf_chi2(3,4),numer;
(%o3)                   .4421745996289249
@end example
@end deffn


@deffn {Função} quantile_chi2 (@var{q},@var{n})
Retorna o @var{q}-quantilede uma variável aleatória Chi-quadrada @math{Chi^2(n)},
com @math{n>0}; em outras palavras, essa função é a inversa da função
@code{cdf_chi2}. O argumento @var{q} deve ser um elemento
de
@math{[0,1]}.

This função não possui uma forma fechada e é calculada numericamante se
a variável global @code{numer} for igual a @code{true},  de outra forma essa
função retorna uma expressão nominal baseada no quantil da função
gama, uma vez que a variável aleatória @math{Chi^2(n)} é equivalente a @math{Gamma(n/2,2)}.

@c ===beg===
@c load (distrib)$
@c quantile_chi2(0.99,9);
@c quantile_chi2(0.99,n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_chi2(0.99,9);
(%o2)                   21.66599433346194
(%i3) quantile_chi2(0.99,n);
                                        n
(%o3)              quantile_gamma(0.99, -, 2)
                                        2
@end example
@end deffn


@deffn {Função} mean_chi2 (@var{n})
Retorna a média de uma variável aleatória Chi-quadrada @math{Chi^2(n)}, com @math{n>0}.

A variável aleatória @math{Chi^2(n)} é equivalente a @math{Gamma(n/2,2)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na média da função gama é
retornada.

@c ===beg===
@c load (distrib)$
@c mean_chi2(n);
@c assume(n>0)$ mean_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_chi2(n);
                                   n
(%o2)                   mean_gamma(-, 2)
                                   2
(%i3) assume(n>0)$ mean_chi2(n);
(%o4)                           n
@end example
@end deffn


@deffn {Função} var_chi2 (@var{n})
Retorna a variância de uma variável aleatória Chi-quadrada @math{Chi^2(n)}, com @math{n>0}.

A variável aleatória @math{Chi^2(n)} é equivalente a @math{Gamma(n/2,2)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na variância da função gama
é retornada.

@c ===beg===
@c load (distrib)$
@c var_chi2(n);
@c assume(n>0)$ var_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_chi2(n);
                                   n
(%o2)                    var_gamma(-, 2)
                                   2
(%i3) assume(n>0)$ var_chi2(n);
(%o4)                          2 n
@end example
@end deffn


@deffn {Função} std_chi2 (@var{n})
Retorna o desvio padrão de uma variável aleatória Chi-quadrada
@math{Chi^2(n)}, com @math{n>0}.

A variável aleatória @math{Chi^2(n)} é equivalente a @math{Gamma(n/2,2)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no desvio padrão da função
gama é retornada.

@c ===beg===
@c load (distrib)$
@c std_chi2(n);
@c assume(n>0)$ std_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_chi2(n);
                                   n
(%o2)                    std_gamma(-, 2)
                                   2
(%i3) assume(n>0)$ std_chi2(n);
(%o4)                    sqrt(2) sqrt(n)
@end example
@end deffn


@deffn {Função} skewness_chi2 (@var{n})
Retorna o coeficiente de assimetria de uma variável aleatória Chi-quadrada
@math{Chi^2(n)}, com @math{n>0}.

A variável aleatória @math{Chi^2(n)} é equivalente a @math{Gamma(n/2,2)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no coeficiente de assimetria da
função gama é
retornada.

@c ===beg===
@c load (distrib)$
@c skewness_chi2(n);
@c assume(n>0)$ skewness_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_chi2(n);
                                     n
(%o2)                 skewness_gamma(-, 2)
                                     2
(%i3) assume(n>0)$ skewness_chi2(n);
                            2 sqrt(2)
(%o4)                       ---------
                             sqrt(n)
@end example
@end deffn


@deffn {Função} kurtosis_chi2 (@var{n})
Retorna o coeficiente de curtose de uma variável aleatória Chi-quadrada
@math{Chi^2(n)}, com @math{n>0}.

A variável aleatória @math{Chi^2(n)} é equivalente a @math{Gamma(n/2,2)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no coeficiente de curtose da função gama é retornada.

@c ===beg===
@c load (distrib)$
@c kurtosis_chi2(n);
@c assume(n>0)$ kurtosis_chi2(n);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_chi2(n);
                                     n
(%o2)                 kurtosis_gamma(-, 2)
                                     2
(%i3) assume(n>0)$ kurtosis_chi2(n);
                               12
(%o4)                          --
                               n
@end example
@end deffn


@defvr {Variável de opção} random_chi2_algorithm
Valor por omissão: @code{ahrens_cheng}

Esse é o algoritmo seleccionado para simular variáveis estatística pseudo-aleatórias
Chi-quadradas. Os algoritmos implementados são @code{ahrens_cheng} e @code{inverse}:
@itemize @bullet

@item
@code{ahrens_cheng}, baseado na simulação aleatória de variáveis gama.
Veja @code{random_gamma_algorithm} para mais detalhes.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_chi2}.
@end defvr


@deffn {Função} random_chi2 (@var{n})
@deffnx {Função} random_chi2 (@var{n},@var{m})
Retorna uma variável estatística pseudo-aleatória Chi-square @math{Chi^2(n)},
com @math{n>0}. Chamando @code{random_chi2} com um segundo argumento @var{m},
uma amostra aleatória de tamanho @var{m} será simulada.

Existem dois algoritmos implementados para essa função, se pode seleccionar o
algoritmo a ser usado fornecendo um certo valor à variável global
@code{random_chi2_algorithm}, cujo valor padrão é
@code{ahrens_cheng}.

Veja também @code{random_chi2_algorithm}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_f (@var{x},@var{m},@var{n})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória F, @math{F(m,n)}, com @math{m,n>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_f (@var{x},@var{m},@var{n})
Retorna o valor em @var{x} da função distribuição de probabilidade de
uma variável aleatória F, @math{F(m,n)}, com @math{m,n>0}. Essa função
não possui uma forma definitiva e é calculada numericamente se
a
variável global
@code{numer} for igual a @code{true},  de outra forma retorna uma expressão nominal.

@c ===beg===
@c load (distrib)$
@c cdf_f(2,3,9/4);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_f(2,3,9/4);
                                     9
(%o2)                    cdf_f(2, 3, -)
                                     4
(%i3) %,numer;
(%o3)                   0.66756728179008
@end example
@end deffn


@deffn {Função} quantile_f (@var{q},@var{m},@var{n})
Retorna o @var{q}-quantil de uma variável aleatória F, @math{F(m,n)}, com @math{m,n>0};
em outras palavras, essa função é o inverso de @code{cdf_f}. O argumento @var{q} deve ser um elemento de @math{[0,1]}.

Essa função não possui uma forma fechada e é calculada numericamante se a
variável global @code{numer} for igual a @code{true},  de outra forma essa função
retorna uma expressão nominal.

@c ===beg===
@c load (distrib)$
@c quantile_f(2/5,sqrt(3),5);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_f(2/5,sqrt(3),5);
                               2
(%o2)               quantile_f(-, sqrt(3), 5)
                               5
(%i3) %,numer;
(%o3)                   0.518947838573693
@end example
@end deffn


@deffn {Função} mean_f (@var{m},@var{n})
Retorna a média de uma variável aleatória F, @math{F(m,n)}, com @math{m>0, n>2}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_f (@var{m},@var{n})
Retorna a variância de uma variável aleatória F, @math{F(m,n)}, com @math{m>0, n>4}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_f (@var{m},@var{n})
Retorna o desvio padrão de uma variável aleatória F, @math{F(m,n)}, com @math{m>0, n>4}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_f (@var{m},@var{n})
Retorna o coeficiente de assimetria de uma variável aleatória F, @math{F(m,n)},
com @math{m>0, n>6}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_f (@var{m},@var{n})
Retorna o coeficiente de curtose de uma variável aleatória F, @math{F(m,n)},
com @math{m>0, n>8}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_f_algorithm
Valor por omissão: @code{inverse}

Esse é o algoritmo seleccionado para simular variáveis estatísticas
pseudo-aleatórias F. Os algoritmos implementados são @code{ratio}
e @code{inverse}:
@itemize @bullet

@item
@code{ratio}, baseado no facto de que se @var{X} for uma variável aleatória
@math{Chi^2(m)} e @math{Y} for uma variável aleatória @math{Chi^2(n)},
então
@ifhtml
@example
                        n X
                    F = ---
                        m Y
@end example
@end ifhtml
@ifinfo
@example
                        n X
                    F = ---
                        m Y
@end example
@end ifinfo
@tex
$$F={{n X}\over{m Y}}$$
@end tex
é uma variável aleatória F com @var{m} e @var{n} graus de liberdade, @math{F(m,n)}.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_f}.
@end defvr


@deffn {Função} random_f (@var{m},@var{n})
@deffnx {Função} random_f (@var{m},@var{n},@var{k})
Retorna uma variável estatística pseudo-aleatória F, @math{F(m,n)},
com @math{m,n>0}. Chamando @code{random_f} com um terceiro argumento
@var{k}, uma amostra aleatória de tamanho @var{k} será simulada.

Existem dois algoritmos implementados para essa função, se pode seleccionar
o algoritmo a ser usado fornecendo um certo valor à variável global
@code{random_f_algorithm}, cujo valor padrão é @code{inverse}.

Veja também @code{random_f_algorithm}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} pdf_exp (@var{x},@var{m})
Retorna o valor em @var{x} da função densidade de probabilidade
variável aleatória @math{Exponential(m)}, com @math{m>0}.

A variável aleatória @math{Exponential(m)} é equivalente a
@math{Weibull(1,1/m)}, embora quando Maxima não tiver informação
disponível para pegar o resultado, uma forma nominal baseada na função
de densidade de probabilidade de Weibull éretornada.

@c ===beg===
@c load (distrib)$
@c pdf_exp(x,m);
@c assume(x>0,m>0)$  pdf_exp(x,m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_exp(x,m);
                                        1
(%o2)                 pdf_weibull(x, 1, -)
                                        m
(%i3) assume(x>0,m>0)$  pdf_exp(x,m);
                                - m x
(%o4)                       m %e
@end example
@end deffn


@deffn {Função} cdf_exp (@var{x},@var{m})
Retorna o valor em @var{x} da função distribuição de probabilidade
variável aleatória @math{Exponential(m)}, com @math{m>0}.

A variável aleatória @math{Exponential(m)} é equivalente a @math{Weibull(1,1/m)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na distribuição de
Weibull é
retornada.

@c ===beg===
@c load (distrib)$
@c cdf_exp(x,m);
@c assume(x>0,m>0)$  cdf_exp(x,m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_exp(x,m);
                                        1
(%o2)                 cdf_weibull(x, 1, -)
                                        m
(%i3) assume(x>0,m>0)$  cdf_exp(x,m);
                                 - m x
(%o4)                      1 - %e
@end example
@end deffn


@deffn {Função} quantile_exp (@var{q},@var{m})
Retorna o @var{q}-quantil variável aleatória @math{Exponential(m)}, com @math{m>0};
em outras palavras, essa função é inversa da função @code{cdf_exp}.
O argumento @var{q} deve ser um elemento de @math{[0,1]}.

A variável aleatória @math{Exponential(m)} é equivalente a @math{Weibull(1,1/m)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no qualtil de Weibull é
retornada.

@c ===beg===
@c load (distrib)$
@c quantile_exp(0.56,5);
@c quantile_exp(0.56,m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_exp(0.56,5);
(%o2)                   .1641961104139661
(%i3) quantile_exp(0.56,m);
                                            1
(%o3)             quantile_weibull(0.56, 1, -)
                                            m
@end example
@end deffn


@deffn {Função} mean_exp (@var{m})
Retorna a média de uma variável aleatória @math{Exponential(m)}, com @math{m>0}.

A variável aleatória @math{Exponential(m)} é equivalente a @math{Weibull(1,1/m)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na média de Weibull é
reornada.

@c ===beg===
@c load (distrib)$
@c mean_exp(m);
@c assume(m>0)$  mean_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_exp(m);
                                       1
(%o2)                  mean_weibull(1, -)
                                       m
(%i3) assume(m>0)$  mean_exp(m);
                                1
(%o4)                           -
                                m
@end example
@end deffn


@deffn {Função} var_exp (@var{m})
Retorna a variância de uma variável aleatória @math{Exponential(m)}, com @math{m>0}.

A variável aleatória @math{Exponential(m)} é equivalente a @math{Weibull(1,1/m)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na variância de Weibull
é retornada.

@c ===beg===
@c load (distrib)$
@c var_exp(m);
@c assume(m>0)$  var_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_exp(m);
                                       1
(%o2)                   var_weibull(1, -)
                                       m
(%i3) assume(m>0)$  var_exp(m);
                               1
(%o4)                          --
                                2
                               m
@end example
@end deffn


@deffn {Função} std_exp (@var{m})
Retorna o desvio padrão de uma variável aleatória @math{Exponential(m)}, com @math{m>0}.

A variável aleatória @math{Exponential(m)} é equivalente a @math{Weibull(1,1/m)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no desvio padrão de
Weibull é retornada.

@c ===beg===
@c load (distrib)$
@c std_exp(m);
@c assume(m>0)$  std_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_exp(m);
                                       1
(%o2)                   std_weibull(1, -)
                                       m
(%i3) assume(m>0)$  std_exp(m);
                                1
(%o4)                           -
                                m
@end example
@end deffn


@deffn {Função} skewness_exp (@var{m})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Exponential(m)}, com @math{m>0}.

A variável aleatória @math{Exponential(m)} é equivalente a @math{Weibull(1,1/m)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no coeficiente de assimetria
de Weibull
é retornada.

@c ===beg===
@c load (distrib)$
@c skewness_exp(m);
@c assume(m>0)$  skewness_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_exp(m);
                                         1
(%o2)                skewness_weibull(1, -)
                                         m
(%i3) assume(m>0)$  skewness_exp(m);
(%o4)                           2
@end example
@end deffn


@deffn {Função} kurtosis_exp (@var{m})
Retorna o coeficiente de curtose de uma variável aleatória @math{Exponential(m)}, com @math{m>0}.

A variável aleatória @math{Exponential(m)} é equivalente a @math{Weibull(1,1/m)}, embora
quando Maxima não tiver informação disponível para pegar o resultado, uma forma nominal
baseada no coeficiente de curtose de Weibull é retornada.

@c ===beg===
@c load (distrib)$
@c kurtosis_exp(m);
@c assume(m>0)$  kurtosis_exp(m);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_exp(m);
                                         1
(%o2)                kurtosis_weibull(1, -)
                                         m
(%i3) assume(m>0)$  kurtosis_exp(m);
(%o4)                           6
@end example
@end deffn


@defvr {Variável de opção} random_exp_algorithm
Valor por omissão: @code{inverse}

Esse é o algoritmo seleccionado para simular variáveis exponenciais estatística
pseudo-aleatórias. Os algoritmos implementados são @code{inverse},
@code{ahrens_cheng} e @code{ahrens_dieter}
@itemize @bullet

@item
@code{inverse}, baseado no método inverso genérico.

@item
@code{ahrens_cheng}, baseado no facto de que a variável aleatória @math{Exp(m)}
é equivalente a @math{Gamma(1,1/m)}. Veja @code{random_gamma_algorithm}
para maiores detalhes.

@item
@code{ahrens_dieter}, baseado no algoritmo descrito em Ahrens, J.H. e Dieter, U. (1972)
@var{Computer methods for sampling from the exponential and normal distributions.}
Comm, ACM, 15, Oct.,  873-882.

@end itemize

Veja também @code{random_exp}.
@end defvr


@deffn {Função} random_exp (@var{m})
@deffnx {Função} random_exp (@var{m},@var{k})
Retorna uma variável estatística pseudo-aleatória @math{Exponential(m)},
com @math{m>0}. Chamando @code{random_exp} com um segundo argumento
@var{k}, uma amostra aleatória de tamanho @var{k} será simulada.

Existem três algoritmos implementados para essa função, se pode
seleccionar o algoritmo a ser usado fornecendo um certo valor à variável global
@code{random_exp_algorithm}, cujo valor padrão é @code{inverse}.

Veja também @code{random_exp_algorithm}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_lognormal (@var{x},@var{m},@var{s})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória @math{Lognormal(m,s)}, com @math{s>0}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_lognormal (@var{x},@var{m},@var{s})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Lognormal(m,s)}, com @math{s>0}. Essa
função é definida em termos de funções @code{erf}de erro
internas do Maxima.

@c ===beg===
@c load (distrib)$
@c assume(x>0, s>0)$  cdf_lognormal(x,m,s);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(x>0, s>0)$  cdf_lognormal(x,m,s);
                           log(x) - m
                       erf(----------)
                           sqrt(2) s     1
(%o3)                  --------------- + -
                              2          2
@end example

Veja também @code{erf}.
@end deffn


@deffn {Função} quantile_lognormal (@var{q},@var{m},@var{s})
Retorna o @var{q}-quantil de uma variável aleatória @math{Lognormal(m,s)},
com @math{s>0}; em outras palavras, essa função é a inversa da função
@code{cdf_lognormal}. O argumento @var{q} deve ser um elemento de @math{[0,1]}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_lognormal (@var{m},@var{s})
Retorna a média de uma variável aleatória @math{Lognormal(m,s)}, com @math{s>0}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_lognormal (@var{m},@var{s})
Retorna a variância de uma variável aleatória @math{Lognormal(m,s)},
com @math{s>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn

@deffn {Função} std_lognormal (@var{m},@var{s})
Retorna o desvio padrão de uma variável aleatória @math{Lognormal(m,s)},
com @math{s>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} skewness_lognormal (@var{m},@var{s})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Lognormal(m,s)},
com @math{s>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_lognormal (@var{m},@var{s})
Retorna o coeficiente de curtose de uma variável aleatória @math{Lognormal(m,s)},
com @math{s>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} random_lognormal (@var{m},@var{s})
@deffnx {Função} random_lognormal (@var{m},@var{s},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Lognormal(m,s)},
com @math{s>0}. Chamando @code{random_lognormal} com um terceiro argumento
@var{n}, uma amostra aleatória de tamanho @var{n} será simulada.

Variáveis Log-normal são simuladas por meio de variáveis estatísticas normais
pseudo-aleatórias. Existem dois algoritmos implementados para essa função, se
pode seleccionar o algoritmo a ser usado fornecendo um certo valor
à variável global
@code{random_normal_algorithm}, cujo valor padrão é @code{box_mueller}.

Veja também @code{random_normal_algorithm}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_gamma (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória @math{Gamma(a,b)}, com @math{a,b>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_gamma (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade de
uma variável aleatória @math{Gamma(a,b)}, com @math{a,b>0}. 

Essa função não possui uma forma fechada e é calculada numericamante se
a variável global @code{numer} for igual a @code{true},  de outra forma essa função
retorna uma expressão nominal.

@c ===beg===
@c load (distrib)$
@c cdf_gamma(3,5,21);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_gamma(3,5,21);
(%o2)                  cdf_gamma(3, 5, 21)
(%i3) %,numer;
(%o3)                 4.402663157135039E-7
@end example
@end deffn


@deffn {Função} quantile_gamma (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Gamma(a,b)},
com @math{a,b>0}; em outras palavras, essa função é a inversa da
função @code{cdf_gamma}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_gamma (@var{a},@var{b})
Retorna a média de uma variável aleatória @math{Gamma(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} var_gamma (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Gamma(a,b)}, com
@math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} std_gamma (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Gamma(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} skewness_gamma (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Gamma(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_gamma (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Gamma(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_gamma_algorithm
Valor por omissão: @code{ahrens_cheng}

Esse é o algoritmo seleccionado para simular variáveis estatística gama
pseudo-aleatórias. Os algoritmos implementados são @code{ahrens_cheng}
e @code{inverse}
@itemize @bullet

@item
@code{ahrens_cheng}, essa é uma combinação de dois processos, dependendo
do valor do parâmetro @var{a}:

For @math{a>=1}, Cheng, R.C.H. e Feast, G.M. (1979). @var{Some simple gamma variate
generators}. Appl. Stat., 28, 3, 290-295.

For @math{0<a<1}, Ahrens, J.H. e Dieter, U. (1974). @var{Computer methods for sampling
from gamma, beta, poisson and binomial cdf_tributions}. Computing, 12, 223-246.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_gamma}.
@end defvr


@deffn {Função} random_gamma (@var{a},@var{b})
@deffnx {Função} random_gamma (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Gamma(a,b)},
com @math{a,b>0}. Chamando @code{random_gamma} com um terceiro argumento
@var{n}, uma amostra aleatória de tamanho @var{n} será simulada.

Existem dois algoritmos implementados para essa função, se pode seleccionar
o algoritmo a ser usado fornecendo um certo valor à variável global @code{random_gamma_algorithm}, cujo valor padrão é
@code{ahrens_cheng}.

Veja também @code{random_gamma_algorithm}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_beta (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma variável
aleatória @math{Beta(a,b)}, com @math{a,b>0}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn



@deffn {Função} cdf_beta (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade de
uma variável aleatória @math{Beta(a,b)}, com @math{a,b>0}. 

Essa função não possui uma forma fechada e é calculada numericamante se a
variável global @code{numer} for igual a @code{true},  de outra forma essa função
retorna uma expressão nominal.

@c ===beg===
@c load (distrib)$
@c cdf_beta(1/3,15,2);
@c %,numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_beta(1/3,15,2);
                                 1
(%o2)                   cdf_beta(-, 15, 2)
                                 3
(%i3) %,numer;
(%o3)                 7.666089131388224E-7
@end example
@end deffn


@deffn {Função} quantile_beta (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Beta(a,b)}, com
@math{a,b>0}; em outras palavras, essa função é a inversa da função
@code{cdf_beta}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para
fazer uso dessa
função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_beta (@var{a},@var{b})
Retorna a média de uma variável aleatória @math{Beta(a,b)}, com @math{a,b>0}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_beta (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Beta(a,b)}, com @math{a,b>0}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} std_beta (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Beta(a,b)}, com @math{a,b>0}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_beta (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Beta(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_beta (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Beta(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_beta_algorithm
Valor por omissão: @code{cheng}

Esse é o algoritmo seleccionado para simular variáveis estatísticas beta
pseudo-aleatórias. Os algoritmos implementados são @code{cheng},
@code{inverse} e @code{ratio}
@itemize @bullet

@item
@code{cheng}, esse é o algoritmo definido em Cheng, R.C.H.  (1978). 
@var{Generating Beta Variates with Nonintegral Shape Parameters}.
Communications of the ACM, 21:317-322

@item
@code{inverse}, baseado no método inverso genérico.

@item
@code{ratio}, baseado no facto de que se @var{X} for uma variável aleatória
@math{Gamma(a,1)} e @var{Y} for @math{Gamma(b,1)}, então a razão @math{X/(X+Y)}
está distribuída como @math{Beta(a,b)}.

@end itemize

Veja também @code{random_beta}.
@end defvr


@deffn {Função} random_beta (@var{a},@var{b})
@deffnx {Função} random_beta (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Beta(a,b)},
com @math{a,b>0}. Chamando @code{random_beta} com um terceiro argumento @var{n},
uma amostra aleatória de tamanho @var{n} será simulada.

Existem três algoritmos implementados para essa função, se pode seleccionar
o algoritmo a ser usado fornecendo um certo valor à variável global
@code{random_beta_algorithm}, cujo valor padrão é @code{cheng}.

Veja também @code{random_beta_algorithm}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} pdf_continuous_uniform (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade
de uma variável aleatória @math{Continuous Uniform(a,b)}, com @math{a<b}.
Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} cdf_continuous_uniform (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Continuous Uniform(a,b)}, com @math{a<b}.
Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} quantile_continuous_uniform (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Continuous Uniform(a,b)},
com @math{a<b}; em outras palavras, essa função é a inversa da função
@code{cdf_continuous_uniform}. O argumento @var{q} deve
ser um elemento
de @math{[0,1]}.
Para
fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_continuous_uniform (@var{a},@var{b})
Retorna a média de uma variável aleatória @math{Continuous Uniform(a,b)},
com @math{a<b}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_continuous_uniform (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Continuous Uniform(a,b)},
com @math{a<b}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} std_continuous_uniform (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Continuous Uniform(a,b)},
com @math{a<b}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_continuous_uniform (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Continuous Uniform(a,b)},
com @math{a<b}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_continuous_uniform (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Continuous Uniform(a,b)},
com @math{a<b}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} random_continuous_uniform (@var{a},@var{b})
@deffnx {Função} random_continuous_uniform (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Continuous Uniform(a,b)},
com @math{a<b}. Chamando @code{random_continuous_uniform} com um terceiro
argumento @var{n}, uma amostra aleatória de tamanho @var{n} será simulada.

Essa é uma aplicação directa da função @code{random} interna do Maxima.

Veja também @code{random}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_logistic (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de
uma variável aleatória @math{Logistic(a,b)} , com @math{b>0}. Para fazer
uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_logistic (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Logistic(a,b)}, com @math{b>0}. Para fazer
uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} quantile_logistic (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Logistic(a,b)} , com
@math{b>0}; em outras palavras, essa função é a inversa da função
@code{cdf_logistic}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}.
Para fazer uso
dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} meanlog (@var{a},@var{b})
Retorna a média de uma @math{Logistic(a,b)} variável aleatória , com @math{b>0}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_logistic (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Logistic(a,b)} , com @math{b>0}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_logistic (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Logistic(a,b)} ,
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} skewness_logistic (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Logistic(a,b)} ,
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_logistic (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Logistic(a,b)} ,
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} random_logistic (@var{a},@var{b})
@deffnx {Função} random_logistic (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Logistic(a,b)}, com @math{b>0}.
Chamando @code{random_logistic} com um terceiro argumento @var{n}, uma
amostra aleatória de tamanho @var{n} será simulada.

Somente o método inverso genérico está implementado. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_pareto (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória @math{Pareto(a,b)}, com @math{a,b>0}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_pareto (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Pareto(a,b)}, com @math{a,b>0}. Para fazer
uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} quantile_pareto (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantile de uma variável aleatória @math{Pareto(a,b)},
com @math{a,b>0}; em outras palavras, essa função é a inversa da
função @code{cdf_pareto}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para
fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_pareto (@var{a},@var{b})
Retorna a média de uma variável aleatória @math{Pareto(a,b)}, com
@math{a>1,b>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} var_pareto (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Pareto(a,b)},
com @math{a>2,b>0}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} std_pareto (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Pareto(a,b)},
com @math{a>2,b>0}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn



@deffn {Função} skewness_pareto (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória
@math{Pareto(a,b)}, com @math{a>3,b>0}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_pareto (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Pareto(a,b)},
com @math{a>4,b>0}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} random_pareto (@var{a},@var{b})
@deffnx {Função} random_pareto (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Pareto(a,b)}, com
@math{a>0,b>0}. Chamando @code{random_pareto} com um terceiro
argumento @var{n}, uma amostra aleatória de tamanho @var{n} será simulada.

Somente o método inverso genérico está implementado. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_weibull (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória @math{Weibull(a,b)}, com @math{a,b>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_weibull (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade de uma
variável aleatória @math{Weibull(a,b)}, com @math{a,b>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} quantile_weibull (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Weibull(a,b)},
com @math{a,b>0}; em outras palavras, essa função é a inversa da
função @code{cdf_weibull}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_weibull (@var{a},@var{b})
Retorna a média de uma variável aleatória @math{Weibull(a,b)}, com
@math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_weibull (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Weibull(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn

@deffn {Função} std_weibull (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Weibull(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn



@deffn {Função} skewness_weibull (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Weibull(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_weibull (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Weibull(a,b)},
com @math{a,b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} random_weibull (@var{a},@var{b})
@deffnx {Função} random_weibull (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Weibull(a,b)},
com @math{a,b>0}. Chamando @code{random_weibull} com um terceiro argumento
@var{n}, uma amostra aleatória de tamanho @var{n} será simulada.

Somente o método inverso genérico está implementado. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn



@deffn {Função} pdf_rayleigh (@var{x},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória @math{Rayleigh(b)}, com @math{b>0}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na função densidade de probabilidade de Weibull é retornada.

@c ===beg===
@c load (distrib)$
@c pdf_rayleigh(x,b);
@c assume(x>0,b>0)$ pdf_rayleigh(x,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_rayleigh(x,b);
                                        1
(%o2)                 pdf_weibull(x, 2, -)
                                        b
(%i3) assume(x>0,b>0)$ pdf_rayleigh(x,b);
                                    2  2
                           2     - b  x
(%o4)                   2 b  x %e
@end example
@end deffn


@deffn {Função} cdf_rayleigh (@var{x},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Rayleigh(b)}, com @math{b>0}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o
resultado, uma forma nominal baseada na distribuição de Weibull é retornada.

@c ===beg===
@c load (distrib)$
@c cdf_rayleigh(x,b);
@c assume(x>0,b>0)$ cdf_rayleigh(x,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_rayleigh(x,b);
                                        1
(%o2)                 cdf_weibull(x, 2, -)
                                        b
(%i3) assume(x>0,b>0)$ cdf_rayleigh(x,b);
                                   2  2
                                - b  x
(%o4)                     1 - %e
@end example
@end deffn


@deffn {Função} quantile_rayleigh (@var{q},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Rayleigh(b)}, com
@math{b>0}; em outras palavras, essa função é a inversa da função
@code{cdf_rayleigh}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no quantil de Weibull é
retornada.

@c ===beg===
@c load (distrib)$
@c quantile_rayleigh(0.99,b);
@c assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) quantile_rayleigh(0.99,b);
                                            1
(%o2)             quantile_weibull(0.99, 2, -)
                                            b
(%i3) assume(x>0,b>0)$ quantile_rayleigh(0.99,b);
                        2.145966026289347
(%o4)                   -----------------
                                b
@end example
@end deffn


@deffn {Função} mean_rayleigh (@var{b})
Retorna a média de uma variável aleatória @math{Rayleigh(b)}, com @math{b>0}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na meia de Weibull é retornada.

@c ===beg===
@c load (distrib)$
@c mean_rayleigh(b);
@c assume(b>0)$ mean_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_rayleigh(b);
                                       1
(%o2)                  mean_weibull(2, -)
                                       b
(%i3) assume(b>0)$ mean_rayleigh(b);
                            sqrt(%pi)
(%o4)                       ---------
                               2 b
@end example
@end deffn


@deffn {Função} var_rayleigh (@var{b})
Retorna a variância de uma variável aleatória @math{Rayleigh(b)}, com @math{b>0}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na variância de Weibull é retornada.

@c ===beg===
@c load (distrib)$
@c var_rayleigh(b);
@c assume(b>0)$ var_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_rayleigh(b);
                                       1
(%o2)                   var_weibull(2, -)
                                       b
(%i3) assume(b>0)$ var_rayleigh(b);
                                 %pi
                             1 - ---
                                  4
(%o4)                        -------
                                2
                               b
@end example
@end deffn


@deffn {Função} std_rayleigh (@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Rayleigh(b)}, com @math{b>0}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na Weibull desvio padrão é retornada.

@c ===beg===
@c load (distrib)$
@c std_rayleigh(b);
@c assume(b>0)$ std_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_rayleigh(b);
                                       1
(%o2)                   std_weibull(2, -)
                                       b
(%i3) assume(b>0)$ std_rayleigh(b);
                                   %pi
                          sqrt(1 - ---)
                                    4
(%o4)                     -------------
                                b
@end example
@end deffn


@deffn {Função} skewness_rayleigh (@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Rayleigh(b)}, com @math{b>0}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no coeficiente de assimetria de Weibull  é retornada.

@c ===beg===
@c load (distrib)$
@c skewness_rayleigh(b);
@c assume(b>0)$ skewness_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_rayleigh(b);
                                         1
(%o2)                skewness_weibull(2, -)
                                         b
(%i3) assume(b>0)$ skewness_rayleigh(b);
                         3/2
                      %pi      3 sqrt(%pi)
                      ------ - -----------
                        4           4
(%o4)                 --------------------
                               %pi 3/2
                          (1 - ---)
                                4
@end example
@end deffn


@deffn {Função} kurtosis_rayleigh (@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Rayleigh(b)}, com @math{b>0}.

A variável aleatória @math{Rayleigh(b)} é equivalente a @math{Weibull(2,1/b)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no coeficiente de curtose de Weibull é retornada.

@c ===beg===
@c load (distrib)$
@c kurtosis_rayleigh(b);
@c assume(b>0)$ kurtosis_rayleigh(b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_rayleigh(b);
                                         1
(%o2)                kurtosis_weibull(2, -)
                                         b
(%i3) assume(b>0)$ kurtosis_rayleigh(b);
                                  2
                             3 %pi
                         2 - ------
                               16
(%o4)                    ---------- - 3
                              %pi 2
                         (1 - ---)
                               4
@end example
@end deffn


@deffn {Função} random_rayleigh (@var{b})
@deffnx {Função} random_rayleigh (@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Rayleigh(b)}, com @math{b>0}.
Chamando @code{random_rayleigh} com um segundo argumento @var{n}, uma amostra aleatória
de tamanho @var{n} será simulada.

Somente o método inverso genérico está implementado. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn



@deffn {Função} pdf_laplace (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória @math{Laplace(a,b)}, com @math{b>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_laplace (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Laplace(a,b)}, com @math{b>0}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} quantile_laplace (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Laplace(a,b)}, com
@math{b>0}; em outras palavras, essa função é a inversa da função
@code{cdf_laplace}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_laplace (@var{a},@var{b})
Retorna a média de uma variável aleatória @math{Laplace(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_laplace (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Laplace(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_laplace (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Laplace(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_laplace (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Laplace(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_laplace (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Laplace(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} random_laplace (@var{a},@var{b})
@deffnx {Função} random_laplace (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Laplace(a,b)}, com @math{b>0}.
Chamando @code{random_laplace} com um terceiro argumento @var{n}, uma
amostra aleatória de tamanho @var{n} será simulada.

Somente o método inverso genérico está implementado. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn



@deffn {Função} pdf_cauchy (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma
variável aleatória @math{Cauchy(a,b)}, com @math{b>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_cauchy (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Cauchy(a,b)}, com @math{b>0}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} quantile_cauchy (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Cauchy(a,b)}, com
@math{b>0}; em outras palavras, essa função é a inversa da função
@code{cdf_cauchy}. O argumento @var{q} deve ser um elemento de @math{[0,1]}. Para
fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} random_cauchy (@var{a},@var{b})
@deffnx {Função} random_cauchy (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo aleatória @math{Cauchy(a,b)}, com @math{b>0}.
Chamando @code{random_cauchy} com um terceiro argumento @var{n}, uma amostra
aleatória de tamanho @var{n} será simulada.

Somente o método inverso genérico está implementado. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn



@deffn {Função} pdf_gumbel (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função densidade de probabilidade de uma variável
aleatória @math{Gumbel(a,b)}, com @math{b>0}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_gumbel (@var{x},@var{a},@var{b})
Retorna o valor em @var{x} da função distribuição de probabilidade de uma
variável aleatória @math{Gumbel(a,b)}, com @math{b>0}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} quantile_gumbel (@var{q},@var{a},@var{b})
Retorna o @var{q}-quantil de uma variável aleatória @math{Gumbel(a,b)}, com
@math{b>0}; em outras palavras, essa função é a inversa da função
@code{cdf_gumbel}. O argumento @var{q} deve ser um elemento de @math{[0,1]}. Para
fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_gumbel (@var{a},@var{b})
Retorna a média de uma variável aleatória @math{Gumbel(a,b)}, com @math{b>0}.

@c ===beg===
@c load (distrib)$
@c assume(b>0)$  mean_gumbel(a,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(b>0)$  mean_gumbel(a,b);
(%o3)                     %gamma b + a
@end example
onde o símbolol @code{%gamma} representa a constante de Euler-Mascheroni.
Veja também @code{%gamma}.
@end deffn


@deffn {Função} var_gumbel (@var{a},@var{b})
Retorna a variância de uma variável aleatória @math{Gumbel(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_gumbel (@var{a},@var{b})
Retorna o desvio padrão de uma variável aleatória @math{Gumbel(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_gumbel (@var{a},@var{b})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Gumbel(a,b)}, com @math{b>0}.

@c ===beg===
@c load (distrib)$
@c assume(b>0)$ skewness_gumbel(a,b);
@c numer:true$ skewness_gumbel(a,b);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) assume(b>0)$ skewness_gumbel(a,b);
                       12 sqrt(6) zeta(3)
(%o3)                  ------------------
                                 3
                              %pi
(%i4) numer:true$ skewness_gumbel(a,b);
(%o5)                   1.139547099404649
@end example
onde @code{zeta} representa a função zeta de Riemann.
@end deffn


@deffn {Função} kurtosis_gumbel (@var{a},@var{b})
Retorna o coeficiente de curtose de uma variável aleatória @math{Gumbel(a,b)},
com @math{b>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} random_gumbel (@var{a},@var{b})
@deffnx {Função} random_gumbel (@var{a},@var{b},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Gumbel(a,b)},
com @math{b>0}. Chamando @code{random_gumbel} com um terceiro argumento @var{n},
uma amostra aleatória de tamanho @var{n} será simulada.

Somente o método inverso genérico está implementado. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@node Definições para distribuições discretas,  , Definições para distribuições contínuas, distrib
@section Definições para distribuições discretas


@deffn {Função} pdf_binomial (@var{x},@var{n},@var{p})
Retorna o valor em @var{x} da função de probabilidade de uma @math{Binomial(n,p)}
variável aleatória, com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_binomial (@var{x},@var{n},@var{p})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma @math{Binomial(n,p)} variável aleatória, com @math{0<p<1} e @math{n} um inteiro positivo.

@code{cdf_binomial} é calculada numéricamente se a variável global @code{numer}
for igual a @code{true},  de outra forma @code{cdf_binomial} retorna uma expressão nominal.

@c ===beg===
@c load (distrib)$
@c cdf_binomial(5,7,1/6);
@c cdf_binomial(5,7,1/6), numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_binomial(5,7,1/6);
                                         1
(%o2)                 cdf_binomial(5, 7, -)
                                         6
(%i3) cdf_binomial(5,7,1/6), numer;
(%o3)                   .9998713991769548
@end example
@end deffn


@deffn {Função} quantile_binomial (@var{q},@var{n},@var{p})
Retorna o @var{q}-quantil de uma variável aleatória @math{Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo; em outras palavras, essa
função é a inversa da função @code{cdf_binomial}. O argumento
@var{q} deve ser um elemento de @math{[0,1]}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_binomial (@var{n},@var{p})
Retorna a média de uma variável aleatória @math{Binomial(n,p)}, com
@math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_binomial (@var{n},@var{p})
Retorna a variância de uma variável aleatória @math{Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_binomial (@var{n},@var{p})
Retorna o desvio padrão de uma variável aleatória @math{Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_binomial (@var{n},@var{p})
Retorna o coeficiente de assimetria de uma variável aleatória 
@math{Binomial(n,p)}, com @math{0<p<1} e @math{n} um inteiro positivo. Para
fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_binomial (@var{n},@var{p})
Retorna o coeficiente de curtose de uma variável aleatória @math{Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_binomial_algorithm
Valor por omissão: @code{kachit}

Esse é o algoritmo seleccionado para simular rvariáveis estatísticas pseudo-aleatórias
binomiais. Os algoritmos implementados são @code{kachit}, @code{bernoulli} e @code{inverse}:
@itemize @bullet

@item
@code{kachit}, baseado no algoritmo descrito em Kachitvichyanukul, V. and
Schmeiser, B.W. (1988) @var{Binomial Random Variate Generation}. Communications of the ACM, 31, Feb., 216.

@item
@code{bernoulli}, baseado na simulação testes de Bernoulli.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_binomial}.
@end defvr


@deffn {Função} random_binomial (@var{n},@var{p})
@deffnx {Função} random_binomial (@var{n},@var{p},@var{m})
Retorna uma variável estatística pseudo-aleatória @math{Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Chamando @code{random_binomial}
com um terceiro argumento @var{m}, uma amostra aleatória de tamanho @var{m} será
simulada.

Existem três algoritmos implementado para essa função, se pode
seleccionar o algoritmo a ser usado fornecendo um certo valor à variável
global @code{random_binomial_algorithm}, cujo valor padrão é @code{kachit}.

Veja também @code{random_binomial_algorithm}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_poisson (@var{x},@var{m})
Retorna o valor em @var{x} da função de probabilidade de uma
variável aleatória @math{Poisson(m)}, com @math{m>0}. Para fazer
uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_poisson (@var{x},@var{m})
Retorna o valor em @var{x} da função distribuição de
probabilidade de uma variável aleatória @math{Poisson(m)}, com @math{m>0}.

Essa função é calculada numéricamente se a variável global
@code{numer} for igual a @code{true},  de outra forma essa função
retorna uma expressão nominal.

@c ===beg===
@c load (distrib)$
@c cdf_poisson(3,5);
@c cdf_poisson(3,5), numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_poisson(3,5);
(%o2)                   cdf_poisson(3, 5)
(%i3) cdf_poisson(3,5), numer;
(%o3)                   .2650259152973617
@end example
@end deffn


@deffn {Função} quantile_poisson (@var{q},@var{m})
Retorna o @var{q}-quantil de uma variável aleatória @math{Poisson(m)},
com @math{m>0}; em outras palavras, essa função é a inversa da
função @code{cdf_poisson}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_poisson (@var{m})
Retorna a média de uma variável aleatória @math{Poisson(m)},
com @math{m>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_poisson (@var{m})
Retorna a variância de uma variável aleatória @math{Poisson(m)},
com  @math{m>0}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_poisson (@var{m})
Retorna o desvio padrão de uma variável aleatória @math{Poisson(m)},
com @math{m>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_poisson (@var{m})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Poisson(m)},
com @math{m>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_poisson (@var{m})
Retorna o coeficiente de curtose de uma Poisson variável aleatória  @math{Poi(m)},
com @math{m>0}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_poisson_algorithm
Valor por omissão: @code{ahrens_dieter}

Esse é o algoritmo seleccionado para simular variáveis estatísticas
pseudo-aleatórias de Poisson.Os algoritmos implementados são @code{ahrens_dieter} e @code{inverse}:
@itemize @bullet

@item
@code{ahrens_dieter}, baseado no algoritmo descrito em Ahrens, J.H. and
Dieter, U. (1982) @var{Computer Generation of Poisson Deviates From Modified Normal Distributions}.
ACM Trans. Math. Software, 8, 2, June,163-179.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_poisson}.
@end defvr


@deffn {Função} random_poisson (@var{m})
@deffnx {Função} random_poisson (@var{m},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Poisson(m)}, com @math{m>0}.
Chamando @code{random_poisson} com um segundo argumento @var{n}, uma amostra
aleatória de tamanho @var{n} será simulada.

Existem dois algoritmos implementado para essa função, se pode seleccionar o
algoritmo a ser usado fornecendo um certo valor à variável global 
@code{random_poisson_algorithm}, cujo valor padrão é
@code{ahrens_dieter}.

Veja também @code{random_poisson_algorithm}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_bernoulli (@var{x},@var{p})
Retorna o valor em @var{x} da função de probabilidade de uma
variável aleatória @math{Bernoulli(p)}, com @math{0<p<1}.

A variável aleatória @math{Bernoulli(p)} é equivalente a @math{Binomial(1,p)},
embora quando Maxima não tiver informação disponível para pegar o
resultado, uma forma nominal baseada na função binomial de
probabilidade é retornada.

@c ===beg===
@c load (distrib)$
@c pdf_bernoulli(1,p);
@c assume(0<p,p<1)$ pdf_bernoulli(1,p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) pdf_bernoulli(1,p);
(%o2)                 pdf_binomial(1, 1, p)
(%i3) assume(0<p,p<1)$ pdf_bernoulli(1,p);
(%o4)                           p
@end example
@end deffn


@deffn {Função} cdf_bernoulli (@var{x},@var{p})
Retorna o valor em @var{x} da função distribuição de
probabilidade de uma variável aleatória @math{Bernoulli(p)}, com @math{0<p<1}.
Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} quantile_bernoulli (@var{q},@var{p})
Retorna o @var{q}-quantil de uma variável aleatória @math{Bernoulli(p)},
com @math{0<p<1}; em outras palavras, essa função é a inversa da
função @code{cdf_bernoulli}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_bernoulli (@var{p})
Retorna a média de uma variável aleatória @math{Bernoulli(p)}, com @math{0<p<1}.

A variável aleatória @math{Bernoulli(p)} é equivalente a @math{Binomial(1,p)}, embora
quando Maxima não tiver informação disponível para pegar o resultado, uma forma
nominal baseada na média binomial é retornada.

@c ===beg===
@c load (distrib)$
@c mean_bernoulli(p);
@c assume(0<p,p<1)$ mean_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) mean_bernoulli(p);
(%o2)                  mean_binomial(1, p)
(%i3) assume(0<p,p<1)$ mean_bernoulli(p);
(%o4)                           p
@end example
@end deffn


@deffn {Função} var_bernoulli (@var{p})
Retorna a variância de uma variável aleatória @math{Bernoulli(p)}, com @math{0<p<1}.

A variável aleatória @math{Bernoulli(p)} é equivalente a @math{Binomial(1,p)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada na variância binomial é retornada.

@c ===beg===
@c load (distrib)$
@c var_bernoulli(p);
@c assume(0<p,p<1)$ var_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) var_bernoulli(p);
(%o2)                  var_binomial(1, p)
(%i3) assume(0<p,p<1)$ var_bernoulli(p);
(%o4)                       (1 - p) p
@end example
@end deffn


@deffn {Função} std_bernoulli (@var{p})
Retorna o desvio padrão de uma variável aleatória @math{Bernoulli(p)}, com @math{0<p<1}.

A variável aleatória @math{Bernoulli(p)} é equivalente a
@math{Binomial(1,p)}, embora quando Maxima não tiver informação
disponível para pegar o resultado, uma forma nominal baseada no desvio
padrão binomial é retornada.

@c ===beg===
@c load (distrib)$
@c std_bernoulli(p);
@c assume(0<p,p<1)$ std_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) std_bernoulli(p);
(%o2)                  std_binomial(1, p)
(%i3) assume(0<p,p<1)$ std_bernoulli(p);
(%o4)                  sqrt(1 - p) sqrt(p)
@end example
@end deffn


@deffn {Função} skewness_bernoulli (@var{p})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Bernoulli(p)}, com @math{0<p<1}.

A variável aleatória @math{Bernoulli(p)} é equivalente a @math{Binomial(1,p)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no coeficiente de assimetria binomial é retornada.

@c ===beg===
@c load (distrib)$
@c skewness_bernoulli(p);
@c assume(0<p,p<1)$ skewness_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) skewness_bernoulli(p);
(%o2)                skewness_binomial(1, p)
(%i3) assume(0<p,p<1)$ skewness_bernoulli(p);
                             1 - 2 p
(%o4)                  -------------------
                       sqrt(1 - p) sqrt(p)
@end example
@end deffn


@deffn {Função} kurtosis_bernoulli (@var{p})
Retorna o coeficiente de curtose de uma variável aleatória @math{Bernoulli(p)}, com @math{0<p<1}.

A variável aleatória @math{Bernoulli(p)} é equivalente a @math{Binomial(1,p)},
embora quando Maxima não tiver informação disponível para pegar o resultado,
uma forma nominal baseada no coeficiente de curtose binomial é retornada.

@c ===beg===
@c load (distrib)$
@c kurtosis_bernoulli(p);
@c assume(0<p,p<1)$ kurtosis_bernoulli(p);
@c ===end===
@example
(%i1) load (distrib)$
(%i2) kurtosis_bernoulli(p);
(%o2)                kurtosis_binomial(1, p)
(%i3) assume(0<p,p<1)$ kurtosis_bernoulli(p);
                         1 - 6 (1 - p) p
(%o4)                    ---------------
                            (1 - p) p
@end example
@end deffn


@deffn {Função} random_bernoulli (@var{p})
@deffnx {Função} random_bernoulli (@var{p},@var{n})
Retorna uma variável estatística pseudo-aleatória @math{Bernoulli(p)},
com @math{0<p<1}. Chamando @code{random_bernoulli} com um segundo
argumento @var{n}, uma amostra aleatória de tamanho @var{n} será simulada.

Essa é uma aplicação directa da função @code{random} built-in função do Maxima.

Veja também @code{random}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_geometric (@var{x},@var{p})
Retorna o valor em @var{x} da função de probabilidade de uma variável
aleatória @math{Geometric(p)}, com @math{0<p<1}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_geometric (@var{x},@var{p})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Geometric(p)}, com @math{0<p<1}. Para fazer
uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} quantile_geometric (@var{q},@var{p})
Retorna o @var{q}-quantil de uma variável aleatória @math{Geometric(p)},
com @math{0<p<1}; em outras palavras, essa função é a inversa da
função @code{cdf_geometric}. O argumento @var{q} deve ser um elemento de
@math{[0,1]}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_geometric (@var{p})
Retorna a média de uma variável aleatória @math{Geometric(p)},
com @math{0<p<1}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_geometric (@var{p})
Retorna a variância de uma variável aleatória @math{Geometric(p)},
com @math{0<p<1}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_geometric (@var{p})
Retorna o desvio padrão de uma variável aleatória @math{Geometric(p)},
com @math{0<p<1}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_geometric (@var{p})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Geometric(p)},
com @math{0<p<1}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_geometric (@var{p})
Retorna o coeficiente de curtose de uma geometric variável aleatória  @math{Geo(p)},
com @math{0<p<1}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_geometric_algorithm
Valor por omissão: @code{bernoulli}

Esse é o algoritmo seleccionado para simular variáveis estatísticas pseudo-aleatórias
geométricas. Algorítmos implementados são @code{bernoulli}, @code{devroye} e @code{inverse}:
@itemize @bullet

@item
@code{bernoulli}, baseado na simulação de testes de Bernoulli.

@item
@code{devroye}, baseado no algoritmo descrito em Devroye, L. (1986)
@var{Non-Uniform Random Variate Generation.} Springer Verlag, p. 480.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_geometric}.
@end defvr


@deffn {Função} random_geometric (@var{p})
@deffnx {Função} random_geometric (@var{p},@var{n})
Retorna um @math{Geometric(p)} variável estatística pseudo-aleatória, com @math{0<p<1}.
Chamando @code{random_geometric} com um segundo argumento @var{n}, uma amostra aleatória
de tamanho @var{n} será simulada.

Existem três algoritmos implementados para essa função, se
pode seleccionar o algoritmo a ser usado fornecendo um certo valor à
variável global @code{random_geometric_algorithm}, cujo valor padrão é
@code{bernoulli}.

Veja também @code{random_geometric_algorithm}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_discrete_uniform (@var{x},@var{n})
Retorna o valor em @var{x} da função de probabilidade de uma variável
aleatória @math{Discrete Uniform(n)}, com @math{n} a strictly positive integer. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} cdf_discrete_uniform (@var{x},@var{n})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma variável aleatória @math{Discrete Uniform(n)}, com @math{n} inteiro
estritamente positivo. Para fazer uso dessa função, escreva
primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} quantile_discrete_uniform (@var{q},@var{n})
Retorna o @var{q}-quantil de uma variável aleatória @math{Discrete Uniform(n)},
com @math{n} um inteiro estritamente positivo; em outras palavras, essa
função é a inversa da função @code{cdf_discrete_uniform}. O
argumento @var{q} deve ser um elemento de @math{[0,1]}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_discrete_uniform (@var{n})
Retorna a média de uma variável aleatória @math{Discrete Uniform(n)},
com @math{n} um inteiro estritamente positivo. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_discrete_uniform (@var{n})
Retorna a variância de uma variável aleatória @math{Discrete Uniform(n)},
com @math{n} um inteiro estritamente positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_discrete_uniform (@var{n})
Retorna o desvio padrão de uma variável aleatória @math{Discrete Uniform(n)},
com @math{n} um inteiro estritamente positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_discrete_uniform (@var{n})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Discrete Uniform(n)},
com @math{n} um inteiro estritamente positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_discrete_uniform (@var{n})
Retorna o coeficiente de curtose de uma variável aleatória @math{Discrete Uniform(n)},
com @math{n} um inteiro estritamente positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} random_discrete_uniform (@var{n})
@deffnx {Função} random_discrete_uniform (@var{n},@var{m})
Retorna uma variável estatística pseudo-aleatória @math{Discrete Uniform(n)},
com @math{n} um inteiro estritamente positivo. Chamando @code{random_discrete_uniform}
com um segundo argumento @var{m}, uma amostra aleatória de
tamanho @var{m} será simulada.

Isso é uma aplicação directa da função @code{random} built-in função do Maxima.

Veja também @code{random}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_hypergeometric (@var{x},@var{n1},@var{n2},@var{n})
Retorna o valor em @var{x} da função de probabilidade de uma
variável aleatória @math{Hypergeometric(n1,n2,n)}, com @var{n1}, @var{n2}
e @var{n} inteiros não negativos e @math{n<=n1+n2}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_hypergeometric (@var{x},@var{n1},@var{n2},@var{n})
Retorna o valor em @var{x} da função distribuição de
probabilidade de uma variável aleatória @math{Hypergeometric(n1,n2,n)},
com @var{n1}, @var{n2} e @var{n} inteiros não negativos e @math{n<=n1+n2}. Para
fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} quantile_hypergeometric (@var{q},@var{n1},@var{n2},@var{n})
Retorna o @var{q}-quantil de uma variável aleatória @math{Hypergeometric(n1,n2,n)},
com @var{n1}, @var{n2} e @var{n} inteiros não negativos e @math{n<=n1+n2}; em outras
palavras, essa função é a inversa da função @code{cdf_hypergeometric}.
O argumento @var{q} deve ser um elemento de @math{[0,1]}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_hypergeometric (@var{n1},@var{n2},@var{n})
Retorna a média de uma variável aleatória discreta univorme
@math{Hyp(n1,n2,n)}, com @var{n1}, @var{n2} e @var{n} inteiros não negativos
e @math{n<=n1+n2}. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_hypergeometric (@var{n1},@var{n2},@var{n})
Retorna a variância de uma variável aleatória hipergeométrica
@math{Hyp(n1,n2,n)}, com @var{n1}, @var{n2} e @var{n} inteiros
não negativos e @math{n<=n1+n2}. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_hypergeometric (@var{n1},@var{n2},@var{n})
Retorna o desvio padrão de uma variável aleatória @math{Hypergeometric(n1,n2,n)},
com @var{n1}, @var{n2} e @var{n} inteiros não negativos e @math{n<=n1+n2}. Para fazer uso dessa função, escreva primeiramente
@code{load(distrib)}.
@end deffn


@deffn {Função} skewness_hypergeometric (@var{n1},@var{n2},@var{n})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Hypergeometric(n1,n2,n)},
com @var{n1}, @var{n2} e @var{n} inteiros não negativos e @math{n<=n1+n2}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_hypergeometric (@var{n1},@var{n2},@var{n})
Retorna o coeficiente de curtose de uma variável aleatória @math{Hypergeometric(n1,n2,n)},
com @var{n1}, @var{n2} e @var{n} inteiros não negativos e @math{n<=n1+n2}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn

@defvr {Variável de opção} random_hypergeometric_algorithm
Valor por omissão: @code{kachit}

Esse é o algoritmo seleccionado para simular variáveis estatísticas pseudo
aleatórias hipergeométricas.Os algoritmos implementados são @code{kachit} e @code{inverse}:
@itemize @bullet

@item
@code{kachit}, baseado no algoritmo descrito em Kachitvichyanukul, V., Schmeiser, B.W. (1985)
@var{Computer generation of hypergeometric variáveis estatística pseudo-aleatórias.} Journal
of Statistical Computation and Simulation 22, 127-145.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_hypergeometric}.
@end defvr


@deffn {Função} random_hypergeometric (@var{n1},@var{n2},@var{n})
@deffnx {Função} random_hypergeometric (@var{n1},@var{n2},@var{n},@var{m})
Retorna uma variável estatística pseudo-aleatória @math{Hypergeometric(n1,n2,n)},
com @var{n1}, @var{n2} e @var{n} inteiros não negativos e @math{n<=n1+n2}. Chamando
@code{random_hypergeometric} com um quarto argumento @var{m}, uma amostra
aleatória de tamanho @var{m} será simulada.

Existem dois algoritmos implementados para essa função, se pode seleccionar o
algoritmo a ser usado fornecendo um certo valor à variável global @code{random_hypergeometric_algorithm},
cujo valor padrão é @code{kachit}.

Veja também @code{random_hypergeometric_algorithm}. Para fazer uso
dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} pdf_negative_binomial (@var{x},@var{n},@var{p})
Retorna o valor em @var{x} da função de probabilidade de uma variável
aleatória @math{Negative Binomial(n,p)}, com @math{0<p<1} e @math{n} um inteiro
positivo. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} cdf_negative_binomial (@var{x},@var{n},@var{p})
Retorna o valor em @var{x} da função distribuição de probabilidade
de uma @math{Negative Binomial(n,p)} variável aleatória, com @math{0<p<1} e @math{n} um inteiro positivo.

Essa função é calculada numéricamente se a variável global @code{numer} for
igual a @code{true},  de outra forma essa função retorna uma expressão nominal.

@c ===beg===
@c load (distrib)$
@c cdf_negative_binomial(3,4,1/8);
@c cdf_negative_binomial(3,4,1/8), numer;
@c ===end===
@example
(%i1) load (distrib)$
(%i2) cdf_negative_binomial(3,4,1/8);
                                             1
(%o2)            cdf_negative_binomial(3, 4, -)
                                             8
(%i3) cdf_negative_binomial(3,4,1/8), numer;
(%o3)                  .006238937377929698
@end example
@end deffn


@deffn {Função} quantile_negative_binomial (@var{q},@var{n},@var{p})
Retorna o @var{q}-quantil de uma variável aleatória @math{Negative Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo; em outras palavras, essa função
é a inversa da função @code{cdf_negative_binomial}. O argumento @var{q} deve ser
um elemento de @math{[0,1]}. Para fazer uso dessa função, escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} mean_negative_binomial (@var{n},@var{p})
Retorna a média de uma variável aleatória @math{Negative Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} var_negative_binomial (@var{n},@var{p})
Retorna a variância de uma variável aleatória @math{Negative Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} std_negative_binomial (@var{n},@var{p})
Retorna o desvio padrão de uma variável aleatória @math{Negative Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa função,
escreva primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} skewness_negative_binomial (@var{n},@var{p})
Retorna o coeficiente de assimetria de uma variável aleatória @math{Negative Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@deffn {Função} kurtosis_negative_binomial (@var{n},@var{p})
Retorna o coeficiente de curtose de uma variável aleatória @math{Negative Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Para fazer uso dessa função, escreva
primeiramente @code{load(distrib)}.
@end deffn


@defvr {Variável de opção} random_negative_binomial_algorithm
Valor por omissão: @code{bernoulli}

Esse é o algoritmo seleccionado para simular variáveis estatísticas pseuso-aleatórias
binomiais negativas. Os algoritmos implementados são @code{devroye}, @code{bernoulli}
e @code{inverse}:
@itemize @bullet

@item
@code{devroye}, baseado no algoritmo descrito em Devroye, L. (1986)
@var{Non-Uniform Random Variate Generation}. Springer Verlag, p. 480.

@item
@code{bernoulli}, baseado na simulação de testes de Bernoulli.

@item
@code{inverse}, baseado no método inverso genérico.

@end itemize

Veja também @code{random_negative_binomial}.
@end defvr


@deffn {Função} random_negative_binomial (@var{n},@var{p})
@deffnx {Função} random_negative_binomial (@var{n},@var{p},@var{m})
Retorna uma variável estatística pseudo-aleatória @math{Negative Binomial(n,p)},
com @math{0<p<1} e @math{n} um inteiro positivo. Chamando @code{random_negative_binomial}
com um terceiro argumento @var{m}, uma amostra aleatória de tamanho
@var{m} será simulada.

Existem três algoritmos implementados para essa função, se pode
seleccionar o algoritmo a ser usado fornecendo um certo valor à variável global
@code{random_negative_binomial_algorithm}, cujo valor padrão é @code{bernoulli}.

Veja também @code{random_negative_binomial_algorithm}. Para fazer uso dessa
função, escreva primeiramente @code{load(distrib)}.
@end deffn

