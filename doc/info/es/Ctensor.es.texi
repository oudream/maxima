@c English version 2011-03-14
@menu
* Introducción a ctensor::     
* Funciones y variables para ctensor::     
@end menu

@node Introducción a ctensor, Funciones y variables para ctensor, ctensor, ctensor
@section Introducción a ctensor

El paquete @code{ctensor} dispone de herramientas para manipular componentes de tensores. Para poder hacer uso de @code{ctensor} es necesario cargarlo previamente en memoria ejecutando  @code{load(ctensor)}. Para comenzar una sesión interactiva con @code{ctensor}, ejecutar la función @code{csetup()}. Primero se le pregunta al usuario la dimensión de la variedad. Si la dimensión es 2, 3 o 4, entonces la lista de coordenadas será por defecto  @code{[x,y]}, @code{[x,y,z]}
o @code{[x,y,z,t]}, respectivamente. Estos nombres pueden cambiarse asignando una nueva lista de coordenadas a la variable @code{ct_coords} (que se describe más abajo), siendo el usuario advertido sobre este particular. 
Se debe tener cuidado en evitar que los nombres de las coordenadas entren en conflicto con los nombres de otros objetos en Maxima.

A continuación, el usuario introduce la métrica, bien directamente, o desde un fichero especificando su posición ordinal. 
@c NO SUCH FILE !
@c As an example of a file of common metrics, see @code{share/tensor/metrics.mac}.
La métrica se almacena en la matriz @code{lg}. Por último, la métrica inversa se obtiene y almacena en la matriz @code{ug}. También se dispone de la opción de efectuar todos los cálculos en serie de potencias.

Se desarrolla a continuación un ejemplo para la métrica estática, esférica y simétrica, en coordenadas estándar, que se aplicará posteriormente al problema de derivar las ecuaciones de vacío de Einstein (de las que se obtiene la solución de Schwarzschild). Muchas de las funciones de @code{ctensor} se mostrarán  en los ejemplos para la métrica estándar.

@example
(%i1) load(ctensor);
(%o1)      /share/tensor/ctensor.mac
(%i2) csetup();
Enter the dimension of the coordinate system: 
4;
Do you wish to change the coordinate names?
n;
Do you want to
1. Enter a new metric?

2. Enter a metric from a file?

3. Approximate a metric with a Taylor series?
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;
Row 1 Column 1:
a;
Row 2 Column 2:
x^2;
Row 3 Column 3:
x^2*sin(y)^2;
Row 4 Column 4:
-d;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none 
depends([a,d],x);
Do you wish to see the metric? 
y;
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%o2)                                done
(%i3) christof(mcs);
                                            a
                                             x
(%t3)                          mcs        = ---
                                  1, 1, 1   2 a

                                             1
(%t4)                           mcs        = -
                                   1, 2, 2   x

                                             1
(%t5)                           mcs        = -
                                   1, 3, 3   x

                                            d
                                             x
(%t6)                          mcs        = ---
                                  1, 4, 4   2 d

                                              x
(%t7)                          mcs        = - -
                                  2, 2, 1     a

                                           cos(y)
(%t8)                         mcs        = ------
                                 2, 3, 3   sin(y)

                                               2
                                          x sin (y)
(%t9)                      mcs        = - ---------
                              3, 3, 1         a

(%t10)                   mcs        = - cos(y) sin(y)
                            3, 3, 2

                                            d
                                             x
(%t11)                         mcs        = ---
                                  4, 4, 1   2 a
(%o11)                               done

@end example


@node Funciones y variables para ctensor,  , Introducción a ctensor, ctensor
@section Funciones y variables para ctensor

@subsection Inicialización y preparación

@deffn {Función} csetup ()
Es la función del paquete @code{ctensor} que inicializa el paquete y permite al usuario introducir una métrica de forma interactiva. Véase @code{ctensor} para más detalles.
@end deffn

@deffn {Función} cmetric (@var{dis})
@deffnx {Función} cmetric ()
Es la función del paquete @code{ctensor} que calcula la métrica inversa y prepara el paquete para cálculos ulteriores.

Si @code{cframe_flag} vale @code{false}, la función calcula la métrica inversa @code{ug} a partir de la matriz @code{lg} definida por el usuario. Se calcula también la métrica determinante y se almacena en la variable @code{gdet}. Además, el paquete determina si la métrica es diagonal y ajusta el valor de @code{diagmetric} de la forma apropiada. Si el argumento opcional @var{dis} está presente y no es igual a @code{false}, el usuario podrá ver la métrica inversa.

Si @code{cframe_flag} vale @code{true}, la función espera que los valores de @code{fri} (la matriz del sistema de referencia inverso) y @code{lfg} (la matriz del sistema de referencia) estén definidos. A partir de ellos, se calculan la matriz del sistema de referencia @code{fr} y su métrica @code{ufg}.

@end deffn


@deffn {Función} ct_coordsys (@var{sistema_coordenadas}, @var{extra_arg})
@deffnx {Función} ct_coordsys (@var{sistema_coordenadas})

Prepara un sistema de coordenadas predefinido y una métrica. El argumento @var{sistema_coordenadas} puede ser cualquiera de los siguientes símbolos:

@example

  Símbolo              Dim Coordenadas       Descripción/comentarios
  --------------------------------------------------------------------------------
  cartesian2d           2  [x,y]             Sistema de coordenadas cartesianas en 2D
  polar                 2  [r,phi]           Sistema de coordenadas polares
  elliptic              2  [u,v]             Sistema de coordenadas elípticas
  confocalelliptic      2  [u,v]             Coordenadas elípticas confocales
  bipolar               2  [u,v]             Sistema de coordenas bipolares
  parabolic             2  [u,v]             Sistema de coordenadas parabólicas
  cartesian3d           3  [x,y,z]           Sistema de coordenadas cartesianas en 3D
  polarcylindrical      3  [r,theta,z]       Polares en 2D con cilíndrica z
  ellipticcylindrical   3  [u,v,z]           Elípticas en 2D con cilíndrica z
  confocalellipsoidal   3  [u,v,w]           Elipsoidales confocales
  bipolarcylindrical    3  [u,v,z]           Bipolares en 2D con cilíndrica z
  paraboliccylindrical  3  [u,v,z]           Parabólicas en 2D con cilíndrica z
  paraboloidal          3  [u,v,phi]         Coordenadas paraboloidales
  conical               3  [u,v,w]           Coordenadas cónicas
  toroidal              3  [u,v,phi]         Coordenadas toroidales
  spherical             3  [r,theta,phi]     Sistema de coordenadas esféricas
  oblatespheroidal      3  [u,v,phi]         Coordenadas esferoidales obleadas
  oblatespheroidalsqrt  3  [u,v,phi]
  prolatespheroidal     3  [u,v,phi]         Coordenadas esferoidales prolatas
  prolatespheroidalsqrt 3  [u,v,phi]
  ellipsoidal           3  [r,theta,phi]     Coordenadas elipsoidales
  cartesian4d           4  [x,y,z,t]         Sistema de coordenadas cartesianas en 4D
  spherical4d           4  [r,theta,eta,phi] Sistema de coordenadas esféricas en 4D
  exteriorschwarzschild 4  [t,r,theta,phi]   Métrica de Schwarzschild
  interiorschwarzschild 4  [t,z,u,v]         Métrica interior de Schwarzschild
  kerr_newman           4  [t,r,theta,phi]   Métrica simétrica con carga axial

@end example

El argumento @code{sistema_coordenadas} puede ser también una lista de funciones de transformación, seguida de una lista que contenga los nombres de las coordenadas. Por ejemplo, se puede especificar una métrica esférica como se indica a continuación:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o2)                                done
(%i3) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o3)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]
(%i4) ct_coords;
(%o4)                           [r, theta, phi]
(%i5) dim;
(%o5)                                  3

@end example

Las funciones de transformación se pueden utilizar también si @code{cframe_flag} vale @code{true}:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) cframe_flag:true;
(%o2)                                true
(%i3) ct_coordsys([r*cos(theta)*cos(phi),r*cos(theta)*sin(phi),
      r*sin(theta),[r,theta,phi]]);
(%o3)                                done
(%i4) fri;
      [ cos(phi) cos(theta)  - cos(phi) r sin(theta)  - sin(phi) r cos(theta) ]
      [                                                                       ]
(%o4) [ sin(phi) cos(theta)  - sin(phi) r sin(theta)   cos(phi) r cos(theta)  ]
      [                                                                       ]
      [     sin(theta)            r cos(theta)                   0            ]
(%i5) cmetric();
(%o5)                                false
(%i6) lg:trigsimp(lg);
                           [ 1  0         0        ]
                           [                       ]
                           [     2                 ]
(%o6)                      [ 0  r         0        ]
                           [                       ]
                           [         2    2        ]
                           [ 0  0   r  cos (theta) ]

@end example

El argumento opcional @var{extra_arg} puede ser cualquiera de los siguientes:

@code{cylindrical} indica a @code{ct_coordsys} que añada una coordenada cilíndrica más.

@code{minkowski} indica a  @code{ct_coordsys} que añada una coordenada más con signatura métrica negativa.

@code{all} indica a  @code{ct_coordsys} que llame a  @code{cmetric} y a @code{christof(false)} tras activar la métrica.

Si la variable global @code{verbose} vale @code{true}, @code{ct_coordsys} muestra los valores de @code{dim}, @code{ct_coords}, junto con @code{lg} o @code{lfg} y @code{fri}, dependiendo del valor de @code{cframe_flag}.

@end deffn

@deffn {Función} init_ctensor ()
Inicializa el paquete @code{ctensor}.

La función @code{init_ctensor} reinicializa el paquete @code{ctensor}. Borra todos los arreglos ("arrays") y matrices utilizados por @code{ctensor} y reinicializa todas las variables, asignando a @code{dim} el valor 4 y la métrica del sistema de referencia a la de Lorentz.

@end deffn

@subsection Los tensores del espacio curvo

El propósito principal del paquete @code{ctensor} es calcular los tensores del espacio (-tiempo) curvo, en especial los tensores utilizados en relatividad general.

Cuando se utiliza una métrica, @code{ctensor} puede calcular los siguientes tensores:

@example

 lg  -- ug
   \      \
    lcs -- mcs -- ric -- uric 
              \      \       \
               \      tracer - ein -- lein
                \
                 riem -- lriem -- weyl
                     \
                      uriem


@end example

El paquete @code{ctensor} también puede trabajar con sistemas de referencia móviles. Si @code{cframe_flag} vale @code{true}, se pueden calcular los siguientes tensores:

@example

 lfg -- ufg
     \
 fri -- fr -- lcs -- mcs -- lriem -- ric -- uric
      \                       |  \      \       \
       lg -- ug               |   weyl   tracer - ein -- lein
                              |\
                              | riem
                              |
                              \uriem

@end example

@deffn {Función} christof (@var{dis})
Es una función del paquete @code{ctensor}. Calcula los símbolos de Christoffel de ambos tipos. El argumento @var{dis} determina qué resultados se mostrarán de forma inmediata. Los símbolos de Christoffel de primer y segundo tipo se almacenan en los arreglos  @code{lcs[i,j,k]} y @code{mcs[i,j,k]}, respectivamente, y se definen simétricos en sus dos primeros índices. Si el argumento de @code{christof} es @code{lcs} o @code{mcs} entonces serán mostrados únicamente los valores no nulos de @code{lcs[i,j,k]} o @code{mcs[i,j,k]}, respectivamente. Si el argumento es @code{all} entonces se mostrarán los valores no nulos de @code{lcs[i,j,k]} y @code{mcs[i,j,k]}.  Si el argumento vale @code{false} entonces no se mostrarán los elementos. El arreglo @code{mcs[i,j,k]} está definido de tal modo que el último índice es contravariante.
@end deffn

@deffn {Función} ricci (@var{dis})
Es una función del paquete @code{ctensor}. La función @code{ricci} calcula las componentes covariantes (simétricas) 
@code{ric[i,j]} del tensor de Ricci. Si el argumento @var{dis} vale @code{true}, entonces se muestran las componentes no nulas.
@end deffn


@deffn {Función} uricci (@var{dis})
Esta función calcula en primer lugar las componentes covariantes  @code{ric[i,j]} del tensor de Ricci. Después se calcula el tensor de Ricci utilizando la métrica contravariante. Si el valor del argumento @var{dis} vale @code{true}, entonces se mostrarán directamente las componentes @code{uric[i,j]} (el índice @var{i} es covariante y el @var{j} contravariante). En otro caso,  @code{ricci(false)} simplemente calculará las entradas del arreglo @code{uric[i,j]} sin mostrar los resultados.

@end deffn

@deffn {Función} scurvature ()

Devuelve la curvatura escalar (obtenida por contracción del tensor de Ricci) de la variedad de Riemannian con la métrica dada.

@end deffn

@deffn {Función} einstein (@var{dis})
Es una función del paquete @code{ctensor}. La función  @code{einstein} calcula el tensor de Einstein después de que los símbolos de  Christoffel y el tensor de Ricci hayan sido calculados (con las funciones @code{christof} y @code{ricci}).  Si el argumento @var{dis} vale @code{true}, entonces se mostrarán los valores no nulos del tensor de Einstein @code{ein[i,j]}, donde @code{j} es el índice contravariante. La variable @code{rateinstein} causará la simplificación racional de estas componentes. Si @code{ratfac} vale @code{true} entonces las componentes también se factorizarán.

@end deffn

@deffn {Función} leinstein (@var{dis})
Es el tensor covariante de Einstein. La función @code{leinstein} almacena los valores del tensor covariante de Einstein en el arreglo @code{lein}. El tensor covariante de Einstein se calcula a partir del tensor de Einstein @code{ein} multiplicándolo por el tensor métrico. Si el argumento  @var{dis} vale @code{true}, entonces se mostrarán los valores no nulos del tensor covariante de Einstein.

@end deffn

@deffn {Función} riemann (@var{dis})
Es una función del paquete @code{ctensor}. La función @code{riemann} calcula el tensor de curvatura de Riemann a partir de la métrica dada y de los símbolos de Christoffel correspondientes. Se utiliza el siguiente convenio sobre los índices:

@example
                l      _l       _l       _l   _m    _l   _m
 R[i,j,k,l] =  R    = |      - |      + |    |   - |    |
                ijk     ij,k     ik,j     mk   ij    mj   ik
@end example

Esta notación es consistente con la notación utilizada por el paquete @code{itensor} y su función @code{icurvature}. Si el argumento opcional @var{dis} vale @code{true}, se muestran las componentes no nulas únicas de @code{riem[i,j,k,l]}. Como en el caso del tensor de Einstein, ciertas variables permiten controlar al usuario la simplificación de las componentes del tensor de Riemann. Si  @code{ratriemann} vale @code{true}, entonces se hará la simplificación racional. Si @code{ratfac} vale @code{true}, entonces se factorizarán todas las componentes.

Si la variable @code{cframe_flag} vale @code{false}, el tensor de Riemann se calcula directamente a partir de los símbolos de Christoffel. Si @code{cframe_flag} vale @code{true}, el tensor covariante de Riemann se calcula a partir de los coeficientes del campo.

@end deffn

@deffn {Función} lriemann (@var{dis})
Es el tensor covariante de Riemann (@code{lriem[]}).

Calcula el tensor covariante de Riemann como un arreglo @code{lriem}. Si el argumento @var{dis} vale @code{true}, sólo se muestran los valores no nulos.

Si la variable @code{cframe_flag} vale @code{true}, el tensor covariante de Riemann se calcula directamente de los coeficientes del campo. En otro caso, el tensor de Riemann (3,1) se calcula en primer lugar.

Para más información sobre la ordenación de los índices, véase @code{riemann}.

@end deffn

@deffn {Función} uriemann (@var{dis})
Calcula las componentes contravariantes del tensor de curvatura de Riemann como un arreglo @code{uriem[i,j,k,l]}.  Éstos se muestran si @var{dis} vale @code{true}.

@end deffn

@deffn {Función} rinvariant ()
Calcula la invariante de Kretchmann (@code{kinvariant}) obtenida por contracción de los tensores.

@example
lriem[i,j,k,l]*uriem[i,j,k,l].
@end example

Este objeto no se simplifica automáticamente al ser en ocasiones muy grande.

@end deffn

@deffn {Función} weyl (@var{dis})
Calcula el tensor conforme de Weyl. Si el argumento @var{dis} vale @code{true}, se le mostrarán al usuario las componentes no nulas @code{weyl[i,j,k,l]}. En otro caso, estas componentes serán únicamente calculadas y almacenadas. Si la variable @code{ratweyl} vale @code{true}, entonces las componentes se simplifican racionalmente; si @code{ratfac} vale @code{true} los resultados también se simplificarán.

@end deffn

@subsection Desarrollo de Taylor

El paquete @code{ctensor} puede truncar resultados e interpretarlos como aproximaciones de Taylor. Este comportamiento se controla con lavariable @code{ctayswitch}; cuando vale @code{true}, @code{ctensor} utiliza internamente la función @code{ctaylor} cuando simplifica resultados.

La función @code{ctaylor} es llamada desde las siguientes funciones del paquete @code{ctensor}:

@example

    Función      Comentarios
    ---------------------------------
    christof()   Sólo para mcs
    ricci()
    uricci()
    einstein()
    riemann()
    weyl()
    checkdiv()
@end example

@deffn {Función} ctaylor ()

La función @code{ctaylor} trunca su argumento convirtiéndolo en un desarrollo de Taylor por medio de la función @code{taylor} e invocando después a @code{ratdisrep}. Esto tiene el efecto de eliminar términos de orden alto en la variable de expansión @code{ctayvar}. El orden de los términos que deben ser eliminados se define @code{ctaypov}; el punto alrededor del cual se desarrolla la serie se especifica en @code{ctaypt}.

Como ejemplo, considérese una sencilla métrica que es una perturbación de la de Minkowski. Sin añadir restricciones, incluso una métrica diagonal produce expansiones del tensor de Einstein que pueden llegar a ser muy complejas:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) derivabbrev:true;
(%o3)                                true
(%i4) ct_coords:[t,r,theta,phi];
(%o4)                         [t, r, theta, phi]
(%i5) lg:matrix([-1,0,0,0],[0,1,0,0],[0,0,r^2,0],[0,0,0,r^2*sin(theta)^2]);
                        [ - 1  0  0         0        ]
                        [                            ]
                        [  0   1  0         0        ]
                        [                            ]
(%o5)                   [          2                 ]
                        [  0   0  r         0        ]
                        [                            ]
                        [              2    2        ]
                        [  0   0  0   r  sin (theta) ]
(%i6) h:matrix([h11,0,0,0],[0,h22,0,0],[0,0,h33,0],[0,0,0,h44]);
                            [ h11   0    0    0  ]
                            [                    ]
                            [  0   h22   0    0  ]
(%o6)                       [                    ]
                            [  0    0   h33   0  ]
                            [                    ]
                            [  0    0    0   h44 ]
(%i7) depends(l,r);
(%o7)                               [l(r)]
(%i8) lg:lg+l*h;
         [ h11 l - 1      0          0                 0            ]
         [                                                          ]
         [     0      h22 l + 1      0                 0            ]
         [                                                          ]
(%o8)    [                        2                                 ]
         [     0          0      r  + h33 l            0            ]
         [                                                          ]
         [                                    2    2                ]
         [     0          0          0       r  sin (theta) + h44 l ]
(%i9) cmetric(false);
(%o9)                                done
(%i10) einstein(false);
(%o10)                               done
(%i11) ntermst(ein);
[[1, 1], 62] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 24] 
[[2, 3], 0] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 0] 
[[3, 3], 46] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 46] 
(%o12)                               done

@end example

Sin embargo, si se recalcula este ejemplo como una aproximación lineal en la variable @code{l}, se obtienen expresiones más sencillas:

@example

(%i14) ctayswitch:true;
(%o14)                               true
(%i15) ctayvar:l;
(%o15)                                 l
(%i16) ctaypov:1;
(%o16)                                 1
(%i17) ctaypt:0;
(%o17)                                 0
(%i18) christof(false);
(%o18)                               done
(%i19) ricci(false);
(%o19)                               done
(%i20) einstein(false);
(%o20)                               done
(%i21) ntermst(ein);
[[1, 1], 6] 
[[1, 2], 0] 
[[1, 3], 0] 
[[1, 4], 0] 
[[2, 1], 0] 
[[2, 2], 13] 
[[2, 3], 2] 
[[2, 4], 0] 
[[3, 1], 0] 
[[3, 2], 2] 
[[3, 3], 9] 
[[3, 4], 0] 
[[4, 1], 0] 
[[4, 2], 0] 
[[4, 3], 0] 
[[4, 4], 9] 
(%o21)                               done
(%i22) ratsimp(ein[1,1]);
                         2      2  4               2     2
(%o22) - (((h11 h22 - h11 ) (l )  r  - 2 h33 l    r ) sin (theta)
                              r               r r

                                2               2      4    2
                  - 2 h44 l    r  - h33 h44 (l ) )/(4 r  sin (theta))
                           r r                r



@end example

Esta capacidad del paquete @code{ctensor} puede ser muy útil; por ejemplo, cuando se trabaja en zonas del campo gravitatorio alejadas del origen de éste.

@end deffn

@subsection Campos del sistema de referencia

Cuando la variable @code{cframe_flag} vale @code{true}, el paquete @code{ctensor} realiza sus cálculos utilizando un sistema de referencia móvil.

@deffn {Función} frame_bracket (@var{fr}, @var{fri}, @var{diagframe})
Es el sistema de referencia soporte (@code{fb[]}).

Calcula el soporte del sistema de referencia de acuerdo con la siguiente definición:

@example
   c          c         c        d     e
ifb   = ( ifri    - ifri    ) ifr   ifr
   ab         d,e       e,d      a     b
@end example

@end deffn

@subsection Clasificación algebraica

Una nueva funcionalidad (Noviembre de 2004) de @code{ctensor} es su capacidad de obtener la clasificación de Petrov de una métrica espaciotemporal de dimensión 4. Para una demostración de esto véase el fichero 
@code{share/tensor/petrov.dem}.

@deffn {Función} nptetrad ()
Calcula la cuaterna nula de Newman-Penrose (@code{np}). Véase @code{petrov} para un ejemplo.

La cuaterna nula se construye bajo la suposición de que se está utilizando una métrica tetradimensional ortonormal con signatura métrica (-,+,+,+). Los componentes de la cuaterna nula se relacionan con la inversa de la matriz del sistema de referencia de la siguiente manera:

@example

np  = (fri  + fri ) / sqrt(2)
  1       1      2

np  = (fri  - fri ) / sqrt(2)
  2       1      2

np  = (fri  + %i fri ) / sqrt(2)
  3       3         4

np  = (fri  - %i fri ) / sqrt(2)
  4       3         4

@end example

@end deffn

@deffn {Función} psi (@var{dis})
Calcula los cinco coeficientes de Newman-Penrose @code{psi[0]}...@code{psi[4]}.
Si @code{dis} vale @code{true}, se muestran estos coeficientes. 
Véase @code{petrov} para un ejemplo.

@c AQUI HAY UN PARRAFO COMPLETO POR TRADUCIR (Mario)
Estos coeficientes se calculan a partir del tensor de Weyl.

@end deffn

@deffn {Función} petrov ()
Calcula la clasificación de  Petrov de la métrica caracterizada por @code{psi[0]}...@code{psi[4]}.

Por ejemplo, lo que sigue demuestra cómo obtener la clasificación de Petrov para la métrica de Kerr:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) (cframe_flag:true,gcd:spmod,ctrgsimp:true,ratfac:true);
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) ug:invert(lg)$
(%i5) weyl(false);
(%o5)                                done
(%i6) nptetrad(true);
(%t6) np = 

       [  sqrt(r - 2 m)           sqrt(r)                                     ]
       [ ---------------   ---------------------      0             0         ]
       [ sqrt(2) sqrt(r)   sqrt(2) sqrt(r - 2 m)                              ]
       [                                                                      ]
       [  sqrt(r - 2 m)            sqrt(r)                                    ]
       [ ---------------  - ---------------------     0             0         ]
       [ sqrt(2) sqrt(r)    sqrt(2) sqrt(r - 2 m)                             ]
       [                                                                      ]
       [                                              r      %i r sin(theta)  ]
       [        0                    0             -------   ---------------  ]
       [                                           sqrt(2)       sqrt(2)      ]
       [                                                                      ]
       [                                              r       %i r sin(theta) ]
       [        0                    0             -------  - --------------- ]
       [                                           sqrt(2)        sqrt(2)     ]

                             sqrt(r)          sqrt(r - 2 m)
(%t7) npi = matrix([- ---------------------, ---------------, 0, 0], 
                      sqrt(2) sqrt(r - 2 m)  sqrt(2) sqrt(r)

          sqrt(r)            sqrt(r - 2 m)
[- ---------------------, - ---------------, 0, 0], 
   sqrt(2) sqrt(r - 2 m)    sqrt(2) sqrt(r)

           1               %i
[0, 0, ---------, --------------------], 
       sqrt(2) r  sqrt(2) r sin(theta)

           1                 %i
[0, 0, ---------, - --------------------])
       sqrt(2) r    sqrt(2) r sin(theta)

(%o7)                                done
(%i7) psi(true);
(%t8)                              psi  = 0
                                      0

(%t9)                              psi  = 0
                                      1

                                          m
(%t10)                             psi  = --
                                      2    3
                                          r

(%t11)                             psi  = 0
                                      3

(%t12)                             psi  = 0
                                      4
(%o12)                               done
(%i12) petrov();
(%o12)                                 D

@end example

La función de clasificación de Petrov se basa en el algoritmo publicado en "Classifying geometries in general relativity: III Classification in practice" de Pollney, Skea, and d'Inverno, Class. Quant. Grav. 17 2885-2902 (2000).
Excepto para algunos ejemplos sencillos, esta implementación no ha sido exhaustivamente probada, por lo que puede contener errores.

@end deffn

@subsection Torsión y no metricidad

El paquete @code{ctensor} es capaz de calcular e incluir coeficientes de torsión y no metricidad en los coeficientes de conexión.

Los coeficientes de torsión se calculan a partir de un tensor suministrado por el usuario, @code{tr}, el cual debe ser de rango (2,1). A partir de ahí, los coeficientes de torsión @code{kt} se calculan de acuerdo con las siguientes fórmulas:

@example

              m          m      m
       - g  tr   - g   tr   - tr   g
          im  kj    jm   ki     ij  km
kt   = -------------------------------
  ijk                 2


  k     km
kt   = g   kt
  ij         ijm

@end example

@c AQUI FALTA UN PARRAFO

Los coeficientes de no metricidad se calculan a partir de un vector de no metricidad, @code{nm}, suministrado por el usuario. A partir de ahí, los coeficientes de no metricidad, @code{nmc}, se calculan como se indica a continuación:

@example

             k    k        km
       -nm  D  - D  nm  + g   nm  g
   k      i  j    i   j         m  ij
nmc  = ------------------------------
   ij                2

@end example

donde D es la delta de Kronecker.

@c AQUI FALTAN DOS PARRAFOS

@deffn {Función} contortion (@var{tr})

Calcula los coeficientes (2,1) de contorsión del tensor de torsión @var{tr}.

@end deffn

@deffn {Función} nonmetricity (@var{nm})

Calcula los coeficientes (2,1) de no metricidad del vector de no metricidad @var{nm}.

@end deffn

@subsection Otras funcionalidades

@deffn {Función} ctransform (@var{M})
Es una función del paquete @code{ctensor}.  Realiza una transformación de coordenadas a partir de una matriz cuadrada simétrica @var{M} arbitraria. El usuario debe introducir las funciones que definen la transformación.

@end deffn

@deffn {Función} findde (@var{A}, @var{n})

Devuelve la lista de las ecuaciones diferenciales que corresponden a los elementos del arreglo cuadrado @var{n}-dimensional. El argumento @var{n} puede ser 2 ó 3; @code{deindex} es una lista global que contiene los índices de @var{A} que corresponden a estas ecuaciones diferenciales. Para el tensor de Einstein (@code{ein}), que es un arreglo bidimensional, si se calcula para la métrica del ejemplo de más abajo, @code{findde} devuelve las siguientes ecuaciones diferenciales independientes:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) dim:4;
(%o3)                                  4
(%i4) lg:matrix([a,0,0,0],[0,x^2,0,0],[0,0,x^2*sin(y)^2,0],[0,0,0,-d]);
                          [ a  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  x       0        0  ]
(%o4)                     [                        ]
                          [         2    2         ]
                          [ 0  0   x  sin (y)   0  ]
                          [                        ]
                          [ 0  0       0       - d ]
(%i5) depends([a,d],x);
(%o5)                            [a(x), d(x)]
(%i6) ct_coords:[x,y,z,t];
(%o6)                            [x, y, z, t]
(%i7) cmetric();
(%o7)                                done
(%i8) einstein(false);
(%o8)                                done
(%i9) findde(ein,2);
                                            2
(%o9) [d  x - a d + d, 2 a d d    x - a (d )  x - a  d d  x + 2 a d d
        x                     x x         x        x    x            x

                                                        2          2
                                                - 2 a  d , a  x + a  - a]
                                                     x      x
(%i10) deindex;
(%o10)                     [[1, 1], [2, 2], [4, 4]]

@end example

@end deffn

@deffn {Función} cograd ()
Calcula el gradiente covariante de una función escalar permitiendo al usuario
elegir el nombre del vector correspondiente, tal como ilustra el ejemplo que acompaña
a la definición de la función @code{contragrad}.
@end deffn


@deffn {Function} contragrad ()

Calcula el gradiente contravariante de una función escalar permitiendo al usuario elegir el nombre del vector correspondiente, tal como muestra el siguiente ejemplo para la métrica de Schwarzschild:

@example

(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(f,r);
(%o4)                               [f(r)]
(%i5) cograd(f,g1);
(%o5)                                done
(%i6) listarray(g1);
(%o6)                            [0, f , 0, 0]
                                      r
(%i7) contragrad(f,g2);
(%o7)                                done
(%i8) listarray(g2);
                               f  r - 2 f  m
                                r        r
(%o8)                      [0, -------------, 0, 0]
                                     r

@end example

@end deffn

@deffn {Función} dscalar ()
Calcula el tensor de d'Alembertian de la función escalar una vez se han declarado las dependencias. Por ejemplo:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) derivabbrev:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) depends(p,r);
(%o4)                               [p(r)]
(%i5) factor(dscalar(p));
                          2
                    p    r  - 2 m p    r + 2 p  r - 2 m p
                     r r           r r        r          r
(%o5)               --------------------------------------
                                       2
                                      r
@end example

@end deffn

@deffn {Función} checkdiv ()

Calcula la divergencia covariante del tensor de segundo rango (mixed second rank tensor), cuyo primer índice debe ser covariante, devolviendo las @code{n} componentes correspondientes del campo vectorial (la divergencia), siendo @code{n = dim}. @c FALTA POR COMPLETAR ESTE PARRAFO.
@end deffn

@deffn {Función} cgeodesic (@var{dis})
Es una función del paquete @code{ctensor} que calcula las ecuaciones geodésicas del movimiento para una métrica dada, las cuales se almacenan en el arreglo @code{geod[i]}. Si el argumento  @var{dis} vale @code{true} entonces se muestran estas ecuaciones.

@end deffn

@deffn {Función} bdvac (@var{f})

Genera las componentes covariantes de las ecuaciones del campo vacío de la teoría gravitacional de Brans- Dicke gravitational. El campo escalar se especifica con el argumento  @var{f}, el cual debe ser el nombre de una función no evaluada (precedida de apóstrofo) con dependencias funcionales, por ejemplo,  @code{'p(x)}.

Las componentes del tensor covariante (second rank covariant field tensor) se almacenan en el arreglo @code{bd}.

@end deffn

@deffn {Función} invariant1 ()

Genera el tensor de Euler-Lagrange (ecuaciones de campo) para la densidad invariante de  R^2. Las ecuaciones de campo son las componentes del arreglo @code{inv1}.

@end deffn

@subsection Utilidades

@deffn {Función} diagmatrixp (@var{M})

Devuelve @code{true} si @var{M} es una matriz diagonal o un arreglo bidimensional.

@end deffn

@deffn {Función} symmetricp (@var{M})

Devuelve @code{true} si @var{M} es una matriz simétrica o un arreglo bidimensional.

@end deffn

@deffn {Función} ntermst (@var{f})
Permite hacerse una idea del tamaño del tensor @var{f}. @c FALTA COMPLETAR PARRAFO

@end deffn


@deffn {Función} cdisplay (@var{ten})
Muestra todos los elementos del tensor @var{ten} como arreglo multidimensional. Tensors de rango 0 y 1, así como otros tipos de variables, se muestran como en @code{ldisplay}. Tensors de rango 2 se muestran como matrices bidimensionales, mientras que tensores de mayor rango se muestran como listas de matrices bidimensionales. Por ejemplo, el tensor de Riemann de la métrica de Schwarzschild se puede ver como:

@example
(%i1) load(ctensor);
(%o1)       /share/tensor/ctensor.mac
(%i2) ratfac:true;
(%o2)                                true
(%i3) ct_coordsys(exteriorschwarzschild,all);
(%o3)                                done
(%i4) riemann(false);
(%o4)                                done
(%i5) cdisplay(riem);
               [ 0               0                    0            0      ]
               [                                                          ]
               [                              2                           ]
               [      3 m (r - 2 m)   m    2 m                            ]
               [ 0  - ------------- + -- - ----       0            0      ]
               [            4          3     4                            ]
               [           r          r     r                             ]
               [                                                          ]
    riem     = [                                 m (r - 2 m)              ]
        1, 1   [ 0               0               -----------       0      ]
               [                                      4                   ]
               [                                     r                    ]
               [                                                          ]
               [                                              m (r - 2 m) ]
               [ 0               0                    0       ----------- ]
               [                                                   4      ]
               [                                                  r       ]

                                [    2 m (r - 2 m)       ]
                                [ 0  -------------  0  0 ]
                                [          4             ]
                                [         r              ]
                     riem     = [                        ]
                         1, 2   [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]

                                [         m (r - 2 m)    ]
                                [ 0  0  - -----------  0 ]
                                [              4         ]
                                [             r          ]
                     riem     = [                        ]
                         1, 3   [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]
                                [                        ]
                                [ 0  0        0        0 ]

                                [            m (r - 2 m) ]
                                [ 0  0  0  - ----------- ]
                                [                 4      ]
                                [                r       ]
                     riem     = [                        ]
                         1, 4   [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]
                                [                        ]
                                [ 0  0  0        0       ]

                               [       0         0  0  0 ]
                               [                         ]
                               [       2 m               ]
                               [ - ------------  0  0  0 ]
                    riem     = [    2                    ]
                        2, 1   [   r  (r - 2 m)          ]
                               [                         ]
                               [       0         0  0  0 ]
                               [                         ]
                               [       0         0  0  0 ]

                   [     2 m                                         ]
                   [ ------------  0        0               0        ]
                   [  2                                              ]
                   [ r  (r - 2 m)                                    ]
                   [                                                 ]
                   [      0        0        0               0        ]
                   [                                                 ]
        riem     = [                         m                       ]
            2, 2   [      0        0  - ------------        0        ]
                   [                     2                           ]
                   [                    r  (r - 2 m)                 ]
                   [                                                 ]
                   [                                         m       ]
                   [      0        0        0         - ------------ ]
                   [                                     2           ]
                   [                                    r  (r - 2 m) ]

                                [ 0  0       0        0 ]
                                [                       ]
                                [            m          ]
                                [ 0  0  ------------  0 ]
                     riem     = [        2              ]
                         2, 3   [       r  (r - 2 m)    ]
                                [                       ]
                                [ 0  0       0        0 ]
                                [                       ]
                                [ 0  0       0        0 ]

                                [ 0  0  0       0       ]
                                [                       ]
                                [               m       ]
                                [ 0  0  0  ------------ ]
                     riem     = [           2           ]
                         2, 4   [          r  (r - 2 m) ]
                                [                       ]
                                [ 0  0  0       0       ]
                                [                       ]
                                [ 0  0  0       0       ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [ m          ]
                               3, 1   [ -  0  0  0 ]
                                      [ r          ]
                                      [            ]
                                      [ 0  0  0  0 ]

                                      [ 0  0  0  0 ]
                                      [            ]
                                      [ 0  0  0  0 ]
                                      [            ]
                           riem     = [    m       ]
                               3, 2   [ 0  -  0  0 ]
                                      [    r       ]
                                      [            ]
                                      [ 0  0  0  0 ]

                               [   m                      ]
                               [ - -   0   0       0      ]
                               [   r                      ]
                               [                          ]
                               [        m                 ]
                               [  0   - -  0       0      ]
                    riem     = [        r                 ]
                        3, 3   [                          ]
                               [  0    0   0       0      ]
                               [                          ]
                               [              2 m - r     ]
                               [  0    0   0  ------- + 1 ]
                               [                 r        ]

                                    [ 0  0  0    0   ]
                                    [                ]
                                    [ 0  0  0    0   ]
                                    [                ]
                         riem     = [            2 m ]
                             3, 4   [ 0  0  0  - --- ]
                                    [             r  ]
                                    [                ]
                                    [ 0  0  0    0   ]

                                [       0        0  0  0 ]
                                [                        ]
                                [       0        0  0  0 ]
                                [                        ]
                     riem     = [       0        0  0  0 ]
                         4, 1   [                        ]
                                [      2                 ]
                                [ m sin (theta)          ]
                                [ -------------  0  0  0 ]
                                [       r                ]

                                [ 0        0        0  0 ]
                                [                        ]
                                [ 0        0        0  0 ]
                                [                        ]
                     riem     = [ 0        0        0  0 ]
                         4, 2   [                        ]
                                [         2              ]
                                [    m sin (theta)       ]
                                [ 0  -------------  0  0 ]
                                [          r             ]

                              [ 0  0          0          0 ]
                              [                            ]
                              [ 0  0          0          0 ]
                              [                            ]
                   riem     = [ 0  0          0          0 ]
                       4, 3   [                            ]
                              [                2           ]
                              [         2 m sin (theta)    ]
                              [ 0  0  - ---------------  0 ]
                              [                r           ]

                 [        2                                             ]
                 [   m sin (theta)                                      ]
                 [ - -------------         0                0         0 ]
                 [         r                                            ]
                 [                                                      ]
                 [                         2                            ]
                 [                    m sin (theta)                     ]
      riem     = [        0         - -------------         0         0 ]
          4, 4   [                          r                           ]
                 [                                                      ]
                 [                                          2           ]
                 [                                   2 m sin (theta)    ]
                 [        0                0         ---------------  0 ]
                 [                                          r           ]
                 [                                                      ]
                 [        0                0                0         0 ]

(%o5)                                done

@end example
@end deffn

@deffn {Función} deleten (@var{L}, @var{n})
Devuelve una nueva lista consistente en @var{L} sin su @var{n}-ésimo elemento.
@end deffn

@subsection Variables utilizadas por @code{ctensor}

@defvr {Variable opcional} dim
Valor por defecto: 4

Es la dimensión de la variedad, que por defecto será 4. La instrucción @code{dim: n} establecerá la dimensión a cualquier otro valor @code{n}.

@end defvr

@defvr {Variable opcional} diagmetric
Valor por defecto: @code{false}

Si @code{diagmetric} vale @code{true} se utilizarán rutinas especiales para calcular todos los objetos geométricos teniendo en cuenta la diagonalidad de la métrica, lo que redundará en una reducción del tiempo de cálculo. Esta opción se fija automáticamente por @code{csetup} si se especifica una métrica diagonal.

@end defvr

@defvr {Variable opcional} ctrgsimp

Provoca que se realicen simplificaciones trigonométricas cuando se calculan tensores. La variable @code{ctrgsimp} afecta únicamente a aquellos cálculos que utilicen un sistema de referencia móvil.

@end defvr

@defvr {Variable opcional} cframe_flag

Provoca que los cálculos se realicen respecto de un sistema de referencia móvil. @c FALTA POR COMPLETAR EL PARRAFO

@end defvr

@defvr {Variable opcional} ctorsion_flag

Obliga a que se calcule también el tensor de contorsión junto con los coeficientes de conexión. El propio tensor de contorsión se calcula con la función @code{contortion} a partir del tensor @code{tr} suministrado por el usuario.

@end defvr

@defvr {Variable opcional} cnonmet_flag

Obliga a que se calculen también los coeficientes de no metricidad junto con los coeficientes de conexión. Los coeficientes de no metricidad se calculan con la función @code{nonmetricity} a partir del vector de no metricidad@code{nm} suministrado por el usuario.

@end defvr

@defvr {Variable opcional} ctayswitch

Si vale @code{true}, obliga a que ciertos cálculos de @code{ctensor} se lleven a cabo utilizando desarrollos de series de 
Taylor. Estos cálculos hacen referencia a las funciones @code{christof}, @code{ricci}, @code{uricci}, @code{einstein} y @code{weyl}.

@end defvr

@defvr {Variable opcional} ctayvar

Variable utilizada para desarrollos de Taylor cuando la variable @code{ctayswitch} vale @code{true}.

@end defvr

@defvr {Variable opcional} ctaypov

Máximo exponente utilizado en los desarrollos de Taylor cuando @code{ctayswitch} vale @code{true}.

@end defvr

@defvr {Variable opcional} ctaypt

Punto alrededor del cual se realiza un desarrollo de Taylor cuando @code{ctayswitch} vale @code{true}.

@end defvr

@defvr {Variable opcional} gdet

Es el determinante del tensor métrico @code{lg}, calculado por  @code{cmetric} cuando @code{cframe_flag} vale @code{false}.

@end defvr

@defvr {Variable opcional} ratchristof

Obliga a que la función @code{christof} aplique la simplificación racional.

@end defvr

@defvr {Variable opcional} rateinstein
Valor por defecto: @code{true}

Si vale @code{true} entonces se hará la simplificación racional en los componentes no nulos de los tensores de Einstein; si @code{ratfac} vale @code{true} entonces las componentes también serán factorizadas.

@end defvr

@defvr {Variable opcional} ratriemann
Valor por defecto: @code{true}

Es una de las variables que controlan la simplificación de los tensores de Riemann; si vale @code{true}, entonces se llevará a cabo la simplificación racional; si @code{ratfac} vale @code{true} entonces las componentes también serán factorizadas.

@end defvr

@defvr {Variable opcional} ratweyl
Valor por defecto: @code{true}

Si vale @code{true}, entonces la función @code{weyl} llevará a cabo la simplificación racional de los valores del tensor de Weyl. si @code{ratfac} vale @code{true} entonces las componentes también serán factorizadas.
@end defvr

@defvr {Variable} lfg
Es la covariante de la métrica del sistema de referencia. Por defecto, está inicializada al sistema de referencia tetradimensional de Lorentz con signatura  (+,+,+,-). Se utiliza cuando @code{cframe_flag} vale @code{true}.
@end defvr

@defvr {Variable} ufg
Es la métrica del sistema de referencia inverso. La calcula @code{lfg} cuando @code{cmetric} es invocada tomando  @code{cframe_flag} el valor  @code{true}.
@end defvr

@defvr {Variable} riem
Es el tensor (3,1) de Riemann. Se calcula cuando se invoca la función @code{riemann}. Para información sobre el indexado, véase la descripción de  @code{riemann}.

Si @code{cframe_flag} vale @code{true}, @code{riem} se calcula a partir del tensor covariante de Riemann @code{lriem}.

@end defvr

@defvr {Variable} lriem

Es el tensor covariante de Riemann. Lo calcula la función @code{lriemann}.

@end defvr

@defvr {Variable} uriem

Es el tensor contravariante de Riemann. Lo calcula la función @code{uriemann}.

@end defvr

@defvr {Variable} ric

Es el tensor de Ricci. Lo calcula la función @code{ricci}.

@end defvr

@defvr {Variable} uric

Es el tensor contravariante de Ricci. Lo calcula la función @code{uricci}.

@end defvr

@defvr {Variable} lg

Es el tensor métrico. Este tensor se debe especificar (como matriz cuadrada de orden @code{dim}) antes de que se hagan otros cálculos.

@end defvr

@defvr {Variable} ug

Es la inversa del tensor métrico. Lo calcula la función @code{cmetric}.

@end defvr

@defvr {Variable} weyl

Es el tensor de Weyl. Lo calcula la función @code{weyl}.

@end defvr

@defvr {Variable} fb

Son los coeficientes del sistema de referencia soporte, tal como los calcula @code{frame_bracket}.

@end defvr

@defvr {Variable} kinvariant

Es la invariante de Kretchmann, tal como la calcula la función @code{rinvariant}.

@end defvr

@defvr {Variable} np

Es la cuaterna nula de Newman-Penrose, tal como la calcula la función @code{nptetrad}.

@end defvr

@defvr {Variable} npi

Es la cuaterna nula "raised-index Newman-Penrose". Lo calcula la función @code{nptetrad}.
Se define como @code{ug.np}. El producto @code{np.transpose(npi)} es constante:

@example
(%i39) trigsimp(np.transpose(npi));
                              [  0   - 1  0  0 ]
                              [                ]
                              [ - 1   0   0  0 ]
(%o39)                        [                ]
                              [  0    0   0  1 ]
                              [                ]
                              [  0    0   1  0 ]
@end example

@end defvr

@defvr {Variable} tr

Tensor de rango 3 suministrado por el usuario y que representa una torsión. Lo utiliza la función @code{contortion}.
@end defvr

@defvr {Variable} kt

Es el tensor de contorsión, calculado a partir de @code{tr} por la función @code{contortion}.
@end defvr

@defvr {Variable} nm

Vector de no metricidad suministrado por el usuario. Lo utiliza la función @code{nonmetricity}.
@end defvr

@defvr {Variable} nmc

Son los coeficientes de no metricidad, calculados a partir de @code{nm} por la función @code{nonmetricity}.

@end defvr

@defvr {Variable del sistema} tensorkill

Variable que indica si el paquete de tensores se ha inicializado. Utilizada por @code{csetup} y reinicializada por @code{init_ctensor}.

@end defvr

@defvr {Variable opcional} ct_coords
Valor por defecto: @code{[]}

La variable @code{ct_coords} contiene una lista de coordenadas. Aunque se define normalmente cuando se llama a la función @code{csetup}, también se pueden redefinir las coordenadas con la asignación @code{ct_coords: [j1, j2, ..., jn]} donde  @code{j} es el nuevo nombre de las coordenadas. Véase también @code{csetup}.

@end defvr

@subsection Nombres reservados

Los siguientes nombres se utilizan internamente en el paquete @code{ctensor} y no deberían redefinirse:

@example
  Nombre       Descripción
  ---------------------------------------
  _lg()        Toma el valor @code{lfg} si se utiliza métrica del sistema de referencia,
               @code{lg} en otro caso
  _ug()        Toma el valor @code{ufg} si se utiliza métrica del sistema de referencia,
               @code{ug} en otro caso
  cleanup()    Elimina elementos de la lista @code{deindex}
  contract4()  Utilizada por @code{psi()}
  filemet()    Utilizada por @code{csetup()} cuando se lee la métrica desde un fichero
  findde1()    Utilizada por @code{findde()}
  findde2()    Utilizada por @code{findde()}
  findde3()    Utilizada por @code{findde()}
  kdelt()      Delta de Kronecker (no generalizada)
  newmet()     Utilizada por @code{csetup()} para establecer una métrica interactivamente
  setflags()   Utilizada por @code{init_ctensor()}
  readvalue()
  resimp()
  sermet()     Utilizada por @code{csetup()} para definir una métrica como serie de Taylor
  txyzsum()
  tmetric()    Métrica del sistema de referencia, utilizada por @code{cmetric()}
               cuando @code{cframe_flag:true}
  triemann()   Tensor de Riemann en la base del sistema de referencia, se utiliza cuando
               @code{cframe_flag:true}
  tricci()     Tensor de Ricci en la base del sistema de referencia, se utiliza cuando
               @code{cframe_flag:true}
  trrc()       Coeficientes de rotación de Ricci, utilizada por @code{christof()}
  yesp()
@end example


