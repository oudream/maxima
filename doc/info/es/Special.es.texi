@c English version 2013-07-30
@menu
* Introducción a las funciones especiales::
* Funciones de Bessel::
* Funciones de Airy::
* Funciones Gamma y factorial::
* Integral exponencial::
* Función de error::
* Funciones de Struve::
* Funciones hipergeométricas::
* Funciones de cilindro parabólico::
* Funciones y variables para las funciones especiales::
@end menu

@node Introducción a las funciones especiales, Funciones de Bessel, Funciones Especiales, Funciones Especiales
@section Introducción a las funciones especiales

A continuación se especifican las notaciones correspondientes a las funciones especiales:

@example
bessel_j (index, expr)    Función de Bessel de primera especie
bessel_y (index, expr)    Función de Bessel de segunda especie
bessel_i (index, expr)    Función de Bessel modificada de primera especie
bessel_k (index, expr)    Función de Bessel modificada de segunda especie
hankel_1 (v,z)            Función de Hankel de primera especie
hankel_2 (v,z)            Función de Hankel de segunda especie
struve_h (v,z)            Función H de Struve
struve_l (v,z)            Función L de Struve
%p[u,v] (z)               Función de Legendre de primera especie
%q[u,v] (z)               Función de Legendre de segunda especie
%f[p,q] ([], [], expr)    Función hipergeométrica generalizada
gamma(z)                  Función Gamma
gamma_incomplete_lower(a,z) Función Gamma incompleta inferior
gamma_incomplete (a,z)    Extremo de la función Gamma incompleta
hypergeometric(l1, l2, z) Función hipergeométrica
@c IS slommel THE "LOMMEL" FUNCTION ?? NOT OTHERWISE MENTIONED IN TEXINFO FILES
slommel
%m[u,k] (z)               Función de Whittaker de primera especie
%w[u,k] (z)               Función de Whittaker de segunda especie
erfc (z)                  Complemento de la función de error, erf
expintegral_e (v,z)       Integral exponencial E
expintegral_e1 (z)        Integral exponencial E1
expintegral_ei (z)        Integral exponencial Ei
expintegral_li (z)        Integral logarítmica Li
expintegral_si (z)        Integral exponencial Si
expintegral_ci (z)        Integral exponencial Ci
expintegral_shi (z)       Integral exponencial Shi
expintegral_chi (z)       Integral exponencial Chi
kelliptic (z)             Integral elíptica completa
                                  de primera especie (K)
parabolic_cylinder_d(v,z) Función D de cilindro parabólico
@end example





@node Funciones de Bessel, Funciones de Airy, Introducción a las funciones especiales, Funciones Especiales
@section Funciones de Bessel


@deffn {Función} bessel_j (@var{v}, @var{z})
Función de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La función @code{bessel_j} se define como

@ifnottex
@example
                inf
                ====       k  - v - 2 k  v + 2 k
                \     (- 1)  2          z
                 >    --------------------------
                /        k! gamma(v + k + 1)
                ====
                k = 0
@end example
@end ifnottex

@tex
$$\sum_{k=0}^{\infty }{{{\left(-1\right)^{k}\,\left(z\over 2\right)^{v+2\,k}
 }\over{k!\,\Gamma\left(v+k+1\right)}}}$$
@end tex

aunque la serie infinita no se utiliza en los cálculos.

@end deffn

@deffn {Función} bessel_y (@var{v}, @var{z})
Función de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La función @code{bessel_y} se define como

@ifnottex
@example
              cos(%pi v) bessel_j(v, z) - bessel_j(-v, z)
              -------------------------------------------
                             sin(%pi v)
@end example
@end ifnottex

@tex
$${{\cos \left(\pi\,v\right)\,J_{v}(z)-J_{-v}(z)}\over{
 \sin \left(\pi\,v\right)}}$$
@end tex

si @math{v} no es un entero.  En caso de que  @math{v} sea un entero @math{n}, se calcula el límite cuando @math{v} se aproxima a @math{n}.

@end deffn


@deffn {Función} bessel_i (@var{v}, @var{z})
Función modificada de Bessel de primera especie de orden @math{v} y argumento @math{z}.

La función @code{bessel_i} se define como

@ifnottex
@example
                    inf
                    ====   - v - 2 k  v + 2 k
                    \     2          z
                     >    -------------------
                    /     k! gamma(v + k + 1)
                    ====
                    k = 0
@end example
@end ifnottex

@tex
$$\sum_{k=0}^{\infty } {{1\over{k!\,\Gamma
 \left(v+k+1\right)}} {\left(z\over 2\right)^{v+2\,k}}}$$
@end tex

aunque la serie infinita no se utiliza en los cálculos.

@end deffn


@deffn {Función} bessel_k (@var{v}, @var{z})
Función modificada de Bessel de segunda especie de orden @math{v} y argumento @math{z}.

La función @code{bessel_k} se define como

@ifnottex
@example
           %pi csc(%pi v) (bessel_i(-v, z) - bessel_i(v, z))
           -------------------------------------------------
                                  2
@end example
@end ifnottex

@tex
$${{\pi\,\csc \left(\pi\,v\right)\,\left(I_{-v}(z)-I_{v}(z)\right)}\over{2}}$$
@end tex

si @math{v} no es un entero.  Si @math{v} es igual al entero @math{n}, entonces se calcula el límite cuando @math{v} tiende a @math{n}.
@end deffn


@deffn {Función} hankel_1 (@var{v}, @var{z})
Función de Hankel de primera especie de orden @math{v} y argumento @math{z}
(A&S 9.1.3). La función @code{hankel_1} se define como

@example
   bessel_j(v,z) + %i * bessel_y(v,z)
@end example

Maxima evalúa @code{hankel_1} numéricamente para el orden real @math{v}
y el argumento complejo @math{z} en doble precisión (float). La evaluación
numérica en gran precisión (bigfloat) y para órdenes complejos no está
implementada.

Si @code{besselexpand} vale @code{true}, @code{hankel_1} se expande en 
términos de funciones elementales cuando el orden @math{v} es la mitad
de un entero impar. Véase al respecto @code{besselexpand}.

Maxima reconoce la derivada de @code{hankel_1} con respecto del argumento @math{z}.

Ejemplos:

Evaluación numérica:

@c ===beg===
@c hankel_1(1,0.5);
@c hankel_1(1,0.5+%i);
@c ===end===
@example
(%i1) hankel_1(1,0.5);
(%o1)              .2422684576748738 - 1.471472392670243 %i
(%i2) hankel_1(1,0.5+%i);
(%o2)             - .2558287994862166 %i - 0.239575601883016
@end example

No se soportan órdenes complejos. Maxima devuelve una forma nominal:

@c ===beg===
@c hankel_1(%i,0.5+%i);
@c ===end===
@example
(%i3) hankel_1(%i,0.5+%i);
(%o3)                       hankel_1(%i, %i + 0.5)
@end example

Expansión de @code{hankel_1} cuando @code{besselexpand} vale @code{true}:

@c ===beg===
@c hankel_1(1/2,z),besselexpand:true;
@c ===end===
@example
(%i4) hankel_1(1/2,z),besselexpand:true;
                      sqrt(2) sin(z) - sqrt(2) %i cos(z)
(%o4)                 ----------------------------------
                              sqrt(%pi) sqrt(z)
@end example

Derivada de @code{hankel_1} respecto del argumento @math{z}. No está
soportada la derivada respecto del orden @math{v}. Maxima devuelve una forma nominal:

@c ===beg===
@c diff(hankel_1(v,z),z);
@c diff(hankel_1(v,z),v);
@c ===end===
@example
(%i5) diff(hankel_1(v,z),z);
                    hankel_1(v - 1, z) - hankel_1(v + 1, z)
(%o5)               ---------------------------------------
                                       2
(%i6) diff(hankel_1(v,z),v);
                             d
(%o6)                        -- (hankel_1(v, z))
                             dv
@end example

@end deffn

@deffn {Función} hankel_2 (@var{v}, @var{z})
Función de Hankel de segunda especie de orden @math{v} y argumento @math{z}
(A&S 9.1.4). La función @code{hankel_2} se define como

@example
   bessel_j(v,z) - %i * bessel_y(v,z)
@end example

Maxima evalúa @code{hankel_2} numéricamente para el orden real @math{v}
y el argumento complejo @math{z} en doble precisión (float). La evaluación
numérica en gran precisión (bigfloat) y para órdenes complejos no está
implementada.

Si @code{besselexpand} vale @code{true}, @code{hankel_2} se expande en 
términos de funciones elementales cuando el orden @math{v} es la mitad
de un entero impar. Véase al respecto @code{besselexpand}.

Maxima reconoce la derivada de @code{hankel_2} con respecto del argumento @math{z}.

Véanse ejemplos en @code{hankel_1}.

@end deffn

@defvr {Variable optativa} besselexpand
Valor por defecto: @code{false}

Controla la expansión de las funciones de Bessel cuando el orden es la mitad de un entero impar. En tal caso, las funciones de Bessel se pueden expandir en términos de otras funciones elementales.  Si @code{besselexpand} vale @code{true}, se expande la función de Bessel.

@example
(%i1) besselexpand: false$
(%i2) bessel_j (3/2, z);
                                    3
(%o2)                      bessel_j(-, z)
                                    2
(%i3) besselexpand: true$
(%i4) bessel_j (3/2, z);
                                        sin(z)   cos(z)
                       sqrt(2) sqrt(z) (------ - ------)
                                           2       z
                                          z
(%o4)                  ---------------------------------
                                   sqrt(%pi)
@end example

@end defvr


@deffn {Función} scaled_bessel_i (@var{v}, @var{z})

Es la función de Bessel modificada de primera especie de
orden @math{v} y argumento @math{z}, es decir
@math{scaled_bessel_i(v,z) = exp(-abs(z))*bessel_i(v, z)}.
Esta función es especialmente útil para calcular @math{bessel_i}
cuando @math{z} es grande. Sin embargo, Maxima no sabe mucho más 
sobre esta función. En cálculos simbólicos, quizás sea
preferible trabajar directamente con la expresión 
@code{exp(-abs(z))*bessel_i(v, z)}.

@end deffn


@deffn {Función} scaled_bessel_i0 (@var{z})

Idéntica a @code{scaled_bessel_i(0,z)}.

@end deffn

@deffn {Función} scaled_bessel_i1 (@var{z})

Idéntica a @code{scaled_bessel_i(1,z)}.

@end deffn


@deffn {Función} %s [@var{u},@var{v}] (@var{z}) 

Función s[u,v](z) de Lommel.
Gradshteyn & Ryzhik 8.570.1.

@end deffn





@node Funciones de Airy, Funciones Gamma y factorial, Funciones de Bessel, Funciones Especiales
@section Funciones de Airy

Las funciones de Airy Ai(x) y Bi(x) se definen en la sección 10.4.
de Abramowitz and Stegun, @i{Handbook of Mathematical Functions}.

@code{y = Ai(x)} y @code{y = Bi(x)} son dos soluciones linealmente
independientes de la ecuación diferencia de Airy
@code{diff (y(x), x, 2) - x y(x) = 0}.

Si el argumento @code{x} es un número decimal en coma flotante
real o complejo, se devolverá el valor numérico de la función.

@deffn {Función} airy_ai (@var{x})
Función de Airy Ai(x).  (A&S 10.4.2)

La derivada @code{diff (airy_ai(x), x)} es @code{airy_dai(x)}.

Véanse @code{airy_bi}, @code{airy_dai} y @code{airy_dbi}.
@end deffn


@deffn {Función} airy_dai (@var{x})
Es la derivada de la función Ai de Airy, @code{airy_ai(x)}. 

Véase @code{airy_ai}.
@end deffn


@deffn {Función} airy_bi (@var{x})
Es la función Bi de Airy, tal como la definen Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}, Sección 10.4. Se trata de la segunda solución de la ecuación de Airy @code{diff (y(x), x, 2) - x y(x) = 0}.

Si el argumento @code{x} es un número decimal real o complejo, se devolverá el valor numérico de @code{airy_bi} siempre que sea posible. En los otros casos, se devuelve la expresión sin evaluar.

La derivada @code{diff (airy_bi(x), x)} es @code{airy_dbi(x)}.

Véanse @code{airy_ai} y @code{airy_dbi}.
@end deffn

@deffn {Función} airy_dbi (@var{x})
Es la derivada de la función Bi de Airy, @code{airy_bi(x)}.

Véanse @code{airy_ai} y @code{airy_bi}.
@end deffn





@node Funciones Gamma y factorial, Integral exponencial, Funciones de Airy, Funciones Especiales
@section Funciones Gamma y factorial

Las funciones gamma, beta, psi y gamma incompleta están
definidas en el capítulo 6 de Abramowitz y Stegun,
@i{Handbook of Mathematical Functions}.




@deffn {Función} bffac (@var{expr}, @var{n})
Versión para "bigfloat" de la función factorial (Gamma desplazada). El segundo argumento indica cuántos dígitos se conservan y devuelven, pudiendo utilizarse para obtener algunas cifras extra.

@end deffn

@defvr {Variable optativa} algepsilon
Valor por defecto: 10^8

El valor de @code{algepsilon} es usado por @code{algsys}.

@end defvr



@deffn {Función} bfpsi (@var{n}, @var{z}, @var{fpprec})
@deffnx {Función} bfpsi0 (@var{z}, @var{fpprec})
La función @code{bfpsi} es la poligamma de argumento real @var{z} y de orden el entero @var{n}. La función @code{bfpsi0} es la digamma.  La llamada @code{bfpsi0 (@var{z}, @var{fpprec})} equivale a @code{bfpsi (0, @var{z}, @var{fpprec})}.

Estas funciones devuelven valores "bigfloat". La variable @var{fpprec} es la precisión "bigfloat" del valor de retorno.

@c psi0(1) = -%gamma IS AN INTERESTING PROPERTY BUT IN THE ABSENCE OF ANY OTHER
@c DISCUSSION OF THE PROPERTIES OF THIS FUNCTION, THIS STATEMENT SEEMS OUT OF PLACE.
@c Note @code{-bfpsi0 (1, fpprec)} provides @code{%gamma} (Euler's constant) as a bigfloat.

@end deffn



@deffn {Función} cbffac (@var{z}, @var{fpprec})
Calcula el factorial de números complejos de punto flotante grandes.

La instrucción @code{load ("bffac")} carga esta función.

@end deffn



@deffn {Función} gamma (@var{x})

La definición básica de la función gamma (A&S 6.1.1) es

@ifnottex
@example
                               inf
                              /
                              [     z - 1   - t
                   gamma(z) = I    t      %e    dt
                              ]
                              /
                               0
@end example
@end ifnottex
@tex
$$\Gamma\left(z\right)=\int_{0}^{\infty }{t^{z-1}\,e^ {- t }\;dt}$$
@end tex

Maxima simplifica @code{gamma} para enteros positivos y para fracciones positivas
o negativas. Para fracciones de denominador dos, el resultado es un número 
racional multiplicado por @code{sqrt(%pi)}. La simplificación para valores
enteros la controla @code{factlim}. Para enteros mayores que @code{factlim}
el resultado numérico de la función factorial, la cual se utiliza para
calcular @code{gamma}, producirá un desbordamiento. La simplificación
para números racionales la controla @code{gammalim} para evitar desbordamientos.
Véanse también @code{factlim} y @code{gammalim}.

Para enteros negativos, @code{gamma} no está definida.

Maxima puede evaluar @code{gamma} numéricamente para valores reales
y complejos, tanto en formato float (doble precisión) como big float 
(precisión arbitraria).

La función @code{gamma} tiene simetría especular.

Si @code{gamma_expand} vale @code{true}, Maxima expande @code{gamma}
para argumentos del tipo @code{z+n} y @code{z-n}, siendo @code{n}
un entero.

Maxima conoce la derivada de @code{gamma}.

Ejemplos:

Simplificación para enteros, fracciones de denominador dos
y números racionales:

@example
(%i1) map('gamma,[1,2,3,4,5,6,7,8,9]);
(%o1)               [1, 1, 2, 6, 24, 120, 720, 5040, 40320]

(%i2) map('gamma,[1/2,3/2,5/2,7/2]);
                           sqrt(%pi)  3 sqrt(%pi)  15 sqrt(%pi)
(%o2)          [sqrt(%pi), ---------, -----------, ------------]
                               2           4            8

(%i3) map('gamma,[2/3,5/3,7/3]);
                                        2           1
                                2 gamma(-)  4 gamma(-)
                            2           3           3
(%o3)                [gamma(-), ----------, ----------]
                            3       3           9
@end example

Evaluación numérica para valores reales y complejos:

@example
(%i4) map('gamma,[2.5,2.5b0]);
(%o4)             [1.329340388179137, 1.329340388179137b0]

(%i5) map('gamma,[1.0+%i,1.0b0+%i]);
(%o5) [.4980156681183558 - .1549498283018108 %i, 
                      4.980156681183561b-1 - 1.549498283018107b-1 %i]
@end example

Simetría especular:

@example
(%i6) declare(z,complex)$
(%i7) conjugate(gamma(z));
(%o7)                         gamma(conjugate(z))
@end example

Maxima expande @code{gamma(z+n)} y @code{gamma(z-n)} si 
@code{gamma_expand} vale @code{true}:

@example
(%i8) gamma_expand:true$
(%i9) [gamma(z+1),gamma(z-1),gamma(z+2)/gamma(z+1)];
                                      gamma(z)
(%o9)                    [z gamma(z), --------, z + 1]
                                       z - 1
@end example

Derivada de @code{gamma}:

@example
(%i10) diff(gamma(z),z);
(%o10)                         psi (z) gamma(z)
                                  0
@end example

Véase también @code{makegamma}.

La constante de Euler-Mascheroni es @code{%gamma}.
@end deffn


@deffn {Función} log_gamma (@var{z})
Logaritmo natural de la función gamma.
@end deffn



@deffn {Función} gamma_incomplete_lower (@var{a}, @var{z})

Función gamma incompleta inferior (A&S 6.5.2):

@ifnottex
@example
                                    z
                                   /
                                   [  a - 1   - t
    gamma_incomplete_lower(a, z) = I t      %e    dt
                                   ]
                                   /
                                    0
@end example
@end ifnottex
@tex
$$\gamma\left(a , z\right)=\int_{0}^{z}{t^{a-1}\,e^ {- t }\;dt}$$
@end tex

Véase también @code{gamma_incomplete} (función gamma incompleta superior).
@end deffn



@deffn {Función} gamma_incomplete (@var{a},@var{z})
Función gamma incompleta superior, A&S 6.5.3:

@ifnottex
@example
                              inf
                             /
                             [     a - 1   - t
    gamma_incomplete(a, z) = I    t      %e    dt
                             ]
                             /
                              z
@end example
@end ifnottex
@tex
$$\Gamma\left(a , z\right)=\int_{z}^{\infty }{t^{a-1}\,e^ {- t }\;dt}$$
@end tex

Véanse también @code{gamma_expand} para controlar cómo se expresa
@code{gamma_incomplete} en términos de funciones elementales y de @code{erfc}.

Véanse también las funciones relacionadas @code{gamma_incomplete_regularized} y
@code{gamma_incomplete_generalized}.
@end deffn

@deffn {Función} gamma_incomplete_regularized (@var{a},@var{z})
Función gamma incompleta superior regularizada, A&S 6.5.1.

@ifnottex
@example
gamma_incomplete_regularized(a, z) = 
                                        gamma_incomplete(a, z)
                                        ----------------------
                                               gamma(a)
@end example
@end ifnottex
@tex
$${\it Q}\left(a , z\right)={{\Gamma\left(a , z\right)}\over{\Gamma\left(a\right)}}$$
@end tex

Véanse también @code{gamma_expand} para controlar cómo se expresa
@code{gamma_incomplete} en términos de funciones elementales y de @code{erfc}.

Véase también @code{gamma_incomplete}.
@end deffn

@deffn {Función} gamma_incomplete_generalized (@var{a},@var{z1},@var{z1})
Función gamma incompleta generalizada.  

@ifnottex
@example
gamma_incomplete_generalized(a, z1, z2) = 
                                               z2
                                              /
                                              [    a - 1   - t
                                              I   t      %e    dt
                                              ]
                                              /
                                               z1
@end example
@end ifnottex
@tex
$$\Gamma\left(a , z_{1}, z_{2}\right)=\int_{z_{1}}^{z_{2}}{t^{a-1}\,e^ {- t }\;dt}$$
@end tex

Véanse también @code{gamma_incomplete} y @code{gamma_incomplete_regularized}.
@end deffn


@defvr {Variable opcional} gamma_expand
Valor por defecto: @code{false}

@code{gamma_expand} controla la expansión de @code{gamma_incomplete}.
Si @code{gamma_expand} vale @code{true}, @code{gamma_incomplete(v,z)}
se expande en términos de
@code{z}, @code{exp(z)} y @code{erfc(z)}, siempre que sea posible.

@example
(%i1) gamma_incomplete(2,z);
(%o1)                       gamma_incomplete(2, z)
(%i2) gamma_expand:true;
(%o2)                                true
(%i3) gamma_incomplete(2,z);
                                           - z
(%o3)                            (z + 1) %e
@group
(%i4) gamma_incomplete(3/2,z);
                              - z   sqrt(%pi) erfc(sqrt(z))
(%o4)               sqrt(z) %e    + -----------------------
                                               2
@end group
@end example
@end defvr



@defvr {Variable optativa} gammalim
Valor por defecto: 10000

La variable @code{gammalim} controla la simplificación de la función gamma con argumentos enteros o racionales. Si el valor absoluto del argumento no es mayor que @code{gammalim}, entonces se realizará la simplificación. Nótese que la variable @code{factlim} también controla la simplificación del resultado de @code{gamma} con argumento entero.

@end defvr

@deffn {Función} makegamma (@var{expr})
Transforma las funciones @code{binomial}, @code{factorial} y @code{beta} que aparecen en @var{expr} en funciones @code{gamma}.

Véase también @code{makefact}.

@end deffn


@deffn {Función} beta (@var{a}, @var{b})
La función beta se define como @code{gamma(a) gamma(b)/gamma(a+b)}
(A&S 6.2.1).

Maxima simplifica la función beta para enteros positivos y números
racionales cuya suma sea entera. Si @code{beta_args_sum_to_integer}
vale @code{true}, Maxima también simplifica expresiones generales
cuya suma sea también entera.

Cuando @var{a} o @var{b} sean nulos, la función beta no está definida.

En general, la función beta no está definida para enteros negativos. 
La excepción es para @var{a=-n}, siendo @var{n} un entero positivo
y @var{b} otro entero positivo tal que @var{b<=n}, entonces es posible
definir una continuación analítica. En este caso Maxima
devuelve un resultado.

Si @code{beta_expand} vale @code{true}, expresiones como @code{beta(a+n,b)},
@code{beta(a-n,b)}, @code{beta(a,b+n)} o @code{beta(a,b-n)}, siendo @code{n}
entero, se simplifican.

Maxima puede evaluar la función beta para valores reales y complejos, tanto
de tipo decimal flotante o big float. Para la evaluación numérica
Maxima utiliza @code{log_gamma}:

@example
           - log_gamma(b + a) + log_gamma(b) + log_gamma(a)
         %e
@end example

Maxima reconoce la simetría de la función beta.

Maxima conoce las derivadas de la función beta, tanto respecto de @var{a}
como de @var{b}.

Para expresar la función beta como un cociente de funciones gamma,
véase @code{makegamma}.

Ejemplos:

Simplificación cuando uno de sus argumentos es entero:

@example
(%i1) [beta(2,3),beta(2,1/3),beta(2,a)];
                               1   9      1
(%o1)                         [--, -, ---------]
                               12  4  a (a + 1)
@end example

Simplificación para argumentos racionales que suman un entero:

@example
(%i2) [beta(1/2,5/2),beta(1/3,2/3),beta(1/4,3/4)];
                          3 %pi   2 %pi
(%o2)                    [-----, -------, sqrt(2) %pi]
                            8    sqrt(3)
@end example

Cuando se iguala @code{beta_args_sum_to_integer} a @code{true} se
simplifican expresiones más generales si la suma de los argumentos
se reduce a un entero:

@example
(%i3) beta_args_sum_to_integer:true$
(%i4) beta(a+1,-a+2);
                                %pi (a - 1) a
(%o4)                         ------------------
                              2 sin(%pi (2 - a))
@end example

Posibles valores cuando uno de los argumentos es entero negativo: 

@example
(%i5) [beta(-3,1),beta(-3,2),beta(-3,3)];
                                    1  1    1
(%o5)                            [- -, -, - -]
                                    3  6    3
@end example

@code{beta(a+n,b)} o @code{beta(a-n)} con @code{n} entero se simplifica
si @code{beta_expand} vale @code{true}:

@example
(%i6) beta_expand:true$
(%i7) [beta(a+1,b),beta(a-1,b),beta(a+1,b)/beta(a,b+1)];
                    a beta(a, b)  beta(a, b) (b + a - 1)  a
(%o7)              [------------, ----------------------, -]
                       b + a              a - 1           b

@end example

La función beta no está definida si uno de sus argumentos es cero:

@example
(%i7) beta(0,b);
beta: expected nonzero arguments; found 0, b
 -- an error.  To debug this try debugmode(true);
@end example

Evaluación numérica para argumentos reales y complejos de tipo
decimal flotante o big float:

@example
(%i8) beta(2.5,2.3);
(%o8) .08694748611299981

(%i9) beta(2.5,1.4+%i);
(%o9) 0.0640144950796695 - .1502078053286415 %i

(%i10) beta(2.5b0,2.3b0);
(%o10) 8.694748611299969b-2

(%i11) beta(2.5b0,1.4b0+%i);
(%o11) 6.401449507966944b-2 - 1.502078053286415b-1 %i
@end example

La función beta es simétrica con simetría especular:

@example
(%i14) beta(a,b)-beta(b,a);
(%o14)                                 0
(%i15) declare(a,complex,b,complex)$
(%i16) conjugate(beta(a,b));
(%o16)                 beta(conjugate(a), conjugate(b))
@end example

Derivada de la función beta respecto de @code{a}:

@example
(%i17) diff(beta(a,b),a);
(%o17)               - beta(a, b) (psi (b + a) - psi (a))
                                      0             0
@end example
@end deffn

@deffn {Función} beta_incomplete (@var{a}, @var{b}, @var{z})
La definición básica de la función beta incompleta (A&S 6.6.1) es

@example
                       z
                      /
                      [         b - 1  a - 1
                      I  (1 - t)      t      dt
                      ]
                      /
                       0
@end example

Esta definición es posible para @math{realpart(a)>0}, @math{realpart(b)>0}
y @math{abs(z)<1}. Para otras situaciones, la función beta incompleta puede
definirse por medio de una función hipergeométrica generalizada:

@example
   gamma(a) hypergeometric_generalized([a, 1 - b], [a + 1], z) z
@end example
(Véase Funcións.wolfram.com para una completa definición de la función beta 
incompleta.)

Para enteros negativos @math{a = -n} y enteros positivos @math{b=m} con 
@math{m<=n} la función beta incompleta se define como

@example
                            m - 1           k
                            ====  (1 - m)  z
                      n - 1 \            k
                     z       >    -----------
                            /     k! (n - k)
                            ====
                            k = 0
@end example
Maxima utiliza esta definición para simplificar @code{beta_incomplete} 
cuando @var{a} es entero negativo.

Cuando @var{a} es entero positivo, @code{beta_incomplete} se simplifica
para cualesquiera argumentos @var{b} y @var{z}, y para @var{b} entero
positivo para cualesquiera argumentos @var{a} y @var{z}, con la 
excepción de cuando @var{a} sea entero negativo.

Para @math{z=0} y @math{realpart(a)>0}, @code{beta_incomplete} se anula.
Para @var{z=1} y @math{realpart(b)>0}, @code{beta_incomplete} se reduce a
la función @code{beta(a,b)}.

Maxima evalúa @code{beta_incomplete} numéricamente para valores reales
y complejos en forma decimal y big float. La evaluación numérica se
realiza expandiendo la función beta incompleta en fracciones continuas.

Si @code{beta_expand} vale @code{true}, Maxima expande las expresiones
@code{beta_incomplete(a+n,b,z)} y @code{beta_incomplete(a-n,b,z)},
siendo @var{n} entero positivo.

Maxima conoce las derivadas de @code{beta_incomplete} con respecto a
las variables @var{a}, @var{b} y @var{z}, así como la
integral respecto de la variable @var{z}.

Ejemplos:

Simplificación para @var{a} entero positivo:

@example
(%i1) beta_incomplete(2,b,z);
                                       b
                            1 - (1 - z)  (b z + 1)
(%o1)                       ----------------------
                                  b (b + 1)
@end example

Simplificación para @var{b} entero positivo:

@example
(%i2) beta_incomplete(a,2,z);
                                               a
                              (a (1 - z) + 1) z
(%o2)                         ------------------
                                  a (a + 1)
@end example

Simplificación para @var{a} y @var{b} enteros positivos:

@example
(%i3) beta_incomplete(3,2,z);
                                               3
                              (3 (1 - z) + 1) z
(%o3)                         ------------------
                                      12
@end example

Para @var{a} entero negativo y @math{b<=(-a)}:

@example
(%i4) beta_incomplete(-3,1,z);
                                       1
(%o4)                              - ----
                                        3
                                     3 z
@end example

Simplificación para los valores @math{z=0} y @math{z=1}:

@example
(%i5) assume(a>0,b>0)$
(%i6) beta_incomplete(a,b,0);
(%o6)                                 0
(%i7) beta_incomplete(a,b,1);
(%o7)                            beta(a, b)
@end example

Evaluación numérica, tanto con float (precisión doble)
como big float (precisión arbitraria):

@example
(%i8) beta_incomplete(0.25,0.50,0.9);
(%o8)                          4.594959440269333
(%i9)  fpprec:25$
(%i10) beta_incomplete(0.25,0.50,0.9b0);
(%o10)                    4.594959440269324086971203b0
@end example

Para @math{abs(z)>1}, @code{beta_incomplete} devuelve un
resultado complejo:

@example
(%i11) beta_incomplete(0.25,0.50,1.7);
(%o11)              5.244115108584249 - 1.45518047787844 %i
@end example

Resultados para argumentos complejos más generales:

@example
(%i14) beta_incomplete(0.25+%i,1.0+%i,1.7+%i);
(%o14)             2.726960675662536 - .3831175704269199 %i
(%i15) beta_incomplete(1/2,5/4*%i,2.8+%i);
(%o15)             13.04649635168716 %i - 5.802067956270001
(%i16) 
@end example

Expansión cuando @code{beta_expand} vale @code{true}:

@example
(%i23) beta_incomplete(a+1,b,z),beta_expand:true;
                                                       b  a
                   a beta_incomplete(a, b, z)   (1 - z)  z
(%o23)             -------------------------- - -----------
                             b + a                 b + a

(%i24) beta_incomplete(a-1,b,z),beta_expand:true;
                                                           b  a - 1
           beta_incomplete(a, b, z) (- b - a + 1)   (1 - z)  z
(%o24)     -------------------------------------- - ---------------
                           1 - a                         1 - a
@end example
 
Derivada e integral de @code{beta_incomplete}:

@example
@example
(%i34) diff(beta_incomplete(a, b, z), z);
                              b - 1  a - 1
(%o34)                 (1 - z)      z
(%i35) integrate(beta_incomplete(a, b, z), z);
              b  a
       (1 - z)  z
(%o35) ----------- + beta_incomplete(a, b, z) z
          b + a
                                       a beta_incomplete(a, b, z)
                                     - --------------------------
                                                 b + a
(%i36) factor(diff(%, z));
(%o36)              beta_incomplete(a, b, z)
@end example

@end example
@end deffn

@deffn {Función} beta_incomplete_regularized (@var{a}, @var{b}, @var{z})
Función beta incompleta regularizada A&S 6.6.2,
definida como

@example
beta_incomplete_regularized(a, b, z) = 
                                      beta_incomplete(a, b, z)
                                      ------------------------
                                             beta(a, b)
@end example

Al igual que @code{beta_incomplete}, esta definición no es completa.
Véase Funcións.wolfram.com para una definición completa de 
@code{beta_incomplete_regularized}.

@code{beta_incomplete_regularized} se simplifica para @var{a} o @var{b} 
entero positivo.

Para @math{z=0} y @math{realpart(a)>0}, @code{beta_incomplete_regularized} se anula.
Para @var{z=1} y @math{realpart(b)>0}, @code{beta_incomplete_regularized} se reduce a 1.

Maxima evalúa @code{beta_incomplete_regularized} numéricamente para valores reales
y complejos en forma decimal y big float.

Si @code{beta_expand} vale @code{true}, Maxima expande 
@code{beta_incomplete_regularized} para los argumentos @math{a+n} o @math{a-n},
siendo @var{n} entero.

Maxima conoce las derivadas de @code{beta_incomplete_regularized} con respecto a
las variables @var{a}, @var{b} y @var{z}, así como la
integral respecto de la variable @var{z}.

Ejemplos:

Simplificación para @var{a} o @var{b} enteros positivos:

@example
(%i1) beta_incomplete_regularized(2,b,z);
                                       b
(%o1)                       1 - (1 - z)  (b z + 1)

(%i2) beta_incomplete_regularized(a,2,z);
                                               a
(%o2)                         (a (1 - z) + 1) z

(%i3) beta_incomplete_regularized(3,2,z);
                                               3
(%o3)                         (3 (1 - z) + 1) z
@end example

Simplificación para los valores @math{z=0} y @math{z=1}:

@example
(%i4) assume(a>0,b>0)$
(%i5) beta_incomplete_regularized(a,b,0);
(%o5)                                 0
(%i6) beta_incomplete_regularized(a,b,1);
(%o6)                                 1
@end example

Evaluación numérica, tanto con float (precisión doble)
como big float (precisión arbitraria):

@example
(%i7) beta_incomplete_regularized(0.12,0.43,0.9);
(%o7)                         .9114011367359802
(%i8) fpprec:32$
(%i9) beta_incomplete_regularized(0.12,0.43,0.9b0);
(%o9)               9.1140113673598075519946998779975b-1
(%i10) beta_incomplete_regularized(1+%i,3/3,1.5*%i);
(%o10)             .2865367499935403 %i - 0.122995963334684
(%i11) fpprec:20$
(%i12) beta_incomplete_regularized(1+%i,3/3,1.5b0*%i);
(%o12)      2.8653674999354036142b-1 %i - 1.2299596333468400163b-1
@end example

Expansión cuando @code{beta_expand} vale @code{true}:

@example
(%i13) beta_incomplete_regularized(a+1,b,z);
                                                     b  a
                                              (1 - z)  z
(%o13) beta_incomplete_regularized(a, b, z) - ------------
                                              a beta(a, b)
(%i14) beta_incomplete_regularized(a-1,b,z);
(%o14) beta_incomplete_regularized(a, b, z)
                                                     b  a - 1
                                              (1 - z)  z
                                         - ----------------------
                                           beta(a, b) (b + a - 1)

@end example

Derivada e integral respecto de @var{z}:

@example
(%i15) diff(beta_incomplete_regularized(a,b,z),z);
                              b - 1  a - 1
                       (1 - z)      z
(%o15)                 -------------------
                           beta(a, b)
(%i16) integrate(beta_incomplete_regularized(a,b,z),z);
(%o16) beta_incomplete_regularized(a, b, z) z
                                                           b  a
                                                    (1 - z)  z
          a (beta_incomplete_regularized(a, b, z) - ------------)
                                                    a beta(a, b)
        - -------------------------------------------------------
                                   b + a
@end example

@end deffn

@deffn {Función} beta_incomplete_generalized (@var{a}, @var{b}, @var{z1}, @var{z2})
La definición básica de la función beta incompleta generalizada es

The basic definition of the generalized incomplete beta function is

@example
                      z2
                     /
                     [          b - 1  a - 1
                     I   (1 - t)      t      dt
                     ]
                     /
                      z1
@end example

Maxima simplifica @code{beta_incomplete_regularized} para @var{a} y @var{b} 
enteros positivos.

Para @math{realpart(a)>0} y @math{z1=0} o @math{z2=0}, Maxima reduce
@code{beta_incomplete_generalized} a @code{beta_incomplete}. Para
@math{realpart(b)>0} y @math{z1=1} o @var{z2=1}, Maxima reduce a
una expresión con @code{beta} y @code{beta_incomplete}.

Maxima evalúa @code{beta_incomplete_generalized} numéricamente para valores reales
y complejos en forma decimal y big float.

Si @code{beta_expand} vale @code{true}, Maxima expande 
@code{beta_incomplete_generalized} para los argumentos @math{a+n} y @math{a-n},
siendo @var{n} entero positivo.

Maxima conoce las derivadas de @code{beta_incomplete_generalized} con respecto a
las variables @var{a}, @var{b}, @var{z1} y @var{z2}, así como la
integral respecto de las variables @var{z1} y @var{z2}.

Ejemplos:

Maxima simplifica @code{beta_incomplete_generalized} para @var{a} y @var{b}
enteros positivos:
@example
(%i1) beta_incomplete_generalized(2,b,z1,z2);
                          b                      b
                  (1 - z1)  (b z1 + 1) - (1 - z2)  (b z2 + 1)
(%o1)             -------------------------------------------
                                   b (b + 1)

(%i2) beta_incomplete_generalized(a,2,z1,z2);
                                     a                      a
                  (a (1 - z2) + 1) z2  - (a (1 - z1) + 1) z1
(%o2)             -------------------------------------------
                                   a (a + 1)

(%i3) beta_incomplete_generalized(3,2,z1,z2);
                  2      2                       2      2
          (1 - z1)  (3 z1  + 2 z1 + 1) - (1 - z2)  (3 z2  + 2 z2 + 1)
(%o3)     -----------------------------------------------------------
                                      12
@end example

Simplificación para los valores @math{z1=0}, @math{z2=0}, @math{z1=1}
o @math{z2=1}:
@example
(%i4) assume(a > 0, b > 0)$
(%i5) beta_incomplete_generalized(a,b,z1,0);
(%o5)                    - beta_incomplete(a, b, z1)

(%i6) beta_incomplete_generalized(a,b,0,z2);
(%o6)                    - beta_incomplete(a, b, z2)

(%i7) beta_incomplete_generalized(a,b,z1,1);
(%o7)              beta(a, b) - beta_incomplete(a, b, z1)

(%i8) beta_incomplete_generalized(a,b,1,z2);
(%o8)              beta_incomplete(a, b, z2) - beta(a, b)
@end example

Evaluación numérica para argumentos reales, tanto con float
(precisión doble) como big float (precisión arbitraria):
@example
(%i9) beta_incomplete_generalized(1/2,3/2,0.25,0.31);
(%o9)                        .09638178086368676

(%i10) fpprec:32$
(%i10) beta_incomplete_generalized(1/2,3/2,0.25,0.31b0);
(%o10)               9.6381780863686935309170054689964b-2
@end example

Evaluación numérica para argumentos complejos, tanto con float
(precisión doble) como big float (precisión arbitraria):
@example
(%i11) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31);
(%o11)           - .09625463003205376 %i - .003323847735353769
(%i12) fpprec:20$
(%i13) beta_incomplete_generalized(1/2+%i,3/2+%i,0.25,0.31b0);
(%o13)     - 9.6254630032054178691b-2 %i - 3.3238477353543591914b-3
@end example

Expansión para @math{a+n} o @math{a-n}, siendo @var{n} entero positivo
con @code{beta_expand} igual @code{true}:
@example
(%i14) beta_expand:true$
(%i15) beta_incomplete_generalized(a+1,b,z1,z2);
               b   a           b   a
       (1 - z1)  z1  - (1 - z2)  z2
(%o15) -----------------------------
                   b + a
                            a beta_incomplete_generalized(a, b, z1, z2)
                          + -------------------------------------------
                                               b + a

(%i16) beta_incomplete_generalized(a-1,b,z1,z2);
       beta_incomplete_generalized(a, b, z1, z2) (- b - a + 1)
(%o16) -------------------------------------------------------
                                1 - a
                                          b   a - 1           b   a - 1
                                  (1 - z2)  z2      - (1 - z1)  z1
                                - -------------------------------------
                                                  1 - a
@end example

Derivada respecto de la variable @var{z1} e integrales respecto de 
@var{z1} y @var{z2}:
@example
(%i17) diff(beta_incomplete_generalized(a,b,z1,z2),z1);
                                      b - 1   a - 1
(%o17)                      - (1 - z1)      z1

(%i18) integrate(beta_incomplete_generalized(a,b,z1,z2),z1);
(%o18) beta_incomplete_generalized(a, b, z1, z2) z1
                                        + beta_incomplete(a + 1, b, z1)

(%i19) integrate(beta_incomplete_generalized(a,b,z1,z2),z2);
(%o19) beta_incomplete_generalized(a, b, z1, z2) z2
                                        - beta_incomplete(a + 1, b, z2)
@end example
@end deffn


@defvr {Variable opcional} beta_expand
Valor por defecto: false

Si @code{beta_expand} vale @code{true}, @code{beta(a,b)} y sus
funciones relacionadas se expanden para argumentos del tipo 
@math{a+n} o @math{a-n}, siendo @math{n} un número entero.
@end defvr

@defvr {Variable opcional} beta_args_sum_to_integer
Valor por defecto: false

Si @code{beta_args_sum_to_integer} vale @code{true}, Maxima simplifica 
@code{beta(a,b)} cuando la suma de los argumentos @var{a} y @var{b} sea un entero.
@end defvr



@deffn {Función} psi [@var{n}](@var{x})

Es la derivada de @code{log (gamma (@var{x}))} de orden @code{@var{n}+1},
de tal manera que @code{psi[0](@var{x})} es la primera derivada, 
@code{psi[1](@var{x})} la segunda derivada y así 
sucesivamente.

En general, Maxima no sabe cómo calcular valores numéricos de 
@code{psi}, pero sí conoce el valor exacto para
algunos argumentos racionales.
Existen algunas variables globales para controlar en qué rangos
racionales debe devolver @code{psi} resultados exactos, si ello es posible.
Véanse las descripciones de @code{maxpsiposint}, @code{maxpsinegint},
@code{maxpsifracnum} y @code{maxpsifracdenom}.
En resumen, @var{x} debe alcanzar un valor entre @code{maxpsinegint} y
@code{maxpsiposint}. Si el valor absoluto de la parte fraccional de
@var{x} es racional y tiene un numerador menor que @code{maxpsifracnum}
y un denominador menor que @code{maxpsifracdenom}, la función @code{psi}
devolverá un valor exacto.

La función @code{bfpsi} del paquete @code{bffac} puede calcular
valores numéricos.

@end deffn

@defvr {Variable opcional} maxpsiposint
Valor por defecto: 20

La variable @code{maxpsiposint} guarda el mayor valor positivo para el 
que @code{psi[n](x)} intentará calcular un valor exacto.

@end defvr

@defvr {Variable opcional} maxpsinegint
Valor por defecto: -10

La variable @code{maxpsinegint} guarda el menor valor negativo para el
que @code{psi[n](x)} intentará calcular un valor exacto. Si
@var{x} es menor que @code{maxnegint}, @code{psi[n](@var{x})} no devolverá
una respuesta simplificada, aunque supiese cómo hacerlo.

@end defvr


@defvr {Variable opcional} maxpsifracnum
Valor por defecto: 6

Sea @var{x} un número racional menor que la unidad de la forma @code{p/q}.
Si @code{p} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolverá una respuesta simplificada.

@end defvr

@defvr {Variable opcional} maxpsifracdenom
Valor por defecto: 6

Sea @var{x} un número racional menor que la unidad de la forma @code{p/q}.
Si @code{q} es mayor que @code{maxpsifracnum}, entonces
@code{psi[@var{n}](@var{x})} no devolverá una respuesta simplificada.

@end defvr


@deffn {Función} makefact (@var{expr})
Transforma las funciones @code{binomial}, @code{gamma} y @code{beta} que aparecen en @var{expr} en su notación factorial.

Véase también @code{makegamma}.

@end deffn


@deffn {Función} numfactor (@var{expr})
Devuelve el factor numérico que multiplica a la expresión @var{expr}, la cual debe tener un único término. 

@example
(%i1) gamma (7/2);
                          15 sqrt(%pi)
(%o1)                     ------------
                               8
(%i2) numfactor (%);
                               15
(%o2)                          --
                               8
@end example

@end deffn







@node Integral exponencial, Función de error, Funciones Gamma y factorial, Funciones Especiales
@section Integral exponencial

La integral exponencial y sus funciones relacionadas se 
definen en el capítulo 5 de Abramowitz y Stegun, 
@i{Handbook of Mathematical Functions}.


@deffn {Función} expintegral_e1 (@var{z})
La integral exponencial E1(z) (A&S 5.1.1)
@end deffn

@deffn {Función} expintegral_ei (@var{z})
La integral exponencial Ei(z) (A&S 5.1.2)
@end deffn

@deffn {Función} expintegral_li (@var{z})
La integral exponencial Li(z)  (A&S 5.1.3)
@end deffn

@deffn {Función} expintegral_e (@var{n},@var{z})
La integral exponencial En(z)  (A&S 5.1.4)
@end deffn

@deffn {Función} expintegral_si (@var{z})
La integral exponencial Si(z) (A&S 5.2.1)
@end deffn

@deffn {Función} expintegral_ci (@var{z})
La integral exponencial Ci(z) (A&S 5.2.2)
@end deffn

@deffn {Función} expintegral_shi (@var{z})
La integral exponencial Shi(z) (A&S 5.2.3)
@end deffn

@deffn {Función} expintegral_chi (@var{z})
La integral exponencial Chi(z) (A&S 5.2.4)
@end deffn

@defvr {Option variable} expintrep
Valor por defecto: false

Transforma la representación de la integral exponencial
en términos de las funciones @code{gamma_incomplete}, 
@code{expintegral_e1}, @code{expintegral_ei}, 
@code{expintegral_li}, @code{expintegral_trig} y @code{expintegral_hyp}.
@end defvr

@defvr {Option variable} expintexpand 
Valor por defecto: false

Expande la integral exponencial E[n](z)
para valores medios de la integral en términos de 
las funciones Erfc o Erf y para positivos enteros
en términos de Ei .
@end defvr





@node Función de error, Funciones de Struve, Integral exponencial, Funciones Especiales
@section Función de error

La función de error y sus asociadas se definen en el 
capítulo 7 de Abramowitz y Stegun, 
@i{Handbook of Mathematical Functions}.


@deffn {Función} erf (@var{z})
Función de error erf(z) (A&S 7.1.1)

Véase también @code{erfflag}.
@end deffn

@deffn {Función} erfc (@var{z})
Complemento de la función de error erfc(z) (A&S 7.1.2)

@code{erfc(z) = 1-erf(z)}
@end deffn

@deffn {Función} erfi (@var{z})
Función de error imaginaria. 

@code{erfi(z) = -%i*erf(%i*z)}
@end deffn

@deffn {Función} erf_generalized (@var{z1},@var{z2})
Función de error generalizada Erf(z1,z2)
@end deffn


@deffn {Función} fresnel_c (@var{z})
Integral de Fresnel @code{C(z) = integrate(cos((%pi/2)*t^2),t,0,z)}. (A&S 7.3.1)

La simplificación @code{fresnel_c(-x) = -fresnel_c(x)} se aplica cuando
la variable global @code{trigsign} vale @code{true}.

La simplificación @code{fresnel_s(%i*x) =  -%i*fresnel_s(x)} se aplica cuando
la variable global @code{%iargs} vale @code{true}.

Véanse también @code{erf_representation} y
@code{hypergeometric_representation}.
@end deffn

@deffn {Función} fresnel_s (@var{z})
Integral de Fresnel S(z) = integrate(sin((%pi/2)*t^2),t,0,z). (A&S 7.3.2)

La simplificación fresnel_s(-x) = -fresnel_s(x) se aplica cuando
la variable global @code{trigsign} vale @code{true}.

La simplificación fresnel_s(%i*x) =  %i*fresnel_s(x) se aplica cuando
la variable global @code{%iargs} vale @code{true}.

Véanse también @code{erf_representation} y
@code{hypergeometric_representation}.
@end deffn

@defvr {Variable opcional} erf_representation
Valor por defecto: false

Cuando valga @code{true} erfc, erfi, erf_generalized, fresnel_s 
y fresnel_c se transforman a erf.
@end defvr

@defvr {Variable opcional} hypergeometric_representation
Valor por defecto: false

Permite obtener la representación hipergeométrica
de las funciones fresnel_s y fresnel_c.
@end defvr







@node Funciones de Struve, Funciones hipergeométricas, Función de error, Funciones Especiales
@section Funciones de Struve

Las funciones de Struve se definen en el capítulo
12 de Abramowitz y Stegun, @i{Handbook of Mathematical Functions}.

@deffn {Función} struve_h (@var{v}, @var{z})
Función H de Struve de orden @var{v} y argumento @var{z}, (A&S 12.1.1).

@end deffn

@deffn {Función} struve_l (@var{v}, @var{z})
Función L modificada de Struve de orden @var{v} y argumento @var{z}, (A&S 12.2.1).

@end deffn





@node Funciones hipergeométricas, Funciones de cilindro parabólico, Funciones de Struve, Funciones Especiales
@section Funciones hipergeométricas

Las funciones hipergeométricas se definen en los capítulos
13 y 15 de Abramowitz y Stegun, @i{Handbook of Mathematical Functions}. 

Maxima tiene un soporte limitado sobre estas funciones, que pueden
aparecer en resultados devueltos por @code{hgfred}.

@deffn {Función} %m [@var{k},@var{u}] (@var{z}) 
Función M de Whittaker
@code{M[k,u](z) = exp(-z/2)*z^(1/2+u)*M(1/2+u-k,1+2*u,z)}.  
(A&S 13.1.32)
@end deffn

@deffn {Función} %w [@var{k},@var{u}] (@var{z}) 
Función W de Whittaker.  (A&S 13.1.33)
@end deffn


@deffn {Función} %f [@var{p},@var{q}] (@var{[a],[b],z}) 
Es la función hipergeométrica pFq(a1,a2,..ap;b1,b2,..bq;z),
donde @code{a} es una lista de longitud @code{p} y 
@code{b} otra lista de longitud @code{q}.
@end deffn


@deffn {Función} hypergeometric ([@var{a1}, ..., @var{ap}],[@var{b1}, ... ,@var{bq}], x)
Es la función hipergeométrica. A diferencia de la función
hipergeométrica @code{%f} de Maxima, la función @code{hypergeometric}
es simplificadora; además, @code{hypergeometric} soporta la evaluación
en doble (float) y gran (bigfloat) precisión. La evaluación 
numérica fuera del círculo unidad no está en general
soportada, pero sí en el caso de la función
hipergeométrica de Gauss, cuando @math{p = 2} y @math{q = 1}.

Si la variable opcional @code{expand_hypergeometric} vale @code{true},
(el valor por defecto es @code{false}) y uno de los argumentos entr @code{a1}
y @code{ap} es entero negativo (caso polinomial), entonces @code{hypergeometric}
devuelve un polinomio expandido.

Ejemplos:
@example
(%i1)  hypergeometric([],[],x);
(%o1) %e^x
@end example

Los polinomios se expanden automáticamente cuando @code{expand_hypergeometric}
vale @code{true}.

@example
(%i2) hypergeometric([-3],[7],x);
(%o2) hypergeometric([-3],[7],x)

(%i3) hypergeometric([-3],[7],x), expand_hypergeometric : true;
(%o3) -x^3/504+3*x^2/56-3*x/7+1
@end example

Se soporta la evaluación en doble (float) y gran (bigfloat) precisión:

@example
(%i4) hypergeometric([5.1],[7.1 + %i],0.42);
(%o4)       1.346250786375334 - 0.0559061414208204 %i
(%i5) hypergeometric([5,6],[8], 5.7 - %i);
(%o5)     .007375824009774946 - .001049813688578674 %i
(%i6) hypergeometric([5,6],[8], 5.7b0 - %i), fpprec : 30;
(%o6) 7.37582400977494674506442010824b-3
                          - 1.04981368857867315858055393376b-3 %i
@end example
@end deffn









@node Funciones de cilindro parabólico, Funciones y variables para las funciones especiales, Funciones hipergeométricas, Funciones Especiales
@section  Funciones de cilindro parabólico

Las funciones de cilindro parabólico se definen en el capítulo
19 de Abramowitz y Stegun, @i{Handbook of Mathematical Functions}. 

Maxima tiene un soporte limitado sobre estas funciones, que pueden
aparecer en resultados devueltos por @code{hgfred}.

@deffn {Función} parabolic_cylinder_d (@var{v}, @var{z}) 
Función de cilindro parabólico @code{parabolic_cylinder_d(v,z)}. (A&s 19.3.1)
@end deffn











@node Funciones y variables para las funciones especiales,  , Funciones de cilindro parabólico, Funciones Especiales
@section Funciones y variables para las funciones especiales


@deffn {Función} specint (exp(- s*@var{t}) * @var{expr}, @var{t})

Calcula la transformada de Laplace de @var{expr} respecto de
la variable @var{t}. El integrando @var{expr} puede contener
funciones especiales.

La función @code{specint} admite las funciones especiales siguientes:
la gamma incompleta, las funciones de error (pero no @code{erfi}, siendo
sencillo transformar @code{erfi} en la función de error @code{erf}),
integrales exponenciales, funciones de Bessel (incluidos productos de
funciones de Bessel), funciones de Hankel, de Hermite y los polinomios de
Laguerre.

Además, @code{specint} también admite la función hipergeométrica
@code{%f[p,q]([],[],z)}, la función de Whittaker de primera especie
@code{%m[u,k](z)} y la de segunda especie @code{%w[u,k](z)}.

El resultado puede darse en términos de funciones especiales y es
posible que incluya también funciones hipergeométricas sin
simplificar.

Cuando @code{laplace} es incapaz de calcular la transformada de Laplace,
entonces llama a la función @code{specint}. Puesto que @code{laplace}
tiene programadas más reglas para calcular transformadas de Laplace,
es preferible utilizar @code{laplace} en lugar de @code{specint}.

La ejecución de @code{demo(hypgeo)} muestra algunos ejemplos de
transformadas de Laplace calculadas con @code{specint}.

Ejemplos:
@c ===beg===
@c assume (p > 0, a > 0)$
@c specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
@c specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
@c               * exp(-p*t), t);
@c ===end===

@example
(%i1) assume (p > 0, a > 0)$
(%i2) specint (t^(1/2) * exp(-a*t/4) * exp(-p*t), t);
                           sqrt(%pi)
(%o2)                     ------------
                                 a 3/2
                          2 (p + -)
                                 4
(%i3) specint (t^(1/2) * bessel_j(1, 2 * a^(1/2) * t^(1/2))
              * exp(-p*t), t);
                                   - a/p
                         sqrt(a) %e
(%o3)                    ---------------
                                2
                               p
@end example

Ejemplos para integrales exponenciales:

@example
(%i4) assume(s>0,a>0,s-a>0)$
(%i5) ratsimp(specint(%e^(a*t)
                      *(log(a)+expintegral_e1(a*t))*%e^(-s*t),t));
                             log(s)
(%o5)                        ------
                             s - a
(%i6) logarc:true$

(%i7) gamma_expand:true$

radcan(specint((cos(t)*expintegral_si(t)
                     -sin(t)*expintegral_ci(t))*%e^(-s*t),t));
                             log(s)
(%o8)                        ------
                              2
                             s  + 1
ratsimp(specint((2*t*log(a)+2/a*sin(a*t)
                      -2*t*expintegral_ci(a*t))*%e^(-s*t),t));
                               2    2
                          log(s  + a )
(%o9)                     ------------
                                2
                               s
@end example

Resultados cuando se utiliza la expansión de @code{gamma_incomplete}
y se cambia la representación de @code{expintegral_e1}:

@example
(%i10) assume(s>0)$
(%i11) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                                            1
                            gamma_incomplete(-, k s)
                                            2
(%o11)                      ------------------------
                               sqrt(%pi) sqrt(s)

(%i12) gamma_expand:true$
(%i13) specint(1/sqrt(%pi*t)*unit_step(t-k)*%e^(-s*t),t);
                              erfc(sqrt(k) sqrt(s))
(%o13)                        ---------------------
                                     sqrt(s)

(%i14) expintrep:expintegral_e1$
(%i15) ratsimp(specint(1/(t+a)^2*%e^(-s*t),t));
                              a s
                        a s %e    expintegral_e1(a s) - 1
(%o15)                - ---------------------------------
                                        a
@end example
@end deffn


@deffn {Función} hgfred (@var{a}, @var{b}, @var{t})

Simplifica la función hipergeométrica generalizada en términos
de otras funciones más sencillas. @var{a} es una lista de parámetros
del numerador y @var{b} lo es de parámetros del denominador.

En caso de que @code{hgfred} no pueda simplificar la función hipergeométrica
devolverá una expresión de la forma @code{%f[p,q]([a], [b], x)}, siendo @var{p}
el número de elementos de @var{a} y @var{q} el de @var{b}. Esta es la 
función hipergeométrica generalizada @code{pFq}.

@example
(%i1) assume(not(equal(z,0)));
(%o1)                          [notequal(z, 0)]
(%i2) hgfred([v+1/2],[2*v+1],2*%i*z);

                     v/2                               %i z
                    4    bessel_j(v, z) gamma(v + 1) %e
(%o2)               ---------------------------------------
                                       v
                                      z
(%i3) hgfred([1,1],[2],z);

                                   log(1 - z)
(%o3)                            - ----------
                                       z
(%i4) hgfred([a,a+1/2],[3/2],z^2);

                               1 - 2 a          1 - 2 a
                        (z + 1)        - (1 - z)
(%o4)                   -------------------------------
                                 2 (1 - 2 a) z

@end example

Tal como muestra el siguiente ejemplo, puede ser de utilidad cargar
también el paquete @code{orthopoly}. Nótese que @var{L} es el
polinomio generalizado de Laguerre.

@example
(%i5) load(orthopoly)$
(%i6) hgfred([-2],[a],z);

                                    (a - 1)
                                 2 L       (z)
                                    2
(%o6)                            -------------
                                   a (a + 1)
(%i7) ev(%);

                                  2
                                 z        2 z
(%o7)                         --------- - --- + 1
                              a (a + 1)    a

@end example

@end deffn


@deffn {Función} lambert_w (@var{z})
Rama principal de la función W de Lambert, solución de
la ecuación @code{z = W(z) * exp(W(z))}.  (DLMF 4.13)
@end deffn

@deffn {Función} generalized_lambert_w (@var{k}, @var{z})
@var{k}-ésima rama de la función W de Lambert's, W(z), solución de
@code{z = W(z) * exp(W(z))}. (DLMF 4.13)

La rama principal, representada por Wp(z) en DLMF, es @code{lambert_w(z) = generalized_lambert_w(0,z)}.

La otra rama con valores reales, representada por Wm(z) en DLMF, es @code{generalized_lambert_w(-1,z)}.
@end deffn

@deffn {Función} nzeta (@var{z})
Función de dispersión del plasma.
@code{nzeta(z) = %i*sqrt(%pi)*exp(-z^2)*(1-erf(-%i*z))}
@end deffn

@deffn {Función} nzetar (@var{z})
Devuelve @code{realpart(nzeta(z))}.
@end deffn

@deffn {Función} nzetai (@var{z})
Devuelve @code{imagpart(nzeta(z))}.
@end deffn


