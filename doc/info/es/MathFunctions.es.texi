@c English version 2013-04-04
@menu
* Funciones para los números::
* Funciones para los números complejos::
* Funciones combinatorias::
* Funciones radicales exponenciales y logarítmicas::
* Funciones trigonométricas::
* Números aleatorios::
@end menu




@node Funciones para los números, Funciones para los números complejos, Funciones matemáticas, Funciones matemáticas
@section Funciones para los números


@deffn {Función} abs (@var{z})
La función @code{abs} representa el valor absoluto y se puede aplicar tanto 
a argumentos numéricos como simbólicos. Si el argumento @var{z} es un
número real o complejo, @code{abs} devuelve el valor absoluto de @var{z}.
Si es posible, las expresiones simbólicas que utilizan la función del
valor absoluto también se simplifican.

Maxima puede derivar, integrar y calcular límites de expresiones
que contengan a @code{abs}. El paquete @code{abs_integrate} extiende las
capacidades de Maxima para calcular integrales que contengan llamadas a
@code{abs}. Véase @code{(%i12)} en el ejemplo de más abajo.

Cuando se aplica a una lista o matriz, @code{abs} se distribuye automáticamente
sobre sus elementos. De forma similar, también se distribuye sobre los dos
miembros de una igualdad. Para cambiar este comportamiento por defecto, 
véase la variable @code{distribute_over}.

Ejemplos:

Cálculo del valor absoluto de números reales y complejos, incluyendo
constantes numéricas e infinitos. El primer ejemplo muestra cómo 
@code{abs} se distribuye sobre los elementos de una lista.

@example
(%i1) abs([-4, 0, 1, 1+%i]);
(%o1)                  [4, 0, 1, sqrt(2)]

(%i2) abs((1+%i)*(1-%i));
(%o2)                           2
(%i3) abs(%e+%i);
                                2
(%o3)                    sqrt(%e  + 1)
(%i4) abs([inf, infinity, minf]);
(%o4)                   [inf, inf, inf]
@end example

Simplificación de expresiones que contienen @code{abs}:

@example
(%i5) abs(x^2);
                                2
(%o5)                          x
(%i6) abs(x^3);
                             2
(%o6)                       x  abs(x)

(%i7) abs(abs(x));
(%o7)                       abs(x)
(%i8) abs(conjugate(x));
(%o8)                       abs(x)
@end example

Integrando y derivando con la función @code{abs}. Nótese que se pueden
calcular más integrales que involucren la función @code{abs} si se
carga el paquete @code{abs_integrate}. El último ejemplo muestra la
transformada de Laplace de @code{abs}. Véase @code{laplace}.

@example
(%i9) diff(x*abs(x),x),expand;
(%o9)                       2 abs(x)

(%i10) integrate(abs(x),x);
                             x abs(x)
(%o10)                       --------
                                2

(%i11) integrate(x*abs(x),x);
                           /
                           [
(%o11)                     I x abs(x) dx
                           ]
                           /

(%i12) load(abs_integrate)$
(%i13) integrate(x*abs(x),x);
                      2           3
                     x  abs(x)   x  signum(x)
(%o13)               --------- - ------------
                         2            6

(%i14) integrate(abs(x),x,-2,%pi);
                               2
                            %pi
(%o14)                      ---- + 2
                             2

(%i15) laplace(abs(x),x,s);
                               1
(%o15)                         --
                                2
                               s
@end example
@end deffn



@deffn {Función} ceiling (@var{x})
Si @var{x} es un número real, devuelve el menor entero mayor o igual que @var{x}.  

Si @var{x} es una expresión constante (por ejemplo, @code{10 * %pi}), 
@code{ceiling} evalúa @var{x} haciendo uso de números grandes en coma flotante (big floats), aplicando a continuación
 @code{ceiling} al número decimal obtenido. Puesto que @code{ceiling} hace evaluaciones en coma flotante, es posible, pero improbable, que esta función devuelva un valor erróneo para entradas constantes. Para evitar estos errores, la evaluación en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{ceiling} intenta devolver un valor simplificado. Aquí se presentan algunos ejemplos sobre las simplificaciones que @code{ceiling} es capaz de hacer:

@c ===beg===
@c ceiling (ceiling (x));
@c ceiling (floor (x));
@c declare (n, integer)$
@c [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
@c assume (x > 0, x < 1)$
@c ceiling (x);
@c tex (ceiling (a));
@c ===end===
@example
(%i1) ceiling (ceiling (x));
(%o1)                      ceiling(x)
(%i2) ceiling (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [ceiling (n), ceiling (abs (n)), ceiling (max (n, 6))];
(%o4)                [n, abs(n), max(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) ceiling (x);
(%o6)                           1
(%i7) tex (ceiling (a));
$$\left \lceil a \right \rceil$$
(%o7)                                false
@end example

La función @code{ceiling} no se extiende automáticamente a los elementos de listas y matrices.
Por último, para todos los argumentos que tengan una forma compleja, @code{ceiling} devuelve una forma nominal.

Si el rango de una función es subconjunto de los números enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta información; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

Ejemplo de uso:

@c ===beg===
@c unitfrac(r) := block([uf : [], q],
@c     if not(ratnump(r)) then 
@c        error("unitfrac: argument must be a rational number"),
@c     while r # 0 do (
@c         uf : cons(q : 1/ceiling(1/r), uf),
@c         r : r - q),
@c     reverse(uf));
@c unitfrac (9/10);
@c apply ("+", %);
@c unitfrac (-9/10);
@c apply ("+", %);
@c unitfrac (36/37);
@c apply ("+", %);
@c ===end===
@example
@group
(%i1) unitfrac(r) := block([uf : [], q],
    if not(ratnump(r)) then
       error("unitfrac: argument must be a rational number"),
    while r # 0 do (
        uf : cons(q : 1/ceiling(1/r), uf),
        r : r - q),
    reverse(uf))$
@end group
(%i2) unitfrac (9/10);
                            1  1  1
(%o2)                      [-, -, --]
                            2  3  15
(%i3) apply ("+", %);
                               9
(%o3)                          --
                               10
(%i4) unitfrac (-9/10);
                                  1
(%o4)                       [- 1, --]
                                  10
(%i5) apply ("+", %);
                                9
(%o5)                         - --
                                10
(%i6) unitfrac (36/37);
                        1  1  1  1    1
(%o6)                  [-, -, -, --, ----]
                        2  3  8  69  6808
(%i7) apply ("+", %);
                               36
(%o7)                          --
                               37
@end example
@end deffn



@deffn {Función} entier (@var{x})
Devuelve el mayor entero menor o igual a @var{x}, siendo @var{x} numérico. La función  @code{fix} (como en
@code{fixnum}) es un sinónimo, de modo que @code{fix(@var{x})} hace justamente lo mismo.

@end deffn



@deffn {Función} floor (@var{x})

Si @var{x} es un número real, devuelve el mayor entero menor o igual que @var{x}.

Si @var{x} es una expresión constante (por ejemplo, @code{10 * %pi}), 
@code{floor} evalúa @var{x} haciendo uso de números grandes en coma flotante (big floats), aplicando a continuación
 @code{floor} al número decimal obtenido. Puesto que @code{floor} hace evaluaciones en coma flotante, es posible, pero improbable, que esta función devuelva un valor erróneo para entradas constantes. Para evitar estos errores, la evaluación en punto flotante se lleva a cabo utilizando tres valores para @code{fpprec}.

Para argumentos no constantes, @code{floor} intenta devolver un valor simplificado. Aquí se presentan algunos ejemplos sobre las simplificaciones que @code{floor} es capaz de hacer:

@c ===beg===
@c floor (ceiling (x));
@c floor (floor (x));
@c declare (n, integer)$
@c [floor (n), floor (abs (n)), floor (min (n, 6))];
@c assume (x > 0, x < 1)$
@c floor (x);
@c tex (floor (a));
@c ===end===
@example
(%i1) floor (ceiling (x));
(%o1)                      ceiling(x)
(%i2) floor (floor (x));
(%o2)                       floor(x)
(%i3) declare (n, integer)$
(%i4) [floor (n), floor (abs (n)), floor (min (n, 6))];
(%o4)                [n, abs(n), min(n, 6)]
(%i5) assume (x > 0, x < 1)$
(%i6) floor (x);
(%o6)                           0
(%i7) tex (floor (a));
$$\left \lfloor a \right \rfloor$$
(%o7)                         false
@end example

La función @code{floor} no se extiende automáticamente a los elementos de listas y matrices.
Por último, para todos los argumentos que tengan una forma compleja, @code{floor} devuelve una forma nominal.

Si el rango de una función es subconjunto de los números enteros, entonces puede ser declarada como @code{integervalued}. Tanto @code{ceiling} como @code{floor} son funciones que hacen uso de esta información; por ejemplo:

@c ===beg===
@c declare (f, integervalued)$
@c floor (f(x));
@c ceiling (f(x) - 1);
@c ===end===
@example
(%i1) declare (f, integervalued)$
(%i2) floor (f(x));
(%o2)                         f(x)
(%i3) ceiling (f(x) - 1);
(%o3)                       f(x) - 1
@end example

@end deffn


@deffn {Función} fix (@var{x})
Es un sinónimo de  @code{entier (@var{x})}.

@end deffn



@deffn {Función} lmax (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('max, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, envía un mensaje de error.
@end deffn



@deffn {Función} lmin (@var{L})

Si @var{L} es una lista o conjunto, devuelve @code{apply ('min, args (@var{L}))}.  Si @var{L} no es una lista o conjunto, envía un mensaje de error.
@end deffn



@deffn {Función} max (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la mayor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o más, @code{max} aplica la simplificación 
@code{max (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o más, @var{max} intenta
eliminar las expresiones que estén entre otros dos de los argumentos dados; por ejemplo,
@code{max (x, 2*x, 3*x) --> max (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn

@deffn {Función} min (@var{x_1}, ..., @var{x_n})
Devuelve un valor simplificado de la menor de las expresiones desde @var{x_1} hasta @var{x_n}.
Si @code{get (trylevel, maxmin)} es 2 o más, @code{min} aplica la simplificación 
@code{min (e, -e) --> |e|}.  Si @code{get (trylevel, maxmin)} es 3 o más, @var{min} intenta
eliminar las expresiones que estén entre otros dos de los argumentos dados; por ejemplo,
@code{min (x, 2*x, 3*x) --> min (x, 3*x)}. Para asignar el valor 2 a @code{trylevel} se puede hacer
@code{put (trylevel, 2, maxmin)}.

@end deffn



@deffn {Función} round (@var{x})
Si @var{x} es un número real, la función devuelve el entero más 
próximo a @var{x}. Los múltiplos de 1/2 se redondean al entero par más próximo.
La evaluación de @var{x} es similar a @code{floor} y @code{ceiling}.

@end deffn



@deffn {Función} signum (@var{x})
Tanto sea @var{x} real o complejo, la función @code{signum} devuelve 0 si @var{x}
es cero. Para un valor no nulo de @var{x}, la función devuelve @code{x/abs(x)}.

Para valores no numéricos de @var{x}, Maxima intenta determinar el
signo del argumento. Cuando es negativo, cero o positivo, @code{signum}
devuelve -1, 0 o 1, respectivamente. En caso de no poder determinarse,
@code{signum} devuelve una forma simplificada equivalente. Estas 
simplificaciones incluyen la transformación de @code{signum(-x)}
en @code{-signum(x)} y la de @code{signum(x*y)} en
@code{signum(x) * signum(y)}.

La función @code{signum} es distributiva respecto de listas,
matrices o ecuaciones. Véase @code{distribute_over}.

@end deffn








@node Funciones para los números complejos, Funciones combinatorias, Funciones para los números, Funciones matemáticas
@section Funciones para los números complejos


@deffn {Función} cabs (@var{expr})
Calcula el valor absoluto de una expresión que representa a un número
complejo. Al contrario que @code{abs}, la función @code{cabs} siempre
descompone su argumento en sus partes real e imaginaria. Si @code{x} e
@code{y} representan variables o expresiones reales, la función @code{cabs}
calcula el valor absoluto de @code{x + %i*y} como
@example
                           2    2
                     sqrt(y  + x )
@end example

La función @code{cabs} puede utilizar propiedades como la simetría
de funciones complejas para calcular el valor absoluto de una expresión.

@code{cabs} no es una función apropiada para cálculos simbólicos; en tales
casos, que incluyen la integración, diferenciación y límites que
contienen valores absolutos, es mejor utilizar @code{abs}.

El resultado devuelto por @code{cabs} puede incluir la función de valor absoluto,
@code{abs}, y el arco tangente, @code{atan2}.

Cuando se aplica a una lista o matriz, @code{cabs} automáticamente se distribuye
sobre sus elementos. También se distribuye sobre los dos miembros de una 
igualdad.

Para otras formas de operar con números complejos, véanse las funciones
@code{rectform}, @code{realpart}, @code{imagpart}, @code{carg}, @code{conjugate}
y @code{polarform}.

Ejemplos:

Ejemplos con @code{sqrt} and @code{sin}:

@example
(%i1) cabs(sqrt(1+%i*x));
                             2     1/4
(%o1)                      (x  + 1)
(%i2) cabs(sin(x+%i*y));
                    2        2         2        2
(%o2)       sqrt(cos (x) sinh (y) + sin (x) cosh (y))
@end example

La simetría especular de la función de error @code{erf} se utiliza
para calcular el valor absoluto del argumento complejo:

@example
(%i3) cabs(erf(x+%i*y));
                                          2
           (erf(%i y + x) - erf(%i y - x))
(%o3) sqrt(--------------------------------
                          4
                                                               2
                                (erf(%i y + x) + erf(%i y - x))
                              - --------------------------------)
                                               4
@end example

Dado que Maxima reconoce algunas identidades complejas de las funciones de
Bessel, le permite calcular su valor absoluto cuando tiene argumentos 
complejos. Un ejemplo para @code{bessel_j}:

@example
(%i4) cabs(bessel_j(1,%i));
(%o4)                 abs(bessel_j(1, %i))
@end example
@end deffn




@deffn {Función} carg (@var{z})
Devuelve el argumento complejo de @var{z}.
El argumento complejo es un ángulo @code{theta} en @code{(-%pi, %pi]}
tal que @code{r exp (theta %i) = @var{z}} donde @code{r} es la magnitud de @var{z}.

La función @code{carg} es computacional, no simplificativa.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT

Véanse también @code{abs} (módulo complejo), @code{polarform}, @code{rectform},
@code{realpart} y @code{imagpart}.

Ejemplos:

@c ===beg===
@c carg (1);
@c carg (1 + %i);
@c carg (exp (%i));
@c carg (exp (%pi * %i));
@c carg (exp (3/2 * %pi * %i));
@c carg (17 * exp (2 * %i));
@c ===end===

@example
(%i1) carg (1);
(%o1)                           0
(%i2) carg (1 + %i);
                               %pi
(%o2)                          ---
                                4
(%i3) carg (exp (%i));
(%o3)                           1
(%i4) carg (exp (%pi * %i));
(%o4)                          %pi
(%i5) carg (exp (3/2 * %pi * %i));
                                %pi
(%o5)                         - ---
                                 2
(%i6) carg (17 * exp (2 * %i));
(%o6)                           2
@end example

@end deffn



@deffn {Función} conjugate (@var{x})
Devuelve el conjugado complejo de @var{x}.

@c ===beg===
@c declare ([aa, bb], real, cc, complex, ii, imaginary);
@c conjugate (aa + bb*%i);
@c conjugate (cc);
@c conjugate (ii);
@c conjugate (xx + yy);
@c ===end===
@example
(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
@end example

@end deffn



@deffn {Función} imagpart (@var{expr})
Devuelve la parte imaginaria de la expresión @var{expr}.

La función @code{imagpart} es computacional,
no simplificativa.
@c PROBABLY NEED TO EXPLAIN IMPLICATIONS OF ABOVE STATEMENT
@c SEE ALSO SF BUG REPORT # 902290

Véanse también @code{abs}, @code{carg}, @code{polarform}, @code{rectform} y @code{realpart}.

@c NEED EXAMPLES HERE
@end deffn



@c NEEDS EXAMPLES
@deffn {Función} polarform (@var{expr})
Devuelve una expresión de la forma @code{r %e^(%i theta)} equivalente a @var{expr},
con @code{r} y @code{theta} son reales.

@end deffn




@c NEEDS EXAMPLES
@deffn {Función} realpart (@var{expr})
Devuelve la parte real de @var{expr}. La funciones @code{realpart} y @code{imagpart} operan también con expresiones que contengan funciones trigonométricas e hiperbólicas, raíces cuadradas, logaritmos y exponentes.

@end deffn

@c NEEDS EXAMPLES
@deffn {Función} rectform (@var{expr})
Devuelve una expresión de la forma @code{a + b %i} equivalente a @var{expr}, con @var{a} y @var{b} reales.

@end deffn







@node Funciones combinatorias, Funciones radicales exponenciales y logarítmicas, Funciones para los números complejos, Funciones matemáticas
@section Funciones combinatorias



@deffn {Operador} !!
@ifinfo
@fnindex Doble factorial
@end ifinfo
El operador doble factorial.

Para un número entero, de punto flotante o racional @code{n},
@code{n!!} se evaluará como el producto de @code{n (n-2) (n-4) (n-6) ... (n - 2 (k-1))}
donde @code{k} es igual a @code{entier(n/2)}, que es, el mayor entero
menor o igual a @code{n/2}. 
Note que esta definición no coincide con otras definciones publicadas para argumentos, los cuales no son enteros. 

@c REPORTED TO BUG TRACKER AS BUG # 1093138 !!!

Para un entero par (o impar) @code{n}, @code{n!} se evalua el producto de
todos los enteros pares (o impares) consecutivos desde 2 (o 1) por @code{n} inclusive.  

Para un argumento @code{n} el cual no es un número entero, punto flotante o racional, @code{n!!} produce una forma de nombre @code{genfact (n, n/2, 2)}. 

@c n!! IS NEITHER SIMPLIFIED NOR EVALUATED IN THIS CASE -- MENTION THAT? OR TOO MUCH DETAIL ???

@end deffn




@deffn {Función} binomial (@var{x}, @var{y})
Es el coeficiente binomial @code{@var{x}!/(@var{y}! (@var{x} - @var{y})!)}.
Si @var{x} y @var{y} son enteros, entonces se calcula el valor numérico 
del coeficiente binomial. Si @var{y} o @var{x - y} son enteros, 
el coeficiente binomial se expresa como un polinomio.

Ejemplos:

@c ===beg===
@c binomial (11, 7);
@c 11! / 7! / (11 - 7)!;
@c binomial (x, 7);
@c binomial (x + 7, x);
@c binomial (11, y);
@c ===end===
@example
(%i1) binomial (11, 7);
(%o1)                          330
(%i2) 11! / 7! / (11 - 7)!;
(%o2)                          330
(%i3) binomial (x, 7);
        (x - 6) (x - 5) (x - 4) (x - 3) (x - 2) (x - 1) x
(%o3)   -------------------------------------------------
                              5040
(%i4) binomial (x + 7, x);
      (x + 1) (x + 2) (x + 3) (x + 4) (x + 5) (x + 6) (x + 7)
(%o4) -------------------------------------------------------
                               5040
(%i5) binomial (11, y);
(%o5)                    binomial(11, y)
@end example
@end deffn



@deffn {Función} factcomb (@var{expr})
Trata de combinar los coeficientes de los factoriales de @var{expr} con los mismos factoriales, convirtiendo, por ejemplo, @code{(n + 1)*n!} en @code{(n + 1)!}.

Si la variable @code{sumsplitfact} vale @code{false} hará que @code{minfactorial} se aplique después de @code{factcomb}.

@end deffn



@deffn {Función} factorial (@var{x})
@deffnx {Operador} !

Representa la función factorial. Maxima considera @code{factorial (@var{x})}
y @code{@var{x}!} como sinónimos.

Para cualquier número complejo @code{x}, excepto para
enteros negativos, @code{x!} se define como @code{gamma(x+1)}. 

Para un entero @code{x}, @code{x!} se reduce al producto de los enteros
desde 1 hasta @code{x} inclusive. @code{0!} se reduce a 1.
Para un número real o complejo en formato de coma flotante @code{x}, 
@code{x!} se reduce al valor de @code{gamma(x+1)}. Cuando
@code{x} es igual a @code{n/2}, siendo @code{n} un entero impar, entonces
@code{x!} se reduce a un factor racional multiplicado por @code{sqrt(%pi)}
(pues @code{gamma(1/2)}) es igual a @code{sqrt(%pi)}).

Las variables opcionales @code{factlim} y @code{gammalim} controlan la
evaluación numérica de factoriales de argumentos enteros y racionales.

Las funciones @code{minfactorial} y @code{factcomb} simplifican expresiones
que contiene factoriales.

Véanse también @code{factlim}, @code{gammalim}, @code{minfactorial} y 
@code{factcomb}.

Las funciones @code{gamma}, @code{bffac} y @code{cbffac} son variaciones de
la función matemática gamma. Las funciones @code{bffac} y @code{cbffac} 
son llamadas internamente desde @code{gamma} para evaluar la función gamma 
de números reales y complejos decimales con precisión de reales grandes
(bigfloats).

Las funciones @code{makegamma} substituye a @code{gamma} para factoriales 
y funciones relacionadas. 

Maxima reconoce la derivada de la función factorial y los límites
para ciertos valores específicos, tales como los enteros negativos.

La variable opcional @code{factorial_expand} controla la simplificación de
expresiones como @code{(n+x)!}, para @code{n} entero.

Véase también @code{binomial}.

Ejemplos:

El factorial de un entero se reduce a un número exacto, a menos que
el argumento sea mayor que @code{factlim}. Los factoriales de números
reales o complejos se evalúan como decimales de coma flotante.

@c ===beg===
@c factlim : 10;
@c [0!, (7/2)!, 8!, 20!];
@c [4,77!, (1.0+%i)!];
@c [2.86b0!, 1.0b0+%i)!];
@c ===end===
@example
(%i1) factlim:10;
(%o1)                                 10
(%i2) [0!, (7/2)!, 8!, 20!];
                            105 sqrt(%pi)
(%o2)                   [1, -------------, 40320, 20!]
                                 16
(%i3) [4.77!, (1.0+%i)!];
(%o3)    [81.44668037931197, 
          .3430658398165454 %i + .6529654964201665]
(%i4) [2.86b0!, (1.0b0+%i)!];
(%o4) [5.046635586910012b0, 
       3.430658398165454b-1 %i + 6.529654964201667b-1]
@end example

El factorial de una constante conocida o de una expresión general
no se calcula. Pero puede ser posible reducir el factorial después de
evaluado el argumento.

@c ===beg===
@c [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
@c ev (%, numer, %enumer);
@c ===end===
@example
(%i1) [(%i + 1)!, %pi!, %e!, (cos(1) + sin(1))!];
(%o1)      [(%i + 1)!, %pi!, %e!, (sin(1) + cos(1))!]
(%i2) ev (%, numer, %enumer);
(%o2) [.3430658398165454 %i + .6529654964201665, 
       7.188082728976031, 
       4.260820476357003, 1.227580202486819]
@end example

Los factoriales son simplificados o reducidos, no evaluados.
Así @code{x!} puede ser reemplazado en una expresión 
nominal. 

@c ===beg===
@c '([0!, (7/2)!, 4.77!, 8!, 20!]);
@c ===end===
@example
(%i1) '([0!, (7/2)!, 4.77!, 8!, 20!]);
          105 sqrt(%pi)
(%o1) [1, -------------, 81.44668037931199, 40320, 
               16
                             2432902008176640000]
@end example

Maxima reconoce la derivada de la función factorial.

@c ===beg===
@c diff(x!,x);
@c ===end===
@example
(%i1) diff(x!,x);
(%o1)                           x! psi (x + 1)
                                      0
@end example

La variable opcional @code{factorial_expand} controla la simplificación de
expresiones con la función factorial.

@c ===beg===
@c (n+1)!/n!,factorial_expand:true;
@c ===end===
@example
(%i1) (n+1)!/n!,factorial_expand:true;
(%o1)                                n + 1
@end example
@end deffn



@defvr {Variable opcional} factlim
Valor por defecto: -1

La variable @code{factlim} especifica el mayor factorial que será expandido automáticamente.  Si su valor es -1, entonces se expandirán todos los enteros.

@end defvr



@defvr {Variable opcional} factorial_expand
Valor por defecto: false

La variable @code{factorial_expand} controla la simplificación
de expresiones tales como @code{(n+1)!}, siendo @code{n} un entero. 

Véase @code{!} para un ejemplo.

@end defvr



@c IS THIS DEFINITION CORRECT ??
@deffn {Función} genfact (@var{x}, @var{y}, @var{z})
Devuelve el factorial generalizado, definido como
@code{x (x-z) (x - 2 z) ... (x - (y - 1) z)}.  Así, para el entero @var{x},
@code{genfact (x, x, 1) = x!} y @code{genfact (x, x/2, 2) = x!!}.

@end deffn



@deffn {Función} minfactorial (@var{expr})

Busca en @var{expr} la presencia de dos factoriales que solo se
diferencien en una unidad; en tal caso, @code{minfactorial}
devuelve una expresión simplificada.

@example
(%i1) n!/(n+2)!;
                               n!
(%o1)                       --------
                            (n + 2)!
(%i2) minfactorial (%);
                                1
(%o2)                    ---------------
                         (n + 1) (n + 2)
@end example

@end deffn


@defvr {Variable opcional} sumsplitfact
Valor por defecto: @code{true}

Si @code{sumsplitfact} vale @code{false},
@c "IS APPLIED" -- UNDER WHAT CIRCUMSTANCES EXACTLY ??
@code{minfactorial} se aplica después de  @code{factcomb}.

@end defvr









@node Funciones radicales exponenciales y logarítmicas, Funciones trigonométricas, Funciones combinatorias, Funciones matemáticas
@section Funciones radicales, exponenciales y logarítmicas


@defvr {Variable opcional} %e_to_numlog
Valor por defecto: @code{false}

Si @code{%e_to_numlog} vale @code{true}, @code{r} es un número racional y @code{x} una expresión, @code{%e^(r*log(x))} se reduce a @code{x^r} .  Téngase en cuenta que la instrucción @code{radcan} también hace este tipo de transformaciones, así como otras más complicadas. La instrucción @code{logcontract} "contrae" expresiones que contienen algún @code{log}.
@end defvr


@defvr {Variable opcional} %emode
Valor por defecto: @code{true}

Si @code{%emode} vale @code{true},
@code{%e^(%pi %i x)} se simplifica como sigue.

@code{%e^(%pi %i x)} se simplifica a @code{cos (%pi x) + %i sin (%pi x)} si @code{x} es
un número decimal de coma flotante, un entero o un múltiplo de 1/2, 1/3, 1/4 o 1/6, y luego se sigue simplificando.

Para otros valores numéricos de @code{x},
@code{%e^(%pi %i x)} se simplifica a @code{%e^(%pi %i y)} donde @code{y} es @code{x - 2 k}
para algún entero @code{k} tal que @code{abs(y) < 1}.  

Si @code{%emode} vale @code{false}, no se realizan simplificaciones especiales a @code{%e^(%pi %i x)}.

@c NEED EXAMPLES HERE
@end defvr


@defvr {Variable opcional} %enumer
Valor por defecto: @code{false}

Si la variable @code{%enumer} vale @code{true} hace que @code{%e} se reemplace por
2.718...  siempre que @code{numer} valga @code{true}. 

Si @code{%enumer} vale @code{false}, esta sustitución se realiza sólo si el exponente en @code{%e^x} tiene un valor numérico.

Véanse también @code{ev} y @code{numer}.

@c NEED EXAMPLES HERE
@end defvr




@deffn {Función} exp (@var{x})
Representa la función exponencial.  
La expresión  @code{exp (@var{x})} en la entrada se simplifica en @code{%e^@var{x}};
@code{exp} no aparece en expresiones simplificadas.

Si la variable @code{demoivre} vale @code{true} hace que @code{%e^(a + b %i)} se simplifique a
@code{%e^(a (cos(b) + %i sin(b)))} si @code{b} no contiene a @code{%i}. Véase @code{demoivre}.

Si la variable @code{%emode} vale @code{true}, 
hace que  @code{%e^(%pi %i x)} se simplifique. Véase @code{%emode}.

Si la variable @code{%enumer} vale @code{true} hace que @code{%e} se reemplace por
2.718...  siempre que @code{numer} valga @code{true}. Véase @code{%enumer}.

@end deffn



@deffn {Función} li [@var{s}] (@var{z})

Representa la función polilogarítmica de orden @var{s} y argumento @var{z},
definida por la serie infinita

@tex
$${\rm Li}_s \left(z\right) = \sum_{k=1}^\infty {z^k \over k^s}$$
@end tex
@ifnottex
@example
                                 inf
                                 ====   k
                                 \     z
                        Li (z) =  >    --
                          s      /      s
                                 ====  k
                                 k = 1
@end example
@end ifnottex

@code{li [1]} es @code{- log (1 - z)}.
@code{li [2]} y @code{li [3]} son las funciones di- y trilogaritmo, respectivamente.

Cuando el orden es 1, el polilogaritmo se simplifica a @code{- log (1 - z)},
el cual a su vez se reduce a un valor numérico si @var{z} es un número
real o complejo en coma flotante o si está presente el término @code{numer}.

Cuando el orden es 2 ó 3,
el polilogaritmo se reduce a un valor numérico si @var{z} es
un número real en coma flotante o si está presente el término @code{numer}.

Ejemplos:

@c ===beg===
@c assume (x > 0);
@c integrate ((log (1 - t)) / t, t, 0, x);
@c li [2] (7);
@c li [2] (7), numer;
@c li [3] (7);
@c li [2] (7), numer;
@c L : makelist (i / 4.0, i, 0, 8);
@c map (lambda ([x], li [2] (x)), L);
@c map (lambda ([x], li [3] (x)), L);
@c ===end===
@example
(%i1) assume (x > 0);
(%o1)                        [x > 0]
(%i2) integrate ((log (1 - t)) / t, t, 0, x);
(%o2)                       - li (x)
                                2
(%i3) li [2] (7);
(%o3)                        li (7)
                               2
(%i4) li [2] (7), numer;
(%o4)        1.24827317833392 - 6.113257021832577 %i
(%i5) li [3] (7);
(%o5)                        li (7)
                               3
(%i6) li [2] (7), numer;
(%o6)        1.24827317833392 - 6.113257021832577 %i
(%i7) L : makelist (i / 4.0, i, 0, 8);
(%o7)   [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0]
(%i8) map (lambda ([x], li [2] (x)), L);
(%o8) [0, .2676526384986274, .5822405249432515, 
.9784693966661848, 1.64493407, 2.190177004178597
 - .7010261407036192 %i, 2.374395264042415
 - 1.273806203464065 %i, 2.448686757245154
 - 1.758084846201883 %i, 2.467401098097648
 - 2.177586087815347 %i]
(%i9) map (lambda ([x], li [3] (x)), L);
(%o9) [0, .2584613953442624, 0.537213192678042, 
.8444258046482203, 1.2020569, 1.642866878950322
 - .07821473130035025 %i, 2.060877505514697
 - .2582419849982037 %i, 2.433418896388322
 - .4919260182322965 %i, 2.762071904015935
 - .7546938285978846 %i]
@end example

@end deffn




@deffn {Función} log (@var{x})
Representa el logaritmo natural (en base @math{e}) de @var{x}.

Maxima no tiene definida una función para el logaritmo de base 10 u
otras bases. El usuario puede hacer uso de la definición 
@code{log10(x) := log(x) / log(10)}.

La simplificación y evaluación de logaritmos se controla con
ciertas variables globales:

@table @code
@item @code{logexpand}
hace que @code{log(a^b)} se convierta en @code{b*log(a)}.
Si toma el valor @code{all}, @code{log(a*b)} también se reducirá a  @code{log(a)+log(b)}.
Si toma el valor @code{super}, entonces @code{log(a/b)} también se reducirá a
@code{log(a)-log(b)}, siendo @code{a/b} racional con @code{a#1}, 
(la expresión @code{log(1/b)}, para @code{b} entero, se simplifica siempre). 
Si toma el valor  @code{false}, se desactivarán todas estas simplificaciones.

@item @code{logsimp}
si vale @code{false}, entonces no se transforma @code{%e} a potencias que contengan logaritmos.

@item @code{lognegint}
si vale @code{true} se aplica la regla @code{log(-n)} -> @code{log(n)+%i*%pi},
siendo @code{n} un entero positivo.

@item @code{%e_to_numlog}
si vale @code{true}, @code{r} es un número racional y @code{x} una expresión,
@code{%e^(r*log(x))} se reduce a @code{x^r}. Téngase en cuenta que la 
instrucción @code{radcan} también hace este tipo de transformaciones, 
así como otras más complicadas. La instrucción @code{logcontract}
"contrae" expresiones que contengan algún @code{log}.
@end table

@end deffn



@defvr {Variable opcional} logabs
Valor por defecto: @code{false}

Cuando se calculan integrales indefinidas en las que se generan logaritmos, como en @code{integrate(1/x,x)}, el resultado se devuelve de la forma  @code{log(abs(...))} si @code{logabs} vale @code{true}, o de la forma @code{log(...)} si
@code{logabs} vale @code{false}. En la integración definida se hace la asignación @code{logabs:true}, ya que aquí es normalmente necesario evaluar la integral indefinida en los extremos del intervalo de integración.

@end defvr

@c NEEDS EXAMPLES
@defvr {Variable opcional} logarc
@defvrx {Función} logarc (@var{expr})

Si la variable global @code{logarc} toma el valor @code{true},
las funciones circulares e hiperbólicas inversas se 
reemplazan por funciones logarítmicas equivalentes.
El valor por defecto de @code{logarc} es @code{false}.

La función @code{logarc(@var{expr})} realiza la anterior transformación
en la expresión @var{expr} sin necesidad de alterar el valor de la
variable global @code{logarc}.

@end defvr



@defvr {Variable opcional} logconcoeffp
Valor por defecto: @code{false}

Controla qué coeficientes se contraen cuando se utiliza @code{logcontract}. Se le puede asignar el nombre de una función de predicado de un argumento; por ejemplo, si se quiere introducir raíces cuadradas, se puede hacer @code{logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Entonces 
@code{logcontract(1/2*log(x));} devolverá @code{log(sqrt(x))}.

@end defvr

@deffn {Función} logcontract (@var{expr})
Analiza la expresión @var{expr} recursivamente, transformando subexpresiones de la forma @code{a1*log(b1) + a2*log(b2) + c} en @code{log(ratsimp(b1^a1 * b2^a2)) + c}

@c ===beg===
@c 2*(a*log(x) + 2*a*log(y))$
@c logcontract(%);
@c ===end===
@example
(%i1) 2*(a*log(x) + 2*a*log(y))$
(%i2) logcontract(%);
                                 2  4
(%o2)                     a log(x  y )

@end example

Si se hace @code{declare(n,integer);} entonces @code{logcontract(2*a*n*log(x));} da
@code{a*log(x^(2*n))}.  Los coeficientes que se contraen de esta manera son aquellos que como el 2 y el @code{n} satisfacen 
@code{featurep(coeff,integer)}. El usuario puede controlar qué coeficientes se contraen asignándole a la variable global @code{logconcoeffp} el nombre de una función de predicado de un argumento; por ejemplo, si se quiere introducir raíces cuadradas, se puede hacer @code{logconcoeffp:'logconfun$ logconfun(m):=featurep(m,integer) or ratnump(m)$} .  Entonces @code{logcontract(1/2*log(x));} devolverá @code{log(sqrt(x))}.

@end deffn


@defvr {Variable opcional} logexpand
Valor por defecto: @code{true}

Si @code{logexpand} vale @code{true} hace que @code{log(a^b)} se convierta
en @code{b*log(a)}. Si toma el valor @code{all}, @code{log(a*b)} también se
reducirá a  @code{log(a)+log(b)}. Si toma el valor @code{super}, entonces 
@code{log(a/b)} también se reducirá a @code{log(a)-log(b)}, siendo 
@code{a/b} racional con @code{a#1},  (la expresión @code{log(1/b)}, para
@code{b} entero, se simplifica siempre). Si toma el valor  @code{false},
se desactivarán todas estas simplificaciones.
@end defvr



@defvr {Variable opcional} lognegint
Valor por defecto: @code{false}

Si @code{lognegint} vale @code{true} se aplica la regla @code{log(-n)} -> @code{log(n)+%i*%pi} siendo @code{n} un entero positivo.

@end defvr



@defvr {Variable opcional} logsimp
Valor por defecto: @code{true}

Si @code{logsimp} vale @code{false}, entonces no se transforma @code{%e} a potencias que contengan logaritmos.

@end defvr



@deffn {Función} plog (@var{x})
Representa la rama principal del logaritmo natural complejo con @code{-%pi} < @code{carg(@var{x})} <= @code{+%pi} .

@end deffn



@deffn {Función} sqrt (@var{x})
Raíz cuadrada de @var{x}. Se representa internamente por @code{@var{x}^(1/2)}.  Véase también @code{rootscontract}.

Si la variable @code{radexpand} vale @code{true} hará que las raíces @code{n}-ésimas de los factores de un producto que sean potencias de @code{n} sean extraídas del radical; por ejemplo, @code{sqrt(16*x^2)} se convertirá en @code{4*x} sólo si @code{radexpand} vale @code{true}.

@end deffn









@node Funciones trigonométricas, Números aleatorios, Funciones radicales exponenciales y logarítmicas, Funciones matemáticas
@section Funciones trigonométricas


@menu
* Introducción a la trigonometría::  
* Funciones y variables para trigonometría:: 
@end menu


@node Introducción a la trigonometría, Funciones y variables para trigonometría, Funciones trigonométricas, Funciones trigonométricas
@subsection Introducción a la trigonometría


Maxima reconoce muchas funciones trigonométricas. No están programadas todas las identidades trigonométricas, pero el usuario puede añadir muchas de ellas haciendo uso de las técnicas basadas en patrones.  Las funciones trigonométricas definidas en Maxima son:  @code{acos},
@code{acosh}, @code{acot}, @code{acoth}, @code{acsc},
@code{acsch}, @code{asec}, @code{asech}, @code{asin}, 
@code{asinh}, @code{atan}, @code{atanh}, @code{cos}, 
@code{cosh}, @code{cot}, @code{coth}, @code{csc}, @code{csch}, 
@code{sec}, @code{sech}, @code{sin}, @code{sinh}, @code{tan} y 
@code{tanh}. Hay también un determinado número de instrucciones especiales para manipular funciones trigonométricas;  véanse a este respecto @code{trigexpand},
@code{trigreduce} y la variable @code{trigsign}.  Dos paquetes adicionales amplían las reglas de simplificación de Maxima, @code{ntrig} y @code{atrig1}.  Ejecútese @code{describe(@var{command})} para más detalles.








@node Funciones y variables para trigonometría,  , Introducción a la trigonometría, Funciones trigonométricas
@subsection Funciones y variables para trigonometría




@defvr {Variable opcional} %piargs
Valor por defecto: @code{true}

Cuando @code{%piargs} vale @code{true}, las funciones trigonométricas
se simplifican a constantes algebraicas cuando el argumento es múltiplo
entero de 
@iftex
@math{\pi}, @math{\pi/2}, @math{\pi/3}, @math{\pi/4} o @math{\pi/6}.
@end iftex
@ifnottex
@math{%pi}, @math{%pi/2}, @math{%pi/3}, @math{%pi/4} o @math{%pi/6}.
@end ifnottex

@iftex
Maxima conoce algunas identidades aplicables cuando @math{\pi}, etc.,
@end iftex
@ifnottex
Maxima conoce algunas identidades aplicables cuando @math{%pi}, etc.,
@end ifnottex
se multiplican por una variable entera (esto es, un símbolo
declarado como entero).

Ejemplo:

@c ===beg===
@c %piargs : false$
@c [sin (%pi), sin (%pi/2), sin (%pi/3)];
@c [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
@c %piargs : true$
@c [sin (%pi), sin (%pi/2), sin (%pi/3)];
@c [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
@c [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
@c        cos (sqrt(2)*%pi/3)];
@c ===end===
@example
(%i1) %piargs : false$
@group
(%i2) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                %pi       %pi
(%o2)            [sin(%pi), sin(---), sin(---)]
                                 2         3
@end group
@group
(%i3) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                      %pi       %pi       %pi
(%o3)            [sin(---), sin(---), sin(---)]
                       4         5         6
@end group
(%i4) %piargs : true$
@group
(%i5) [sin (%pi), sin (%pi/2), sin (%pi/3)];
                                sqrt(3)
(%o5)                    [0, 1, -------]
                                   2
@end group
@group
(%i6) [sin (%pi/4), sin (%pi/5), sin (%pi/6)];
                         1         %pi   1
(%o6)                [-------, sin(---), -]
                      sqrt(2)       5    2
@end group
@group
(%i7) [cos (%pi/3), cos (10*%pi/3), tan (10*%pi/3),
       cos (sqrt(2)*%pi/3)];
                1    1               sqrt(2) %pi
(%o7)          [-, - -, sqrt(3), cos(-----------)]
                2    2                    3
@end group
@end example


@iftex
Se aplican ciertas identidades cuando @math{\pi} o @math{\pi/2} se multiplican por una variable entera.
@end iftex
@ifnottex
Se aplican ciertas identidades cuando @math{%pi} o @math{%pi/2} se multiplican por una variable entera.
@end ifnottex

@c ===beg===
@c declare (n, integer, m, even)$
@c [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
@c        cos (%pi/2 * m)];
@c ===end===
@example
(%i1) declare (n, integer, m, even)$
@group
(%i2) [sin (%pi * n), cos (%pi * m), sin (%pi/2 * m),
       cos (%pi/2 * m)];
                                      m/2
(%o2)                  [0, 1, 0, (- 1)   ]
@end group
@end example

@end defvr




@defvr {Variable opcional} %iargs
Valor por defecto: @code{true}

Cuando @code{%iargs} vale @code{true}, las funciones trigonométricas
se simplifican a funciones hiperbólicas
@iftex
si el argumento es aparentemente un múltiplo de la unidad imaginaria @math{i}.
@end iftex
@ifnottex
si el argumento es aparentemente un múltiplo de la unidad imaginaria @math{%i}.
@end ifnottex

La simplificación se lleva a cabo incluso cuando el argumento es manifiestamente real;
@iftex
Maxima sólo se fija en si el argumento es un múltiplo literal de @math{i}.
@end iftex
@ifnottex
Maxima sólo se fija en si el argumento es un múltiplo literal de @math{%i}.
@end ifnottex

Ejemplos:

@c ===beg===
@c %iargs : false$
@c [sin (%i * x), cos (%i * x), tan (%i * x)];
@c %iargs : true$
@c [sin (%i * x), cos (%i * x), tan (%i * x)];
@c ===end===
@example
(%i1) %iargs : false$
@group
(%i2) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o2)           [sin(%i x), cos(%i x), tan(%i x)]
@end group
(%i3) %iargs : true$
@group
(%i4) [sin (%i * x), cos (%i * x), tan (%i * x)];
(%o4)           [%i sinh(x), cosh(x), %i tanh(x)]
@end group
@end example

La simplificación se aplica incluso en el caso de que
el argumento se reduzca a un número real.

@c ===beg===
@c declare (x, imaginary)$
@c [featurep (x, imaginary), featurep (x, real)];
@c sin (%i * x);
@c ===end===
@example
(%i1) declare (x, imaginary)$
@group
(%i2) [featurep (x, imaginary), featurep (x, real)];
(%o2)                     [true, false]
@end group
@group
(%i3) sin (%i * x);
(%o3)                      %i sinh(x)
@end group
@end example

@end defvr





@deffn {Function} acos (@var{x})
Arco coseno.

@end deffn

@deffn {Función} acosh (@var{x})
Arco coseno hiperbólico.

@end deffn

@deffn {Función} acot (@var{x})
Arco cotangente.

@end deffn

@deffn {Función} acoth (@var{x})
Arco cotangente hiperbólica.

@end deffn

@deffn {Función} acsc (@var{x})
Arco cosecante.

@end deffn

@deffn {Función} acsch (@var{x})
Arco cosecante hiperbólica.

@end deffn

@deffn {Función} asec (@var{x})
Arco secante.

@end deffn

@deffn {Función} asech (@var{x})
Arco secante hiperbólica.

@end deffn

@deffn {Función} asin (@var{x})
Arco seno.

@end deffn

@deffn {Función} asinh (@var{x})
Arco seno hiperbólico.

@end deffn

@deffn {Función} atan (@var{x})
Arco tangente.

@end deffn

@deffn {Función} atan2 (@var{y}, @var{x})
Calcula el valor de @code{atan(@var{y}/@var{x})} en el intervalo de @code{-%pi} a @code{%pi}.

@end deffn

@deffn {Función} atanh (@var{x})
Arco tangente hiperbólica.

@end deffn

@defvr {Paquete} atrig1
El paquete @code{atrig1} contiene ciertas reglas de simplificación adicionales para las funciones trigonométricas inversas. Junto con las reglas que ya conoce Maxima, los siguientes ángulos están completamente implementados:
@code{0}, @code{%pi/6}, @code{%pi/4}, @code{%pi/3} y @code{%pi/2}.  
Los ángulos correspondientes en los otros tres cuadrantes también están disponibles.  
Para hacer uso de estas reglas, ejecútese @code{load(atrig1);}.

@end defvr

@deffn {Función} cos (@var{x})
Coseno.

@end deffn

@deffn {Función} cosh (@var{x})
Coseno hiperbólico.

@end deffn

@deffn {Función} cot (@var{x})
Cotangente.

@end deffn

@deffn {Función} coth (@var{x})
Cotangente hiperbólica.

@end deffn

@deffn {Función} csc (@var{x})
Cosecante.

@end deffn

@deffn {Función} csch (@var{x})
Cosecante hiperbólica.

@end deffn


@defvr {Variable opcional} halfangles
Valor por defecto: @code{false}

Si @code{halfangles} vale @code{true}, las funciones
trigonométricas con argumentos del tipo @code{@var{expr}/2}
se simplifican a funciones con argumentos @var{expr}.

Para un argumento real @var{x} en el intervalo @code{0 < x < 2*%pi}
el seno del semiángulo se simplifica como

@example
                    sqrt(1 - cos(x))
                    ----------------
                        sqrt(2)
@end example

Se necesita un factor relativamente complicado para que esta fórmula
sea también válida para cualquier argumento complejo @var{z}:

@example
           realpart(z)
     floor(-----------)
              2 %pi
(- 1)                   (1 - unit_step(- imagpart(z))

                      realpart(z)            realpart(z)
                floor(-----------) - ceiling(-----------)
                         2 %pi                  2 %pi
          ((- 1)                                          + 1))
@end example

Maxima reconoce este factor y otros similares para las funciones @code{sin}, 
@code{cos}, @code{sinh} y @code{cosh}. Para valores especiales del argumento
@math{z}, estos factores se simplifican de forma apropiada.

Ejemplos:

@c ===beg===
@c halfangles : false$
@c sin (x / 2);
@c halfangles : true$
@c sin (x / 2);
@c assume(x>0, x<2*%pi)$
@c sin(x / 2);
@c ===end===
@example
(%i1) halfangles:false;
(%o1)                                false
(%i2) sin(x/2);
                                        x
(%o2)                               sin(-)
                                        2
(%i3) halfangles:true;
(%o3)                                true
(%i4) sin(x/2);
                                                    x
                                            floor(-----)
                                                  2 %pi
                      sqrt(1 - cos(x)) (- 1)
(%o4)                 ----------------------------------
                                   sqrt(2)
(%i5) assume(x>0, x<2*%pi)$
(%i6) sin(x/2);
                               sqrt(1 - cos(x))
(%o6)                          ----------------
                                   sqrt(2)
@end example

@end defvr


@defvr {Paquete} ntrig
El paquete @code{ntrig} contiene un conjunto de reglas de simplificación que se pueden usar para simplificar funciones trigonométricas cuyos argumentos son de la forma
@code{@var{f}(@var{n} %pi/10)} donde @var{f} es cualquiera de las funciones 
@code{sin}, @code{cos}, @code{tan}, @code{csc}, @code{sec} o @code{cot}.
@c NEED TO LOAD THIS PACKAGE ??

@end defvr

@deffn {Función} sec (@var{x})
Secante.

@end deffn

@deffn {Función} sech (@var{x})
Secante hiperbólica.

@end deffn

@deffn {Función} sin (@var{x})
Seno.

@end deffn

@deffn {Función} sinh (@var{x})
Seno hiperbólico.

@end deffn

@deffn {Función} tan (@var{x})
Tangente.

@end deffn

@deffn {Función} tanh (@var{x})
Tangente hiperbólica.

@end deffn

@deffn {Función} trigexpand (@var{expr})
Expande funciones trigonométricas e hiperbólicas de sumas de ángulos y de múltiplos de ángulos presentes en @var{expr}.  Para mejorar los resultados, @var{expr} debería expandirse. Para facilitar el control por parte del usuario de las simplificaciones, esta función tan solo expande un nivel de cada vez, expandiendo sumas de ángulos o de múltiplos de ángulos. A fin de obtener una expansión completa en senos y coseno, se le dará a la variable @code{trigexpand} el valor @code{true}.

La función @code{trigexpand} está controlada por las siguientes variables:

@table @code
@item trigexpand
Si vale @code{true}, provoca la expansión de todas las expresiones que contengan senos y cosenos.
@item trigexpandplus
Controla la regla de la suma para @code{trigexpand}, la expansión de una suma como @code{sin(x + y)} se llevará a cabo sólo si @code{trigexpandplus} vale @code{true}.
@item trigexpandtimes
Controla la regla del producto para @code{trigexpand}, la expansión de un producto como @code{sin(2 x)} se llevará a cabo sólo si @code{trigexpandtimes} vale @code{true}.
@end table

Ejemplos:

@c ===beg===
@c x+sin(3*x)/sin(x),trigexpand=true,expand;
@c trigexpand(sin(10*x+y));
@c ===end===
@example
@group
(%i1) x+sin(3*x)/sin(x),trigexpand=true,expand;
                         2           2
(%o1)               - sin (x) + 3 cos (x) + x
@end group
@group
(%i2) trigexpand(sin(10*x+y));
(%o2)          cos(10 x) sin(y) + sin(10 x) cos(y)
@end group
@end example

@end deffn

@defvr {Variable optativa} trigexpandplus
Valor por defecto: @code{true}

La variable @code{trigexpandplus} controla la regla de la suma para @code{trigexpand}.  Así, si la instrucción @code{trigexpand} se utiliza o si la variable @code{trigexpand} vale @code{true}, se realizará la expansión de sumas como @code{sin(x+y)} sólo si @code{trigexpandplus} vale @code{true}.

@end defvr

@defvr {Variable optativa} trigexpandtimes
Valor por defecto: @code{true}

La variable @code{trigexpandtimes} controla la regla del producto para @code{trigexpand}.  Así, si la instrucción @code{trigexpand} se utiliza o si la variable @code{trigexpand} vale @code{true}, se realizará la expansión de productos como @code{sin(2*x)} sólo si @code{trigexpandtimes} vale @code{true}.

@end defvr

@defvr {Variable optativa} triginverses
Valor por defecto: @code{true}

La variable @code{triginverses} controla la simplificación de la composición de funciones trigonométricas e hiperbólicas con sus funciones inversas.

Si vale @code{all}, tanto @code{atan(tan(@var{x}))}  como @code{tan(atan(@var{x}))} se reducen a @var{x}.  

Si vale @code{true}, se desactiva la simplificación de @code{@var{arcfun}(@var{fun}(@var{x}))}.

Si vale @code{false}, se desactivan las simplificaciones de 
@code{@var{arcfun}(@var{fun}(@var{x}))} y 
@code{@var{fun}(@var{arcfun}(@var{x}))}.

@end defvr

@deffn {Función} trigreduce (@var{expr}, @var{x})
@deffnx {Función} trigreduce (@var{expr})
Combina productos y potencias de senos y cosenos trigonométricos e hiperbólicos de @var{x}, transformándolos en otros que son múltiplos de @var{x}.  También intenta eliminar estas funciones cuando aparecen en los denominadores.  Si no se introduce el argumento @var{x}, entonces se utilizan todas las variables de @var{expr}.

Véase también @code{poissimp}.

@c ===beg===
@c trigreduce(-sin(x)^2+3*cos(x)^2+x);
@c ===end===
@example
@group
(%i1) trigreduce(-sin(x)^2+3*cos(x)^2+x);
               cos(2 x)      cos(2 x)   1        1
(%o1)          -------- + 3 (-------- + -) + x - -
                  2             2       2        2
@end group
@end example


Las rutinas de simplificación trigonométrica utilizan información declarada en algunos casos sencillos. Las declaraciones sobre variables se utilizan como se indica a continuación:

@c ===beg===
@c declare(j, integer, e, even, o, odd)$
@c sin(x + (e + 1/2)*%pi);
@c sin(x + (o + 1/2)*%pi);
@c ===end===
@example
(%i1) declare(j, integer, e, even, o, odd)$
(%i2) sin(x + (e + 1/2)*%pi);
(%o2)                        cos(x)
(%i3) sin(x + (o + 1/2)*%pi);
(%o3)                       - cos(x)

@end example

@end deffn

@defvr {Variable optativa} trigsign
Valor por defecto: @code{true}

Si @code{trigsign} vale @code{true}, se permite la simplificación de argumentos negativos en funciones trigonométricas, como en @code{sin(-x)}, que se transformará en @code{-sin(x)} sólo si @code{trigsign} vale @code{true}.

@end defvr

@deffn {Función} trigsimp (@var{expr})
@iftex
Utiliza las identidades
@tex
$\sin\left(x\right)^2 + \cos\left(x\right)^2 = 1$
@end tex
y
@tex
$\cosh\left(x\right)^2 - \sinh\left(x\right)^2 = 1$
@end tex
para simplificar expresiones que contienen @code{tan}, @code{sec},
etc., en expresiones con @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@end iftex
@ifnottex
Utiliza las identidades @math{sin(x)^2 + cos(x)^2 = 1} y
@math{cosh(x)^2 - sinh(x)^2 = 1} para simplificar expresiones que contienen @code{tan}, @code{sec},
etc., en expresiones con @code{sin}, @code{cos}, @code{sinh}, @code{cosh}.
@end ifnottex

Las funciones @code{trigreduce}, @code{ratsimp} y @code{radcan} puden seguir siendo útiles para continuar el proceso de simplificación.

La instrucción @code{demo ("trgsmp.dem")} muestra algunos ejemplos de @code{trigsimp}.
@c MERGE EXAMPLES INTO THIS ITEM

@end deffn

@deffn {Función} trigrat (@var{expr})
Devuelve una forma canónica simplificada cuasi-lineal de una expresión trigonométrica;
@var{expr} es una fracción racional que contiene @code{sin}, @code{cos} o @code{tan}, 
cuyos argumentos son formas lineales respecto de ciertas variables (o kernels) y @code{%pi/@var{n}}
(@var{n} entero) con coeficientes enteros. El resultado es una fracción simplificada con 
el numerador y denominador lineales respecto de @code{sin} y @code{cos}. Así,
 @code{trigrat} devuelve una expresión lineal siempre que sea posible.

@c ===beg===
@c trigrat(sin(3*a)/sin(a+%pi/3));
@c ===end===
@example
@group
(%i1) trigrat(sin(3*a)/sin(a+%pi/3));
(%o1)            sqrt(3) sin(2 a) + cos(2 a) - 1
@end group
@end example

El siguiente ejemplo se ha tomado de
Davenport, Siret y Tournier, @i{Calcul Formel}, Masson (o en inglés,
Addison-Wesley), sección 1.5.5, teorema de Morley.

@c ===beg===
@c c : %pi/3 - a - b$
@c bc : sin(a)*sin(3*c)/sin(a+b);
@c ba : bc, c=a, a=c;
@c ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
@c trigrat (ac2);
@c ===end===
@example
(%i1) c : %pi/3 - a - b$
@group
(%i2) bc : sin(a)*sin(3*c)/sin(a+b);
                                          %pi
                  sin(a) sin(3 (- b - a + ---))
                                           3
(%o2)             -----------------------------
                           sin(b + a)
@end group
@group
(%i3) ba : bc, c=a, a=c;
                                         %pi
                    sin(3 a) sin(b + a - ---)
                                          3
(%o3)               -------------------------
                                  %pi
                          sin(a - ---)
                                   3
@end group
@group
(%i4) ac2 : ba^2 + bc^2 - 2*bc*ba*cos(b);
         2         2         %pi
      sin (3 a) sin (b + a - ---)
                              3
(%o4) ---------------------------
                2     %pi
             sin (a - ---)
                       3
                                       %pi
 - (2 sin(a) sin(3 a) sin(3 (- b - a + ---)) cos(b)
                                        3
             %pi            %pi
 sin(b + a - ---))/(sin(a - ---) sin(b + a))
              3              3
      2       2              %pi
   sin (a) sin (3 (- b - a + ---))
                              3
 + -------------------------------
                2
             sin (b + a)
@end group
@group
(%i5) trigrat (ac2);
(%o5) - (sqrt(3) sin(4 b + 4 a) - cos(4 b + 4 a)
 - 2 sqrt(3) sin(4 b + 2 a) + 2 cos(4 b + 2 a)
 - 2 sqrt(3) sin(2 b + 4 a) + 2 cos(2 b + 4 a)
 + 4 sqrt(3) sin(2 b + 2 a) - 8 cos(2 b + 2 a) - 4 cos(2 b - 2 a)
 + sqrt(3) sin(4 b) - cos(4 b) - 2 sqrt(3) sin(2 b) + 10 cos(2 b)
 + sqrt(3) sin(4 a) - cos(4 a) - 2 sqrt(3) sin(2 a) + 10 cos(2 a)
 - 9)/4
@end group
@end example

@end deffn








@node Números aleatorios, , Funciones trigonométricas, Funciones matemáticas
@section Números aleatorios



@deffn {Función} make_random_state (@var{n})
@deffnx {Función} make_random_state (@var{s})
@deffnx {Función} make_random_state (true)
@deffnx {Función} make_random_state (false)

Un objeto de estado aleatorio representa el estado del generador de números aleatorios. El estado consiste en 627 cadenas binarias de 32 bits.

La llamada @code{make_random_state (@var{n})} devuelve un nuevo objeto de estado aleatorio creado a partir de una semilla entera igual a @var{n} módulo 2^32. El argumento @var{n} puede ser negativo.

La llamada @code{make_random_state (@var{s})} devuelve una copia del estado aleatorio @var{s}.

La llamada @code{make_random_state (true)} devuelve un nuevo objeto de estado aleatorio, cuya semilla se genera a partir de la hora actual del reloj del sistema como semilla.

La llamada @code{make_random_state (false)} devuelve una copia del estado actual del generador de números aleatorios.

@end deffn



@deffn {Función} set_random_state (@var{s})
Establece @var{s} como estado del generador de números aleatorios.

La función @code{set_random_state} devuelve @code{done} en todo caso.

@end deffn



@deffn {Función} random (@var{x})
Devuelve un número seudoaleatorio. Si @var{x} es un entero, @code{random (@var{x})} devuelve un
entero entre 0 y @code{@var{x} - 1}, ambos inclusive. Si @var{x} es un decimal en punto flotante,
@code{random (@var{x})} devuelve un decimal no negativo en punto flotante menor que @var{x}.
La función @code{random} emite un mensaje de error si @var{x} no es ni entero ni de punto flotante,
o si @var{x} no es positivo.

Las funciones @code{make_random_state} y @code{set_random_state}
permiten controlar el estado del generador de números aleatorios.

El generador de números aleatorios de Maxima implementa el algoritmo de Mersenne twister MT 19937.

Ejemplos:

@c ===beg===
@c s1: make_random_state (654321)$
@c set_random_state (s1);
@c random (1000);
@c random (9573684);
@c random (2^75);
@c s2: make_random_state (false)$
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c set_random_state (s2);
@c random (1.0);
@c random (10.0);
@c random (100.0);
@c ===end===
@example
(%i1) s1: make_random_state (654321)$
(%i2) set_random_state (s1);
(%o2)                         done
(%i3) random (1000);
(%o3)                          768
(%i4) random (9573684);
(%o4)                        7657880
(%i5) random (2^75);
(%o5)                11804491615036831636390
(%i6) s2: make_random_state (false)$
(%i7) random (1.0);
(%o7)                   .2310127244107132
(%i8) random (10.0);
(%o8)                   4.394553645870825
(%i9) random (100.0);
(%o9)                   32.28666704056853
(%i10) set_random_state (s2);
(%o10)                        done
(%i11) random (1.0);
(%o11)                  .2310127244107132
(%i12) random (10.0);
(%o12)                  4.394553645870825
(%i13) random (100.0);
(%o13)                  32.28666704056853
@end example

@end deffn




@c FALTA DEFINICION DE exptisolate


