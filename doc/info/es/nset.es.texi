@c english version 2011-07-8
@menu
* Introducción a los conjuntos::       
* Funciones y variables para los conjuntos::       
@end menu

@node Introducción a los conjuntos, Funciones y variables para los conjuntos, Conjuntos, Conjuntos
@section Introducción a los conjuntos

Maxima dispone de funciones para realizar operaciones con conjuntos, como la intersección o la unión. Los conjuntos deben ser finitos y definidos por enumeración. Maxima trata a los conjuntos y a las listas como objectos de distinta naturaleza, lo que permite trabajar con conjuntos cuyos elementos puedan ser también conjuntos o listas.

Además de funciones para operar con conjuntos finitos, Maxima dispone también de algunas funciones sobre combinatoria, como los números de Stirling de primera y segunda especie, números de Bell, coeficientes multinomiales, particiones de enteros no negativos y algunos otros. Maxima también define la función delta de Kronecker.


@subsection Utilización

Para construir un conjunto cuyos elementos sean @code{a_1, ..., a_n}, se utiliza la instrucción  @code{set(a_1, ..., a_n)} o @code{@{a_1, ..., a_n@}}; para formar un conjunto vacío, basta con hacer @code{set()} o @code{@{@}}. Para introducir conjuntos en Maxima, @code{set (...)} y @code{@{ ... @}} son equivalentes. Los conjuntos se muestran siempre con llave.

Si un elemento se indica más de una vez, el proceso 
de simplificación elimina los elementos redundantes.

@c ===beg===
@c set();
@c set(a, b, a);
@c set(a, set(b));
@c set(a, [b]);
@c {};
@c {a, b, a};
@c {a, {b}};
@c {a, [b]};
@c ===end===
@example
(%i1) set();
(%o1)                          @{@}
(%i2) set(a, b, a);
(%o2)                        @{a, b@}
(%i3) set(a, set(b));
(%o3)                       @{a, @{b@}@}
(%i4) set(a, [b]);
(%o4)                       @{a, [b]@}
(%i5) @{@};
(%o5)                          @{@}
(%i6) @{a, b, a@};
(%o6)                        @{a, b@}
(%i7) @{a, @{b@}@};
(%o7)                       @{a, @{b@}@}
(%i8) @{a, [b]@};
(%o8)                       @{a, [b]@}
@end example


Dos elementos candidatos a formar parte de un conjunto, @var{x} e @var{y},
son redundantes, esto es, se consideran el mismo elemento a 
efectos de consruir el conjunto, si y sólo si @code{is (@var{x} = @var{y})}
devuelve el valor @code{true}. Nótese que @code{is (equal (@var{x}, @var{y}))}
puede devolver @code{true} y @code{is (@var{x} = @var{y})} retornar
@code{false}; en cuyo caso los elementos @var{x} e @var{y} se
considerarían distintos.

@c ===beg===
@c x: a/c + b/c;
@c y: a/c + b/c;
@c z: (a + b)/c;
@c is (x = y);
@c is (y = z);
@c is (equal (y, z));
@c y - z;
@c ratsimp (%);
@c {x, y, z};
@c ===end===
@example
(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) @{x, y, z@};
                          b + a  b   a
(%o9)                    @{-----, - + -@}
                            c    c   c
@end example


Para formar un conjunto a partir de los miembros de una lista úsese @code{setify}.

@c ===beg===
@c setify([b, a]);
@c ===end===
@example
(%i1) setify([b, a]);
(%o1)                        @{a, b@}
@end example

Los elementos @code{x} e @code{y} de un conjunto se consideran iguales si @code{is(x = y)} devuelve el valor @code{true}. Así, @code{rat(x)} y @code{x} se consideran el mismo elemento de un conjunto; consecuentemente, 

@c ===beg===
@c {x, rat(x)};
@c ===end===
@example
(%i1) @{x, rat(x)@};
(%o1)                          @{x@}
@end example

Además, puesto que  @code{is((x-1)*(x+1) = x^2 - 1)} devuelve @code{false},  @code{(x-1)*(x+1)} y @code{x^2-1} se consideran elementos diferentes; así

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
@end example

Para reducir este conjunto a otro unitario, aplicar @code{rat} a cada elemento del conjunto:

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c map (rat, %);
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
(%i2) map (rat, %);
                              2
(%o2)/R/                    @{x  - 1@}
@end example

Para eliminar redundancias con otros conjuntos, será necesario utilizar otras funciones de simplificación. He aquí un ejemplo que utiliza  @code{trigsimp}:

@c ===beg===
@c {1, cos(x)^2 + sin(x)^2};
@c map (trigsimp, %);
@c ===end===
@example
(%i1) @{1, cos(x)^2 + sin(x)^2@};
                            2         2
(%o1)                @{1, sin (x) + cos (x)@}
(%i2) map (trigsimp, %);
(%o2)                          @{1@}
@end example

Se entiende que un conjunto está simplificado cuando entre sus elementos no hay redundancias y se hayan ordenados. La versión actual de las funciones para conjuntos utiliza la función @code{orderlessp} de Maxima para ordenar sus elementos; sin embargo, @i{futuras versiones de las funciones para operar con conjuntos podrán utilizar otras funciones de ordenación}.

Algunas operaciones con conjuntos, tales como la sustitución, fuerzan automáticamente una re-simplificación; por ejemplo,

@c ===beg===
@c s: {a, b, c}$
@c subst (c=a, s);
@c subst ([a=x, b=x, c=x], s);
@c map (lambda ([x], x^2), set (-1, 0, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@}$
(%i2) subst (c=a, s);
(%o2)                        @{a, b@}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          @{x@}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        @{0, 1@}
@end example

Maxima considera a las listas y conjuntos como objetos diferentes;
funciones tales como @code{union} y @code{intersection} emitirán
un error si alguno de sus argumentos no es un conjunto. Si se 
necesita aplicar una función de conjunto a una lista, se deberá 
utilizar la función @code{setify} para convertirla previamente en conjunto. 
Así,

@c ===beg===
@c union ([1, 2], {a, b});
@c union (setify ([1, 2]), {a, b});
@c ===end===
@example
(%i1) union ([1, 2], @{a, b@});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), @{a, b@});
(%o2)                     @{1, 2, a, b@}
@end example

Para extraer todos los elementos de un conjunto @code{s} que satisfagan un predicado @code{f}, úsese @code{subset(s,f)}. (Un @i{predicado} es una función booleana.) Por ejemplo, para encontrar las ecuaciones en un conjunto dado que no dependan de la variable @code{z}, se hará

@c ===beg===
@c subset ({x + y + z, x - y + 4, x + y - 5}, 
@c         lambda ([e], freeof (z, e)));
@c ===end===
@example
(%i1) subset (@{x + y + z, x - y + 4, x + y - 5@},
              lambda ([e], freeof (z, e)));
(%o1)               @{- y + x + 4, y + x - 5@}
@end example

La sección @code{Funciones y variables para los conjuntos} incluye una lista completa de funciones para operar con conjuntos en  Maxima.

@subsection Iteraciones con elementos

Hay dos formas para operar iterativamente sobre los elementos de un conjunto. Una es utilizar @code{map}; por ejemplo:

@c ===beg===
@c map (f, {a, b, c});
@c ===end===
@example
(%i1) map (f, @{a, b, c@});
(%o1)                  @{f(a), f(b), f(c)@}
@end example

La otra forma consiste en hacer uso de la construcción @code{for @var{x} in @var{s} do}

@c ===beg===
@c s: {a, b, c};
@c for si in s do print (concat (si, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
@end example

Las funciones de Maxima  @code{first} y @code{rest} funcionan también con conjuntos.  En este caso, @code{first} devuelve el primer elemento que se muestra del conjunto, el cual puede depender de la implementación del sistema. Si @code{s} es un conjunto, entonces @code{rest(s)} equivale a @code{disjoin (first(s), s)}. Hay otras funciones que trabajan correctamente con conjuntos. En próximas versiones de las funciones para operar con conjuntos es posible que @code{first} y @code{rest} trabajen de modo diferente o que ya no lo hagan en absoluto.

@subsection Fallos

Las funciones para operar con conjuntos utilizan la función @code{orderlessp}
de Maxima para ordenar los elementos de los conjuntos, así
como la función @code{like} de Lisp para decidir sobre la igualdad de dichos
elementos. Ambas funciones tienen fallos que son conocidos y que pueden
aflorar si se trabaja con conjuntos que tengan elementos en formato de
listas o matrices y que contengan expresiones racionales canónicas (CRE).
Un ejemplo es

@c ===beg===
@c {[x], [rat (x)]};
@c ===end===
@example
(%i1) @{[x], [rat (x)]@};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Esta expresión provoca una parada de Maxima junto con la 
emisión de un mensaje de error, el cual dependerá de 
la versión de Lisp que utilice Maxima. Otro ejemplo es

@c ===beg===
@c setify ([[rat(a)], [rat(b)]]);
@c ===end===
@example
(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Estos fallos son causados por fallos en  @code{orderlessp} y @code{like},
no por fallos cuyo origen se encuentre en las funciones para conjuntos.
Para ilustrarlo, se pueden ejecutar las siguientes expresiones

@c ===beg===
@c orderlessp ([rat(a)], [rat(b)]);
@c is ([rat(a)] = [rat(a)]);
@c ===end===
@example
(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
@end example

Hasta que estos errores no se corrijan, no es aconsejable construir conjuntos que tengan por elementos listas o matrices que contengan expresiones en forma CRE; sin embargo, un conjunto con elementos de la forma CRE no deberían dar problemas:

@c ===beg===
@c {x, rat (x)};
@c ===end===
@example
(%i1) @{x, rat (x)@};
(%o1)                          @{x@}
@end example

La función @code{orderlessp} de Maxima tiene otro fallo que puede causar problemas con las funciones para conjuntos, en concreto, que el predicado de ordenación @code{orderlessp} no es transitivo. El ejemplo más simple que ilustra este punto es

@c ===beg===
@c q: x^2$
@c r: (x + 1)^2$
@c s: x*(x + 2)$
@c orderlessp (q, r);
@c orderlessp (r, s);
@c orderlessp (q, s);
@c ===end===
@example
(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
@end example

El fallo puede causar problemas con todas las funciones para conjuntos,
así como también con otras funciones de Maxima.
Es probable, pero no seguro, que este fallo se puede evitar si todos 
los elementos del conjunto están en la forma de expresión racional
canónica (CRE) o han sido simplificados con @code{ratsimp}.

@c WHAT EXACTLY IS THE EFFECT OF ordergreat AND orderless ON THE SET FUNCTIONS ??
Los mecanismos @code{orderless} y @code{ordergreat} de Maxima son incompatibles
con las funciones para conjuntos. Si se necesitan utilizar @code{orderless} o
@code{ordergreat}, hágase antes de construir los conjuntos y no se utilice 
la instrucción @code{unorder}.

Se ruega a todo usuario que crea haber encontrado un fallo en las funciones para conjuntos que lo comunique en la base de datos de Maxima. Véase @code{bug_report}.

@subsection Autores

Stavros Macrakis de Cambridge, Massachusetts y Barton Willis de la University of Nebraska at Kearney (UNK).

@node Funciones y variables para los conjuntos,  , Introducción a los conjuntos, Conjuntos
@section Funciones y variables para los conjuntos


@deffn {Función} adjoin (@var{x}, @var{a}) 

Calcula la unión del conjunto @var{a} y @code{@{@var{x}@}}.

La función @code{adjoin} emite un mensaje de error si @var{a}
no es un conjunto literal.

Las sentencias @code{adjoin(@var{x}, @var{a})} y 
@code{union(set(@var{x}), @var{a})} son equivalentes, aunque
@code{adjoin} puede ser algo más rápida que @code{union}.

Véase también @code{disjoin}.

Ejemplos:

@c ===beg===
@c adjoin (c, {a, b});
@c adjoin (a, {a, b});
@c ===end===
@example
(%i1) adjoin (c, @{a, b@});
(%o1)                       @{a, b, c@}
(%i2) adjoin (a, @{a, b@});
(%o2)                        @{a, b@}
@end example

@end deffn


@deffn {Función} belln (@var{n})

Representa el @math{n}-ésimo número de Bell, de
modo que @code{belln(n)} es el número de particiones de un conjunto de 
@var{n} elementos.

El argumento @var{n} debe ser un entero no negativo.

La función @code{belln} se distribuye sobre ecuaciones, listas,
matrices y conjuntos.

Ejemplos:

@code{belln} se aplica a enteros no negativos,

@c ===beg===
@c makelist (belln (i), i, 0, 6);
@c is (cardinality (set_partitions ({})) = belln (0));
@c is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6}))
@c                          = belln (6));
@c ===end===
@example
(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions (@{@})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions (@{1, 2, 3, 4, 5, 6@}))
                            = belln (6));
(%o3)                         true
@end example

Si @var{n} no es un entero no negativo, la función @code{belln(n)} no hace cálculo alguno.

@c ===beg===
@c [belln (x), belln (sqrt(3)), belln (-9)];
@c ===end===
@example
(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
@end example
@end deffn


@deffn {Función} cardinality (@var{a})

Devuelve el número de elementos del conjunto @var{a}.

La función @code{cardinality} ignora los elementos
redundantes, incluso cuando la simplificación está
desabilitada.

Ejemplos:

@c ===beg===
@c cardinality ({});
@c cardinality ({a, a, b, c});
@c simp : false;
@c cardinality ({a, a, b, c});
@c ===end===
@example
(%i1) cardinality (@{@});
(%o1)                           0
(%i2) cardinality (@{a, a, b, c@});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality (@{a, a, b, c@});
(%o4)                           3
@end example
@end deffn


@deffn {Función} cartesian_product (@var{b_1}, ... , @var{b_n})

Devuelve un conjunto formado por listas de la forma @code{[@var{x_1}, ..., @var{x_n}]},
siendo @var{x_1}, ..., @var{x_n} elementos de los conjuntos @var{b_1}, ... , @var{b_n},
respectivamente.

La función @code{cartesian_product} emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.

Ejemplos:

@c ===beg===
@c cartesian_product ({0, 1});
@c cartesian_product ({0, 1}, {0, 1});
@c cartesian_product ({x}, {y}, {z});
@c cartesian_product ({x}, {-1, 0, 1});
@c ===end===
@example
(%i1) cartesian_product (@{0, 1@});
(%o1)                      @{[0], [1]@}
(%i2) cartesian_product (@{0, 1@}, @{0, 1@});
(%o2)           @{[0, 0], [0, 1], [1, 0], [1, 1]@}
(%i3) cartesian_product (@{x@}, @{y@}, @{z@});
(%o3)                      @{[x, y, z]@}
(%i4) cartesian_product (@{x@}, @{-1, 0, 1@});
(%o4)              @{[x, - 1], [x, 0], [x, 1]@}
@end example
@end deffn


@deffn {Función} disjoin (@var{x}, @var{a})

Devuelve el conjunto @var{a} sin el elemento @var{x}.
Si @var{x} no es elemento de @var{a}, entonces el
resultado es el propio @var{a}.

La función @code{disjoin} emite un mensaje de error si
@var{a} no es un conjunto literal.

Las sentencias @code{disjoin(@var{x}, @var{a})}, @code{delete(@var{x}, @var{a})}
y @code{setdifference(@var{a}, set(@var{x}))} son todas ellas equivalentes;
pero en general, @code{disjoin} será más rápida que las otras.

Ejemplos:

@c ===beg===
@c disjoin (a, {a, b, c, d});
@c disjoin (a + b, {5, z, a + b, %pi});
@c disjoin (a - b, {5, z, a + b, %pi});
@c ===end===
@example
(%i1) disjoin (a, @{a, b, c, d@});
(%o1)                       @{b, c, d@}
(%i2) disjoin (a + b, @{5, z, a + b, %pi@});
(%o2)                      @{5, %pi, z@}
(%i3) disjoin (a - b, @{5, z, a + b, %pi@});
(%o3)                  @{5, %pi, b + a, z@}
@end example
@end deffn


@deffn {Función} disjointp (@var{a}, @var{b}) 

Devuelve @code{true} si y sólo si los conjuntos  @var{a} y @var{b}
son disjuntos.

La función @code{disjointp} emite un mensaje de error si
@var{a} o @var{b} no son conjuntos literales.

Ejemplos:

@c ===beg===
@c disjointp ({a, b, c}, {1, 2, 3});
@c disjointp ({a, b, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) disjointp (@{a, b, c@}, @{1, 2, 3@});
(%o1)                         true
(%i2) disjointp (@{a, b, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example
@end deffn


@deffn {Función} divisors (@var{n})

Calcula el conjunto de divisores de @var{n}.

La sentencia @code{divisors(@var{n})} devuelve un conjunto
de enteros si @var{n} es un entero no nulo.
El conjunto de divisores incluye los elementos 1 y @var{n}.
Los divisores de un entero negativo son los divisores de su
valor absoluto.

La función @code{divisors} se distribuye sobre las ecuaciones,
listas, matrices y conjuntos.

Ejemplos:

Se puede comprobar que 28 es un número perfecto:
la suma de sus divisores (excepto él mismo) es 28.

@c ===beg===
@c s: divisors(28);
@c lreduce ("+", args(s)) - 28;
@c ===end===
@example
(%i1) s: divisors(28);
(%o1)                 @{1, 2, 4, 7, 14, 28@}
(%i2) lreduce ("+", args(s)) - 28;
(%o2)                          28
@end example

La función @code{divisors} es simplificadora.
Haciendo la sustitución de @code{a} por 8 en @code{divisors(a)}
devuelve los divisores sin tener que reevaluar @code{divisors(8)},

@c ===beg===
@c divisors (a);
@c subst (8, a, %);
@c ===end===
@example
(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     @{1, 2, 4, 8@}
@end example

La función @code{divisors} se distribuye sobre ecuaciones, listas,
matrices y conjuntos.

@c ===beg===
@c divisors (a = b);
@c divisors ([a, b, c]);
@c divisors (matrix ([a, b], [c, d]));
@c divisors ({a, b, c});
@c ===end===
@example
(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors (@{a, b, c@});
(%o4)        @{divisors(a), divisors(b), divisors(c)@}
@end example
@end deffn


@deffn {Función} elementp (@var{x}, @var{a})

Devuelve @code{true} si y sólo si @var{x} es miembro del
conjunto @var{a}.

La función @code{elementp} emite un mensaje de error si 
@var{a} no es un conjunto literal.

Ejemplos: 

@c ===beg===
@c elementp (sin(1), {sin(1), sin(2), sin(3)});
@c elementp (sin(1), {cos(1), cos(2), cos(3)});
@c ===end===
@example
(%i1) elementp (sin(1), @{sin(1), sin(2), sin(3)@});
(%o1)                         true
(%i2) elementp (sin(1), @{cos(1), cos(2), cos(3)@});
(%o2)                         false
@end example
@end deffn


@deffn {Función} emptyp (@var{a})
Devuelve @code{true} si y sólo si @var{a} es el conjunto vacío o la lista vacía.

Ejemplos:

@c ===beg===
@c map (emptyp, [{}, []]);
@c map (emptyp, [a + b, {{}}, %pi]);
@c ===end===
@example
(%i1) map (emptyp, [@{@}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, @{@{@}@}, %pi]);
(%o2)                 [false, false, false]
@end example
@end deffn
       

@deffn {Función} equiv_classes (@var{s}, @var{F})

Devuelve el conjunto de las clases de equivalencia del conjunto @var{s}
respecto de la relación de equivalencia @var{F}.

El argumento @var{F} es una función de dos variables definida sobre
el producto cartesiano @var{s} por @var{s}.
El valor devuelto por @var{F} debe ser @code{true} o @code{false},
o bien una expresión @var{expr} tal que @code{is(@var{expr})}
tome el valor @code{true} o @code{false}.

Si @var{F} no es una relación de equivalencia, @code{equiv_classes}
la acepta sin emitir ningún mensaje de error, pero el resultado
será incorrecto en general.

Ejemplos:

La relación de equivalencia es una expresión lambda que devuelve 
@code{true} o @code{false},

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
@c                 lambda ([x, y], is (equal (x, y))));
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@},
                      lambda ([x, y], is (equal (x, y))));
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

La relación de equivalencia es el nombre de una función relacional
en la que @code{is} evalúa a @code{true} o @code{false},

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@}, equal);
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

Las clases de equivalencia son números que difieren en un múltiplo de 3.

@c ===beg===
@c equiv_classes ({1, 2, 3, 4, 5, 6, 7}, 
@c             lambda ([x, y], remainder (x - y, 3) = 0));
@c ===end===
@example
(%i1) equiv_classes (@{1, 2, 3, 4, 5, 6, 7@}, 
              lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              @{@{1, 4, 7@}, @{2, 5@}, @{3, 6@}@}
@end example
@end deffn


@deffn {Función} every (@var{f}, @var{s})
@deffnx {Función} every (@var{f}, @var{L_1}, ..., @var{L_n})

Devuelve @code{true} si el predicado @var{f} vale @code{true}
para todos los argumentos dados.

Dado un conjunto como segundo argumento,
@code{every(@var{f}, @var{s})} devuelve @code{true}
si @code{is(@var{f}(@var{a_i}))} devuelve @code{true} para todos los
@var{a_i} pertenecientes @var{s}.
La función @code{every} puede evaluar o no @var{f} para todos los
@var{a_i} pertenecientes @var{s}.
Puesto que los conjuntos no están ordenados, @code{every}
puede evaluar @code{@var{f}(@var{a_i})} en cualquier orden.

Dada una o más listas como argumentos,
@code{every(@var{f}, @var{L_1}, ..., @var{L_n})} devuelve @code{true}
si @code{is(@var{f}(@var{x_1}, ..., @var{x_n}))} devuelve @code{true} 
para todo @var{x_1}, ..., @var{x_n} en @var{L_1}, ..., @var{L_n}, respectivamente.
La función @code{every} puede evaluar o no 
@var{f} para cualquier combinación de @var{x_1}, ..., @var{x_n}; además,
@code{every} evalúa las listas en el orden creciente del índice.

Dado un conjunto vacío @code{@{@}} o lista vacía 
@code{[]} como argumentos, @code{every} devuelve @code{false}.

Si la variable global @code{maperror} vale @code{true}, todas las listas
@var{L_1}, ..., @var{L_n} deben ser de igual longitud.
Si @code{maperror} vale @code{false}, los argumentos en forma de listas
se truncan para igualar sus longitudes a la de la lista más corta.

Los valores que devuelve el predicado @var{f} cuando toman 
(mediante @code{is}) un valor diferente a @code{true} y @code{false}
se controlan con la variable global @code{prederror}.
Si @code{prederror} vale @code{true}, tales valores se
consideran como @code{false} y la respuesta de @code{every} es @code{false}.
Si @code{prederror} vale @code{false}, tales valores se
consideran como desconocidos (@code{unknown}) y la respuesta de 
@code{every} es @code{unknown}.

Ejemplos:

Se aplica @code{every} a un único conjunto.
El predicado es una función de un argumento.

@c ===beg===
@c every (integerp, {1, 2, 3, 4, 5, 6});
@c every (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) every (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) every (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         false
@end example

Se aplica @code{every} a dos listas.
El predicado es una función de dos argumentos.

@c ===beg===
@c every ("=", [a, b, c], [a, b, c]);
@c every ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) every ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Las respuestas del predicado @var{f} que se evalúan 
a cualquier cosa diferente de @code{true} y @code{false}
están controlados por la variable global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z],
@c                [x^2, y^2, z^2]);
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c prederror : true;
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                   [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
@end example
@end deffn
 

@deffn {Función} extremal_subset (@var{s}, @var{f}, max)
@deffnx {Función} extremal_subset (@var{s}, @var{f}, min)

Calcula el subconjunto de @var{s} para el cual la función @var{f}
toma sus valores mayor y menor.

La sentencia @code{extremal_subset(@var{s}, @var{f}, max)}
devuelve el subconjunto del conjunto o lista @var{s} para el cual
la función real @var{f} toma su valor máximo.

La sentencia @code{extremal_subset(@var{s}, @var{f}, min)}
devuelve el subconjunto del conjunto o lista @var{s} para el cual
la función real @var{f} toma su valor mínimo.

Ejemplos

@c ===beg===
@c extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
@c extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
@c ===end===
@example
(%i1) extremal_subset (@{-2, -1, 0, 1, 2@}, abs, max);
(%o1)                       @{- 2, 2@}
(%i2) extremal_subset (@{sqrt(2), 1.57, %pi/2@}, sin, min);
(%o2)                       @{sqrt(2)@}
@end example
@end deffn


@deffn {Función} flatten (@var{expr})

Recoge los argumentos de subexpresiones con el mismo operador que @var{expr}
y construye con ellas otra expresión a partir de estos argumentos.

Aquellas subexpresiones en las que el operador es diferente del operador
principal de @code{expr} se copian sin modificarse, incluso cuando ellas
mismas contengan subexpresiones en las que el operador sea el mismo 
que el de @code{expr}.

Es posible que @code{flatten} construya expresiones en las que el número
de argumentos difiera del número admitido por el operador, lo cual
hará que se emita un mensaje de error. La función @code{flatten}
no intentará detectar estas situaciones.

Las expresiones que tengan representaciones especiales, por ejemplo las racionales
canónicas (CRE), no admiten que se aplique sobre ellas la función @code{flatten};
en tales casos se devuelve el argumento sin modificación.

Ejemplos:

Aplicada a una lista, @code{flatten} reune todos los elementos que son a su vez listas.

@c ===beg===
@c flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
@c ===end===
@example
(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
@end example

Aplicado a un conjunto, @code{flatten} reune todos los elementos que son a su vez conjuntos.

@c ===beg===
@c flatten ({a, {b}, {{c}}});
@c flatten ({a, {[a], {a}}});
@c ===end===
@example
(%i1) flatten (@{a, @{b@}, @{@{c@}@}@});
(%o1)                       @{a, b, c@}
(%i2) flatten (@{a, @{[a], @{a@}@}@});
(%o2)                       @{a, [a]@}
@end example

La función @code{flatten} es similar a la declaración del operador
principal como n-ario. Sin embargo, @code{flatten} no tiene efecto alguno
sobre subexpresiones que tengan un operador diferente del principal, mientras
que sí lo tiene una declaración n-aria.


@c ===beg===
@c expr: flatten (f (g (f (f (x)))));
@c declare (f, nary);
@c ev (expr);
@c ===end===
@example
(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
@end example

La función @code{flatten} trata las funciones subindicadas como
a cualquier otro operador.

@c ===beg===
@c flatten (f[5] (f[5] (x, y), z));
@c ===end===
@example
(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
@end example

Es posible que @code{flatten} construya expresiones en las que el número
de argumentos difiera del número admitido por el operador.

@c ===beg===
@c 'mod (5, 'mod (7, 4));
@c flatten (%);
@c ''%, nouns;
@c ===end===
@example
(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example
@end deffn


@deffn {Función} full_listify (@var{a})

Sustituye los operadores de conjunto presentes en @var{a}
por operadores de listas, devolviendo el resultado.
La función @code{full_listify} sustituye operadores de 
conjuntos en subexpresiones anidadas, incluso cuando
el operador principal no es @code{set}.

La función @code{listify} sustituye únicamente el
operador principal.

Ejemplos:

@c ===beg===
@c full_listify ({a, b, {c, {d, e, f}, g}});
@c full_listify (F (G ({a, b, H({c, d, e})})));
@c ===end===
@example
(%i1) full_listify (@{a, b, @{c, @{d, e, f@}, g@}@});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G (@{a, b, H(@{c, d, e@})@})));
(%o2)              F(G([a, b, H([c, d, e])]))
@end example
@end deffn


@deffn {Función} fullsetify (@var{a})

Si @var{a} es una lista, sustituye el operador de lista por el
de conjunto, aplicando posteriormente @code{fullsetify} a todos
los elementos que son a su vez conjuntos.
Si @var{a} no es una lista, se devuelve sin cambio alguno.

La función @code{setify} sustituye solamente el operador principal.

Ejemplos:

En la salida @code{(%o2)} el argumento de @code{f} no se convierte en
conjunto porque el operador principal de @code{f([b])} no es una lista.

@c ===beg===
@c fullsetify ([a, [a]]);
@c fullsetify ([a, f([b])]);
@c ===end===
@example
(%i1) fullsetify ([a, [a]]);
(%o1)                       @{a, @{a@}@}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      @{a, f([b])@}
@end example
@end deffn


@deffn {Función} identity (@var{x})

La función @code{identity} devuelve su argumento cualquiera que sea éste.

Ejemplos:

La función @code{identity} puede utilizarse como predicado cuando
los argumentos ya son valores booleanos.

@c ===beg===
@c every (identity, [true, true]);
@c ===end===
@example
(%i1) every (identity, [true, true]);
(%o1)                         true
@end example
@end deffn


@deffn {Función} integer_partitions (@var{n})
@deffnx {Función} integer_partitions (@var{n}, @var{len})

Devuelve particiones enteras de @var{n}, esto es,
listas de enteros cuyas sumas son @var{n}.

La sentencia @code{integer_partitions(@var{n})}
devuelve el conjunto de todas las particiones del entero @var{n}.
Cada partición es una lista ordenada de mayor a menor.

La sentencia @code{integer_partitions(@var{n}, @var{len})}
devuelve todas las particiones de longitud @var{len} o menor;
en este caso, se añaden ceros a cada partición con menos
de @var{len} términos para que todas ellas sean de longitud
@var{len}. Las particiones son listas ordenadas de mayor a menor.

Una lista @math{[a_1, ..., a_m]} es una partición de un entero no
negativo @math{n} si (1) cada @math{a_i} es entero no nulo y (2)
@math{a_1 + ... + a_m = n.} Así, 0 no tiene particiones.

Ejemplos:

@c ===beg===
@c integer_partitions (3);
@c s: integer_partitions (25)$
@c cardinality (s);
@c map (lambda ([x], apply ("+", x)), s);
@c integer_partitions (5, 3);
@c integer_partitions (5, 2);
@c ===end===
@example
(%i1) integer_partitions (3);
(%o1)               @{[1, 1, 1], [2, 1], [3]@}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply ("+", x)), s);
(%o4)                         @{25@}
(%i5) integer_partitions (5, 3);
(%o5) @{[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]@}
(%i6) integer_partitions (5, 2);
(%o6)               @{[3, 2], [4, 1], [5, 0]@}
@end example

Para encontrar todas las particiones que satisfagan cierta
condición, utilícese la función @code{subset};
he aquí un ejemplo que encuentra todas las
particiones de 10 formadas por números primos.

@c ===beg===
@c s: integer_partitions (10)$
@c cardinality (s);
@c xprimep(x) := integerp(x) and (x > 1) and primep(x)$
@c subset (s, lambda ([x], every (xprimep, x)));
@c ===end===
@example
(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) @{[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]@}
@end example
@end deffn


@deffn {Función} intersect (@var{a_1}, ..., @var{a_n})
Es una forma abreviada de la función @code{intersection}.
@end deffn


@deffn {Función} intersection (@var{a_1}, ..., @var{a_n})

Devuelve el conjunto de todos los elementos que son
comunes a los conjuntos  @var{a_1} a @var{a_n}.

Emite un mensaje de error en caso de que cualquiera de los 
@var{a_i} no sea un conjunto.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c, d};
@c S_2 : {d, e, f, g};
@c S_3 : {c, d, e, f};
@c S_4 : {u, v, w};
@c intersection (S_1, S_2);
@c intersection (S_2, S_3);
@c intersection (S_1, S_2, S_3);
@c intersection (S_1, S_2, S_3, S_4);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, d@};
(%o1)                     @{a, b, c, d@}
(%i2) S_2 : @{d, e, f, g@};
(%o2)                     @{d, e, f, g@}
(%i3) S_3 : @{c, d, e, f@};
(%o3)                     @{c, d, e, f@}
(%i4) S_4 : @{u, v, w@};
(%o4)                       @{u, v, w@}
(%i5) intersection (S_1, S_2);
(%o5)                          @{d@}
(%i6) intersection (S_2, S_3);
(%o6)                       @{d, e, f@}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          @{d@}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          @{@}
@end example
@end deffn

@deffn {Función} kron_delta (@var{x1}, @var{y1}, @dots{}, @var{xp}, @var{yp})

Es la función delta de Kronecker.

La función @code{kron_delta} devuelve 1 cuando @var{xi} y
@var{yi} son iguales para todos los pares, devolviendo 0 si existe
un par en el que @var{xi} y @var{yi} no sean iguales. La igualdad
se determina utilizando @code{is(equal(xi,xj))} y la desigualdad
con @code{is(notequal(xi,xj))}. En caso de un solo argumento,
@code{kron_delta} devuelve un mensaje de error.

Ejemplos:

@c ===beg===
@c kron_delta(a,a);
@c kron_delta(a,b,a,b);
@c kron_delta(a,a,b,a+1);
@c assume(equal(x,y));
@c kron_delta(x,y);
@c ===end===
@example
(%i1) kron_delta(a,a);
(%o1)                                  1
(%i2) kron_delta(a,b,a,b);
(%o2)                          kron_delta(a, b)
(%i3) kron_delta(a,a,b,a+1);
(%o3)                                  0
(%i4) assume(equal(x,y));
(%o4)                            [equal(x, y)]
(%i5) kron_delta(x,y);
(%o5)                                  1
@end example
@end deffn


@deffn {Función} listify (@var{a})

Si @var{a} es un conjunto, devuelve una lista con los elementos de @var{a};
si  @var{a} no es un conjunto, devuelve @var{a}.

La función @code{full_listify} sustituye todos los operadores
de conjunto en @var{a} por operadores de lista.

Ejemplos:

@c ===beg===
@c listify ({a, b, c, d});
@c listify (F ({a, b, c, d}));
@c ===end===
@example
(%i1) listify (@{a, b, c, d@});
(%o1)                     [a, b, c, d]
(%i2) listify (F (@{a, b, c, d@}));
(%o2)                    F(@{a, b, c, d@})
@end example
@end deffn


@deffn {Función} lreduce (@var{f}, @var{s})
@deffnx {Función} lreduce (@var{f}, @var{s}, @var{init})

Amplía la función binaria @var{F} a n-aria mediante
composición, siendo @var{s} una lista.

La sentencia  @code{lreduce(@var{F}, @var{s})} devuelve
@code{F(... F(F(s_1, s_2), s_3), ... s_n)}.
Si se incluye el argumento opcional @var{s_0},
el resultado equivale a @code{lreduce(@var{F}, cons(@var{s_0}, @var{s}))}.

La función @var{F} se aplica primero a los elementos del
extremo izquierdo de la lista, de ahí el nombre
@code{lreduce}, (@i{left reduce}).

Véanse también @code{rreduce}, @code{xreduce} y @code{tree_reduce}.

Ejemplos:

La función @code{lreduce} sin el argumento opcional,

@c ===beg===
@c lreduce (f, [1, 2, 3]);
@c lreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
@end example

La función @code{lreduce} con el argumento opcional,

@c ===beg===
@c lreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
@end example

La función @code{lreduce} aplicada a operadores binarios de Maxima.
El símbolo @code{/} es el operador división.

@c ===beg===
@c lreduce ("^", args ({a, b, c, d}));
@c lreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) lreduce ("^", args (@{a, b, c, d@}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce ("/", args (@{a, b, c, d@}));
                                a
(%o2)                         -----
                              b c d
@end example

@end deffn


@deffn {Función} makeset (@var{expr}, @var{x}, @var{s})

Genera un conjunto cuyos miembros se generan a partir de la
expresión @var{expr}, siendo @var{x} una lista de variables de
@var{expr} y @var{s} un conjunto o lista de listas.
Para generar los elementos del conjunto, se evalúa @var{expr}
asignando a las variables de @var{x} los elementos de @var{s}
en paralelo.

Los elementos de @var{s} deben tener la misma longitud que @var{x}.
La lista de variables @var{x} debe ser una lista de símbolos
sin subíndices. Cuando se trate de un único símbolo,
@var{x} debe expresarse como una lista de un elemento y cada elemento de @var{s}
debe ser una lista de un sólo elemento.

@c FOLLOWING EQUIVALENT EXPRESSION IS REALLY TOO COMPLICATED, JUST SKIP IT FOR NOW
@c @code{makeset(@var{expr}, @var{x}, @var{s})} returns the same result as
@c @code{setify(map(lambda([L], sublis(map("=", ''@var{x}, L), ''@var{expr})), args(@var{s})))}.

Véase también @code{makelist}.

Ejemplos:

@c ===beg===
@c makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
@c S : {x, y, z}$
@c S3 : cartesian_product (S, S, S);
@c makeset (i + j + k, [i, j, k], S3);
@c makeset (sin(x), [x], {[1], [2], [3]});
@c ===end===
@example
(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     @{-, -, -, -@}
                           a  b  c  d
(%i2) S : @{x, y, z@}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) @{[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]@}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) @{3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y@}
(%i5) makeset (sin(x), [x], @{[1], [2], [3]@});
(%o5)               @{sin(1), sin(2), sin(3)@}
@end example
@end deffn


@deffn {Función} moebius (@var{n})

Representa la función de Moebius.

Si @var{n} es el producto de @math{k} números primos diferentes,
@code{moebius(@var{n})} devuelve @math{(-1)^k}, retornando 1 si 
@math{@var{n} = 1} y 0 para cualesquiera otros enteros positivos.


La función de Moebius se distribuye respecto de ecuaciones,
listas, matrices y conjuntos.

Ejemplos:

@c ===beg===
@c moebius (1);
@c moebius (2 * 3 * 5);
@c moebius (11 * 17 * 29 * 31);
@c moebius (2^32);
@c moebius (n);
@c moebius (n = 12);
@c moebius ([11, 11 * 13, 11 * 13 * 15]);
@c moebius (matrix ([11, 12], [13, 14]));
@c moebius ({21, 22, 23, 24});
@c ===end===
@example
(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius (@{21, 22, 23, 24@});
(%o9)                      @{- 1, 0, 1@}
@end example
@end deffn
 

@deffn {Función} multinomial_coeff (@var{a_1}, ..., @var{a_n})
@deffnx {Función} multinomial_coeff ()

Calcula el coeficiente multinomial.

Si todos los @var{a_k} son enteros no negativos, el coeficiente multinomial
es el número de formas de colocar  @code{@var{a_1} + ... + @var{a_n}}
objetos diferentes en  @math{n} cajas con @var{a_k} elementos en la
@math{k}-ésima caja. En general,
@code{multinomial_coeff (@var{a_1}, ..., @var{a_n})} calcula
@code{(@var{a_1} + ... + @var{a_n})!/(@var{a_1}! ... @var{a_n}!)}.

Si no se dan argumentos, @code{multinomial_coeff()} devuelve 1.

Se puede usar @code{minfactorial} para simplificar el valor
devuelto por @code{multinomial_coeff}.

Ejemplos:

@c ===beg===
@c multinomial_coeff (1, 2, x);
@c minfactorial (%);
@c multinomial_coeff (-6, 2);
@c minfactorial (%);
@c ===end===
@example
(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
@end example
@end deffn


@deffn {Función} num_distinct_partitions (@var{n})
@deffnx {Función} num_distinct_partitions (@var{n}, @var{list})

Si @var{n} es un entero no negativo, devuelve el número de
particiones enteras distintas de @var{n}, en caso contrario
@code{num_distinct_partitions} devuelve una forma nominal.

La sentencia @code{num_distinct_partitions(@var{n}, list)}
devuelve una lista con el número de particiones distintas
de 1, 2, 3, ..., @var{n}.

Una partición distinta de @var{n} es una lista de números
enteros positivos distintos @math{k_1}, ..., @math{k_m}
tales que @math{@var{n} = k_1 + ... + k_m}.

Ejemplos:

@c ===beg===
@c num_distinct_partitions (12);
@c num_distinct_partitions (12, list);
@c num_distinct_partitions (n);
@c ===end===
@example
(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
@end example
@end deffn


@deffn {Función} num_partitions (@var{n})
@deffnx {Función} num_partitions (@var{n}, @var{list})

Si @var{n} es un entero no negativo, devuelve el número de
particiones enteras de @var{n}, en caso contrario @code{num_partitions}
devuelve una expresión nominal.

La sentencia @code{num_partitions(@var{n}, list)} devuelve una lista
con los números de particiones enteras de 1, 2, 3, ..., @var{n}.

Siendo @var{n} un entero no negativo, @code{num_partitions(@var{n})}
es igual a @code{cardinality(integer_partitions(@var{n}))}; sin
embargo, @code{num_partitions} no construye el conjunto de 
particiones, por lo que es más rápido.

Ejemplos:

@c ===beg===
@c num_partitions (5) = cardinality (integer_partitions (5));
@c num_partitions (8, list);
@c num_partitions (n);
@c ===end===
@example
(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
@end example
@end deffn


@deffn {Función} partition_set (@var{a}, @var{f})

Particiona el conjunto @var{a} respecto del predicado @var{f}.

La función @code{partition_set} devuelve una lista con dos conjuntos;
el primer conjunto es el subconjunto de @var{a} para el cual el predicado
@var{f} devuelve @code{false} y el segundo contiene al resto de elementos de @var{a}.

La función @code{partition_set} no aplica @code{is} al valor devuelto
por @var{f}.

La función @code{partition_set} emite un mensaje de error si @var{a}
no es un conjunto literal.

Véase también @code{subset}.

Ejemplos:

@c ===beg===
@c partition_set ({2, 7, 1, 8, 2, 8}, evenp);
@c partition_set ({x, rat(y), rat(y) + z, 1},
@c                 lambda ([x], ratp(x)));
@c ===end===
@example
(%i1) partition_set (@{2, 7, 1, 8, 2, 8@}, evenp);
(%o1)                   [@{1, 7@}, @{2, 8@}]
(%i2) partition_set (@{x, rat(y), rat(y) + z, 1@},
                  lambda ([x], ratp(x)));
(%o2)/R/              [@{1, x@}, @{y, y + z@}]
@end example
@end deffn


@deffn {Función} permutations (@var{a})

Devuelve un conjunto con todas las permutaciones distintas
de los miembros de la lista o conjunto  @var{a}. Cada permutación
es una lista, no un conjunto.

Si @var{a} es una lista, sus miembros duplicados no son eliminados
antes de buscar sus permutaciones.

Si @var{a} no es una lista o conjunto, @code{permutations} emite
un mensaje de error.

Véase también @code{random_permutation}.

Ejemplos:

@c ===beg===
@c permutations ([a, a]);
@c permutations ([a, a, b]);
@c ===end===
@example
(%i1) permutations ([a, a]);
(%o1)                       @{[a, a]@}
(%i2) permutations ([a, a, b]);
(%o2)           @{[a, a, b], [a, b, a], [b, a, a]@}
@end example
@end deffn


@deffn {Función} powerset (@var{a})
@deffnx {Función} powerset (@var{a}, @var{n})

Devuelve el conjunto de todos los subconjuntos del conjunto @var{a}
o un sunconjunto de ellos.

La sentencia @code{powerset(@var{a})} devuelve el conjunto de todos
los subconjuntos de @var{a}, que contendrá @code{2^cardinality(@var{a})}
elementos.

La sentencia @code{powerset(@var{a}, @var{n})} devuelve el conjunto de todos
los subconjuntos de @var{a} de cardinalidad @var{n}.

La función @code{powerset} emite un mensaje de error si @var{a} no
es un conjunto literal o si @var{n} no es un entero no negativo.

Ejemplos:

@c ===beg===
@c powerset ({a, b, c});
@c powerset ({w, x, y, z}, 4);
@c powerset ({w, x, y, z}, 3);
@c powerset ({w, x, y, z}, 2);
@c powerset ({w, x, y, z}, 1);
@c powerset ({w, x, y, z}, 0);
@c ===end===
@example
(%i1) powerset (@{a, b, c@});
(%o1) @{@{@}, @{a@}, @{a, b@}, @{a, b, c@}, @{a, c@}, @{b@}, @{b, c@}, @{c@}@}
(%i2) powerset (@{w, x, y, z@}, 4);
(%o2)                    @{@{w, x, y, z@}@}
(%i3) powerset (@{w, x, y, z@}, 3);
(%o3)     @{@{w, x, y@}, @{w, x, z@}, @{w, y, z@}, @{x, y, z@}@}
(%i4) powerset (@{w, x, y, z@}, 2);
(%o4)   @{@{w, x@}, @{w, y@}, @{w, z@}, @{x, y@}, @{x, z@}, @{y, z@}@}
(%i5) powerset (@{w, x, y, z@}, 1);
(%o5)                 @{@{w@}, @{x@}, @{y@}, @{z@}@}
(%i6) powerset (@{w, x, y, z@}, 0);
(%o6)                         @{@{@}@}
@end example
@end deffn



@deffn {Función} random_permutation (@var{a})

Devuelve una permutación aleatoria del conjunto o lista
@var{a}, siguiendo el algoritmo de Knuth.

El valor devuelto es una lista nueva distinta del argumento,
incluso cuando todos los elementos son iguales. Sin embargo,
los elementos del argumento no se copian.

Ejemplos:

@c ===beg===
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ({x + 1, y + 2, z + 3});
@c random_permutation ({x + 1, y + 2, z + 3});
@c ===end===
@example
(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation (@{x + 1, y + 2, z + 3@});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation (@{x + 1, y + 2, z + 3@});
(%o4)                 [x + 1, y + 2, z + 3]
@end example

@end deffn




@deffn {Función} rreduce (@var{f}, @var{s})
@deffnx {Función} rreduce (@var{f}, @var{s}, @var{init})

Amplía la función binaria @var{F} a n-aria mediante
composición, siendo @var{s} una lista.

La sentencia  @code{rreduce(@var{F}, @var{s})} devuelve
@code{F(s_1, ... F(s_@{n - 2@}, F(s_@{n - 1@}, s_n)))}.
Si se incluye el argumento opcional @var{s_@{n + 1@}},
el resultado equivale a @code{rreduce(@var{F}, endcons(@var{s_@{n + 1@}}, @var{s}))}.

La función @var{F} se aplica primero a los elementos del
extremo derecho de la lista, de ahí el nombre
@code{rreduce}, (@i{right reduce}).

Véanse también @code{lreduce}, @code{xreduce} y @code{tree_reduce}.

Ejemplos:

La función @code{rreduce} sin el argumento opcional,

@c ===beg===
@c rreduce (f, [1, 2, 3]);
@c rreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
@end example

La función @code{rreduce} con el argumento opcional,

@c ===beg===
@c rreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
@end example

La función @code{rreduce} aplicada a operadores binarios de Maxima.
El símbolo @code{/} es el operador división.

@c ===beg===
@c rreduce ("^", args ({a, b, c, d}));
@c rreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) rreduce ("^", args (@{a, b, c, d@}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce ("/", args (@{a, b, c, d@}));
                               a c
(%o2)                          ---
                               b d
@end example
@end deffn


@deffn {Función}  setdifference (@var{a}, @var{b})

Devuelve el conjunto con los elementos del conjunto @var{a} que
no pertenecen al conjunto @var{b}.

La función @code{setdifference} emite un mensaje de error si
@var{a} o @var{b} no son conjuntos.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c, x, y, z};
@c S_2 : {aa, bb, c, x, y, zz};
@c setdifference (S_1, S_2);
@c setdifference (S_2, S_1);
@c setdifference (S_1, S_1);
@c setdifference (S_1, {});
@c setdifference ({}, S_1);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, x, y, z@};
(%o1)                  @{a, b, c, x, y, z@}
(%i2) S_2 : @{aa, bb, c, x, y, zz@};
(%o2)                 @{aa, bb, c, x, y, zz@}
(%i3) setdifference (S_1, S_2);
(%o3)                       @{a, b, z@}
(%i4) setdifference (S_2, S_1);
(%o4)                     @{aa, bb, zz@}
(%i5) setdifference (S_1, S_1);
(%o5)                          @{@}
(%i6) setdifference (S_1, @{@});
(%o6)                  @{a, b, c, x, y, z@}
(%i7) setdifference (@{@}, S_1);
(%o7)                          @{@}
@end example
@end deffn


@deffn {Función} setequalp (@var{a}, @var{b})

Devuelve  @code{true} si los conjuntos @var{a} y @var{b} tienen
el mismo número de elementos
@c $SETEQUALP CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
y @code{is (@var{x} = @var{y})} vale @code{true}
para @code{x} perteneciente a @var{a}
e @code{y} perteneciente a @var{b},
considerados en el orden que determina la función 
@code{listify}. En caso contrario, @code{setequalp}
devuelve @code{false}.

Ejemplos:

@c ===beg===
@c setequalp ({1, 2, 3}, {1, 2, 3});
@c setequalp ({a, b, c}, {1, 2, 3});
@c setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
@c ===end===
@example
(%i1) setequalp (@{1, 2, 3@}, @{1, 2, 3@});
(%o1)                         true
(%i2) setequalp (@{a, b, c@}, @{1, 2, 3@});
(%o2)                         false
(%i3) setequalp (@{x^2 - y^2@}, @{(x + y) * (x - y)@});
(%o3)                         false
@end example
@end deffn


@deffn {Función} setify (@var{a})

Construye un conjunto con los miembros de la lista @var{a}.
Los elementos duplicados de la lista @var{a} son borrados
y ordenados de acuerdo con el predicado @code{orderlessp}.

La función @code{setify} emite un mensaje de error si
@var{a} no es un conjunto literal.

Ejemplos:

@c ===beg===
@c setify ([1, 2, 3, a, b, c]);
@c setify ([a, b, c, a, b, c]);
@c setify ([7, 13, 11, 1, 3, 9, 5]);
@c ===end===
@example
(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  @{1, 2, 3, a, b, c@}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       @{a, b, c@}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                @{1, 3, 5, 7, 9, 11, 13@}
@end example
@end deffn


@deffn {Función} setp (@var{a})

Devuelve @code{true} si y sólo si @var{a} es un conjunto de Maxima.

La función @code{setp} devuelve @code{true} tanto cuando el conjunto
tiene como cuando no tiene elementos repetidos.

@c NOT SURE WE NEED TO MENTION THIS. OK FOR NOW
La función @code{setp} is equivalent to the Maxima function
@code{setp(a) := not atom(a) and op(a) = 'set}.

Ejemplos:

@c ===beg===
@c simp : false;
@c {a, a, a};
@c setp (%);
@c ===end===
@example
(%i1) simp : false;
(%o1)                         false
(%i2) @{a, a, a@};
(%o2)                       @{a, a, a@}
(%i3) setp (%);
(%o3)                         true
@end example
@end deffn


@deffn {Función} set_partitions (@var{a})
@deffnx {Función} set_partitions (@var{a}, @var{n})

Devuelve el conjunto de todas las particiones de @var{a} o
un subconjunto de ellas.

La sentencia @code{set_partitions(@var{a}, @var{n})}
devuelve un conjunto con todas las descomposiciones de @var{a}
en @var{n} conjuntos no vacíos disjuntos.

La sentencia @code{set_partitions(@var{a})} devuelve el
conjunto de todas las particiones.

La función @code{stirling2} devuelve la cardinalidad del conjunto
de las particiones de un conjunto.

Se dice que un conjunto @math{P} es una partición del conjunto @math{S} si verifica

@enumerate
@item
cada elemento de @math{P} es un conjunto no vacío, 
@item
los elementos de @math{P} son disjuntos,
@item
la unión de los elementos de @math{P} es igual a  @math{S}.
@end enumerate

Ejemplos:

El conjunto vacío forma una partición de sí mismo,

@c ===beg===
@c set_partitions ({});
@c ===end===
@example
(%i1) set_partitions (@{@});
(%o1)                         @{@{@}@}
@end example

La cardinalidad del conjunto de particiones de un conjunto puede calcularse con @code{stirling2},

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c cardinality(p) = stirling2 (6, 3);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
@end example

Cada elemento de @code{p} debería tener @var{n} = 3 miembros,

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (cardinality, p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          @{3@}
@end example

Por último, para cada miembro de @code{p}, la unión de sus elementos
debe ser igual a @code{s},

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (lambda ([x], apply (union, listify (x))), p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 @{@{0, 1, 2, 3, 4, 5@}@}
@end example
@end deffn


@deffn {Función} some (@var{f}, @var{a})
@deffnx {Función} some (@var{f}, @var{L_1}, ..., @var{L_n})

Devuelve @code{true} si el predicado @var{f} devuelve @code{true}
para al menos uno de sus argumentos.
Si el segundo argumento es un conjunto, @code{some (@var{f}, @var{a})}
devuelve @code{true} si @code{@var{f}(@var{a_i})} devuelve también
@code{true} para alguno de los @var{a_i} en @var{a}; puede ser que
@code{some} no evalúe @var{f} para todos los @var{a_i} de @var{s}.
Puesto que los conjuntos no están ordenados, @code{some} puede evaluar
@code{@var{f}(@var{a_i})} en cualquier orden.

Dada una o más listas como argumentos,
@code{some (@var{f}, @var{L_1}, ..., @var{L_n})} devuelve @code{true}
si @code{@var{f}(@var{x_1}, ..., @var{x_n})} devuelve también
@code{true} para al menos un  @var{x_1}, ..., @var{x_n} de
@var{L_1}, ..., @var{L_n}, respectivamente; puede ser que
@code{some} no evalúe @var{f} para todos las combinaciones
@var{x_1}, ..., @var{x_n}. La función @code{some} evalúa
las listas en el orden creciente de su índice

Dado un conjunto vacío @code{@{@}} o una lista
vacía como argumentos, @code{some} devuelve @code{false}.

Si la variable global @code{maperror} vale @code{true},
todas las listas @var{L_1}, ..., @var{L_n} deben tener
igual número de elementos. Si @code{maperror} vale
@code{false}, los argumentos se truncan para tener todos
el número de elementos de la lista más corta. 

Los valores que devuelve el predicado @var{f} cuando toman 
(mediante @code{is}) un valor diferente a @code{true} y @code{false}
se controlan con la variable global @code{prederror}.
Si @code{prederror} vale @code{true}, tales valores se
consideran como @code{false}.
Si @code{prederror} vale @code{false}, tales valores se
consideran como desconocidos (@code{unknown}).

Ejemplos:

La función @code{some} aplicada a un único conjunto.
El predicado es una función de un argumento,

@c ===beg===
@c some (integerp, {1, 2, 3, 4, 5, 6});
@c some (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) some (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) some (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         true
@end example

La función @code{some} aplicada a dos listas.
El predicado es una función de dos argumentos,

@c ===beg===
@c some ("=", [a, b, c], [a, b, c]);
@c some ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) some ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Las respuestas del predicado @var{f} que se evalúan 
a cualquier cosa diferente de @code{true} y @code{false}
están controlados por la variable global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z],
@c                 [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c prederror : true;
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
@end example
@end deffn


@deffn {Función} stirling1 (@var{n}, @var{m})

Es el número de Stirling de primera especie.

Si tanto @var{n} como @var{m} son enteros no negativos,
el valor que toma @code{stirling1 (@var{n}, @var{m})}
es el número de permutaciones de un conjunto de
@var{n} elementos con @var{m} ciclos. Para más detalles,
véase Graham, Knuth and Patashnik @i{Concrete Mathematics}.
Maxima utiliza una relación recursiva para definir
@code{stirling1 (@var{n}, @var{m})} para @var{m} menor
que 0; no está definida para @var{n} menor que 0 ni
para argumentos no enteros.

La función @code{stirling1} es simplificadora. Maxima
reconoce las siguientes identidades:

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling1(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling1(n, n) = 1} (Ref. [1])
@item
@math{stirling1(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling1(n + 1, 0) = 0} (Ref. [1])
@item
@math{stirling1(n + 1, 1) = n!} (Ref. [1])
@item
@math{stirling1(n + 1, 2) = 2^n  - 1} (Ref. [1])
@end enumerate

Estas identidades se aplican cuando los argumentos son enteros
literales o símbolos declarados como enteros y
el primer argumento es no negativo. La función @code{stirling1}
no simplifica para argumentos no enteros.

Referencias:

[1] Donald Knuth, @i{The Art of Computer Programming,}
Tercera Edición, Volumen 1, Sección 1.2.6, Ecuaciones 48, 49 y 50.

Ejemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
@end example

La función @code{stirling1} no simplifica en caso de argumentos no enteros,

@c ===beg===
@c stirling1 (sqrt(2), sqrt(2));
@c ===end===
@example
(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
@end example

Maxima aplicas algunas identidades a @code{stirling1},

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n + 1, n);
@c stirling1 (n + 1, 1);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
@end example
@end deffn


@deffn {Función} stirling2 (@var{n}, @var{m})

Es el número de Stirling de segunda especie.

Si @var{n} y @var{m} son enteros no negativos,
@code{stirling2 (@var{n}, @var{m})} es el número
de formas en las que se puede particionar un conjunto
de cardinal @var{n} en @var{m} subconjuntos disjuntos.
Maxima utiliza una relación recursiva para definir
@code{stirling2 (@var{n}, @var{m})} con @var{m} menor
que 0; la función no está definida para  @var{n}
menor que 0  ni para argumentos no enteros.

La función @code{stirling2} es simplificadora. Maxima
reconoce las siguientes identidades:

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling2(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling2(n, n) = 1} (Ref. [1])
@item
@math{stirling2(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling2(n + 1, 1) = 1} (Ref. [1])
@item
@math{stirling2(n + 1, 2) = 2^n  - 1} (Ref. [1])
@item
@math{stirling2(n, 0) = kron_delta(n, 0)} (Ref. [2])
@item
@math{stirling2(n, m) = 0} when @math{m > n} (Ref. [2])
@item
@math{stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!}
si @math{m} y @math{n} son enteros y @math{n} no negativo. (Ref. [3])
@end enumerate

Estas identidades se aplican cuando los argumentos son enteros
literales o símbolos declarados como enteros y
el primer argumento es no negativo. La función @code{stirling2}
no simplifica para argumentos no enteros.

Referencias:

[1] Donald Knuth. @i{The Art of Computer Programming},
Tercera Edición, Volumen 1, Sección 1.2.6, Ecuaciones 48, 49 y 50.

[2] Graham, Knuth y Patashnik. @i{Concrete Mathematics}, Tabla 264.

[3] Abramowitz y Stegun. @i{Handbook of Mathematical Functions}, Sección 24.1.4.

Ejemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
@end example

La función @code{stirling2} no simplifica en caso de argumentos no enteros,

@c ===beg===
@c stirling2 (%pi, %pi);
@c ===end===
@example
(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
@end example

Maxima aplicas algunas identidades a @code{stirling2},

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n + 9, n + 8);
@c stirling2 (n + 1, 2);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
@end example
@end deffn


@deffn {Función} subset (@var{a}, @var{f})

Devuelve el subconjunto del conjunto @var{a} que satisface el predicado @var{f}.

La función @code{subset} devuelve el conjunto que contiene a los
elementos de @var{a} para los cuales @var{f} devuelve un resultado
diferente de @code{false}. La función @code{subset} no aplica
@code{is} al valor retornado por @var{f}.

La función @code{subset} emite un mensaje de error si @var{a}
no es un conjunto literal.

Véase también @code{partition_set}.

Ejemplos:

@c ===beg===
@c subset ({1, 2, x, x + y, z, x + y + z}, atom);
@c subset ({1, 2, 7, 8, 9, 14}, evenp);
@c ===end===
@example
(%i1) subset (@{1, 2, x, x + y, z, x + y + z@}, atom);
(%o1)                     @{1, 2, x, z@}
(%i2) subset (@{1, 2, 7, 8, 9, 14@}, evenp);
(%o2)                      @{2, 8, 14@}
@end example
@end deffn


@deffn {Función} subsetp (@var{a}, @var{b})

Devuelve @code{true} si y sólo si el conjunto @var{a} es un subconjunto de @var{b}.

La función @code{subsetp} emite un mensaje de error si
cualesquiera @var{a} o @var{b} no es un conjunto literal.

Ejemplos:

@c ===beg===
@c subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
@c subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) subsetp (@{1, 2, 3@}, @{a, 1, b, 2, c, 3@});
(%o1)                         true
(%i2) subsetp (@{a, 1, b, 2, c, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example
@end deffn



@deffn {Función} symmdifference (@var{a_1}, @dots{}, @var{a_n})

Devuelve la diferencia simétrica de los conjuntos @code{ @var{a_1}, @dots{}, @var{a_n}}.

Dados dos argumentos, @code{symmdifference (@var{a}, @var{b})} equivale a
@code{union (setdifference (@var{a}, @var{b}), setdifference (@var{b}, @var{a}))}.

La función @code{symmdifference} emite un mensaje de error si alguno de
su argumentos no es un conjunto literal.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c};
@c S_2 : {1, b, c};
@c S_3 : {a, b, z};
@c symmdifference ();
@c symmdifference (S_1);
@c symmdifference (S_1, S_2);
@c symmdifference (S_1, S_2, S_3);
@c symmdifference ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) S_2 : @{1, b, c@};
(%o2)                       @{1, b, c@}
(%i3) S_3 : @{a, b, z@};
(%o3)                       @{a, b, z@}
(%i4) symmdifference ();
(%o4)                          @{@}
(%i5) symmdifference (S_1);
(%o5)                       @{a, b, c@}
(%i6) symmdifference (S_1, S_2);
(%o6)                        @{1, a@}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                       @{1, b, z@}
(%i8) symmdifference (@{@}, S_1, S_2, S_3);
(%o8)                       @{1,b, z@}
@end example
@end deffn

@c TREE_REDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE WANT ONLY LISTS; STRANGE
@deffn {Función} tree_reduce (@var{F}, @var{s})
@deffnx {Función} tree_reduce (@var{F}, @var{s}, @var{s_0})


Amplía la función binaria @var{F} a n-aria, siendo @var{s} una lista.

La función @code{tree_reduce} equivale a lo suguiente:
Aplicar @var{F} a pares sucesivos de elementos para formar
una nueva lista @code{[@var{F}(@var{s_1}, @var{s_2}), @var{F}(@var{s_3}, @var{s_4}), ...]},
llevando el elemento final sin cambiar si el número de elementos es impar;
después repetir hasta que la lista se reduzca a un único elemento,
que es el valor de retorno.

Cuando está presente el argumento opcional @var{s_0},
el resultado equivale a @code{tree_reduce(@var{F}, cons(@var{s_0}, @var{s})}.

Para la suma de números decimales en coma flotante,
@code{tree_reduce} puede devolver una suma que tenga un error
de redondeo menor que el conseguido por @code{rreduce} o @code{lreduce}.

Los elementos de @var{s} y los resultados parciales pueden colocarse
en un árbol binario de mínima profundidad, de ahí
el nombre de @i{tree_reduce}.

Ejemplos:

La función @code{tree_reduce} aplicada a una lista con un número
par de elementos,

@c ===beg===
@c tree_reduce (f, [a, b, c, d]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
@end example

La función @code{tree_reduce} aplicada a una lista con un número
impar de elementos,

@c ===beg===
@c tree_reduce (f, [a, b, c, d, e]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
@end example
@end deffn


@deffn {Function} union (@var{a_1}, ..., @var{a_n})

Devuelve la unión de los conjuntos @var{a_1} hasta @var{a_n}.

La sentencia @code{union()} (sin argumentos) devuelve el
conjunto vacío.

La función @code{union} emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c + d, %e};
@c S_2 : {%pi, %i, %e, c + d};
@c S_3 : {17, 29, 1729, %pi, %i};
@c union ();
@c union (S_1);
@c union (S_1, S_2);
@c union (S_1, S_2, S_3);
@c union ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c + d, %e@};
(%o1)                   @{%e, a, b, d + c@}
(%i2) S_2 : @{%pi, %i, %e, c + d@};
(%o2)                 @{%e, %i, %pi, d + c@}
(%i3) S_3 : @{17, 29, 1729, %pi, %i@};
(%o3)                @{17, 29, 1729, %i, %pi@}
(%i4) union ();
(%o4)                          @{@}
(%i5) union (S_1);
(%o5)                   @{%e, a, b, d + c@}
(%i6) union (S_1, S_2);
(%o6)              @{%e, %i, %pi, a, b, d + c@}
(%i7) union (S_1, S_2, S_3);
(%o7)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
(%i8) union (@{@}, S_1, S_2, S_3);
(%o8)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
@end example
@end deffn


@deffn {Función} xreduce (@var{F}, @var{s})
@deffnx {Función} xreduce (@var{F}, @var{s}, @var{s_0})



Amplía la función @var{F} a n-aria mediante
composición; si @var{F} ya es n-aria, aplica @var{F} a @var{s}.
Si @var{F} no es n-aria, @code{xreduce} equivale a @code{lreduce}.
El argumento @var{s} debe ser una lista.

Funciones n-arias reconocidas por Maxima son la suma @code{+}, la
multiplicación @code{*}, @code{and}, @code{or}, @code{max},
@code{min} y @code{append}. Las funciones también se pueden
declarar n-arias mediante @code{declare(@var{F}, nary)};
para estas funciones, @code{xreduce} será más rápida que
@code{rreduce} o @code{lreduce}.

Cuando está presente el argumento opcional @var{s_0},
el resultado equivale a @code{xreduce(@var{s}, cons(@var{s_0}, @var{s}))}.

La suma de números decimales en coma flotante no es exactamente asociativa;
aún así, @code{xreduce} aplica la suma n-aria cuando @var{s}
contiene números en coma flotante.

Ejemplos:

La función @code{xreduce} aplicada a una función n-aria;
@code{F} es invocada una sóla vez, con todos sus argumentos,

@c ===beg===
@c declare (F, nary);
@c F ([L]) := L;
@c xreduce (F, [a, b, c, d, e]);
@c ===end===
@example
(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[("[", simp), a], b], c], d], e]
@end example

La función @code{xreduce} aplicada a una función que se desconoce si
es n-aria; @code{G} es invocada varias veces, con dos argumentos de cada vez,

@c ===beg===
@c G ([L]) := L;
@c xreduce (G, [a, b, c, d, e]);
@c lreduce (G, [a, b, c, d, e]);
@c ===end===
@example
(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[("[", simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
@end example
@end deffn








